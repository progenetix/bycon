import { GenericFilehandle } from 'generic-filehandle';
import { Observable } from 'rxjs';
import { BlockView } from './block-view';
export interface Feature {
    start: number;
    end: number;
    score: number;
    rest?: string;
    minScore?: number;
    maxScore?: number;
    summary?: boolean;
    uniqueId?: string;
    field?: number;
}
interface Statistics {
    scoreSum: number;
    basesCovered: number;
    scoreSumSquares: number;
}
interface RefInfo {
    name: string;
    id: number;
    length: number;
}
export interface Header {
    autoSql: string;
    totalSummary: Statistics;
    zoomLevels: any;
    unzoomedIndexOffset: number;
    unzoomedDataOffset: number;
    definedFieldCount: number;
    uncompressBufSize: number;
    chromTreeOffset: number;
    fileSize: number;
    extHeaderOffset: number;
    isBigEndian: boolean;
    fileType: string;
    refsByName: {
        [key: string]: number;
    };
    refsByNumber: {
        [key: number]: RefInfo;
    };
}
export interface RequestOptions {
    signal?: AbortSignal;
    headers?: Record<string, string>;
    [key: string]: unknown;
}
export declare abstract class BBI {
    protected bbi: GenericFilehandle;
    private headerP?;
    protected renameRefSeqs: (a: string) => string;
    getHeader(opts?: RequestOptions): Promise<Header>;
    constructor(args: {
        filehandle?: GenericFilehandle;
        path?: string;
        url?: string;
        renameRefSeqs?: (a: string) => string;
    });
    private _getHeader;
    private _getMainHeader;
    private _isBigEndian;
    private _readChromTree;
    protected getUnzoomedView(opts?: RequestOptions): Promise<BlockView>;
    protected abstract getView(scale: number, opts?: RequestOptions): Promise<BlockView>;
    /**
     * Gets features from a BigWig file
     *
     * @param refName - The chromosome name
     * @param start - The start of a region
     * @param end - The end of a region
     * @param opts - An object containing basesPerSpan (e.g. pixels per basepair) or scale used to infer the zoomLevel to use
     */
    getFeatureStream(refName: string, start: number, end: number, opts?: RequestOptions & {
        scale?: number;
        basesPerSpan?: number;
    }): Promise<Observable<Feature[]>>;
    getFeatures(refName: string, start: number, end: number, opts?: RequestOptions & {
        scale?: number;
        basesPerSpan?: number;
    }): Promise<Feature[]>;
}
export {};
