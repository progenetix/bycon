import { GenericFilehandle } from 'generic-filehandle';
interface BaseOpts {
    signal?: AbortSignal;
}
interface IndexEntry {
    offset: number;
    lineBytes: number;
    lineLength: number;
    length: number;
}
declare function readFAI(fai: GenericFilehandle, opts?: BaseOpts): Promise<{
    name: {
        [k: string]: {
            id: number;
            name: string;
            length: number;
            start: number;
            end: number;
            offset: number;
            lineLength: number;
            lineBytes: number;
        };
    };
    id: {
        [k: string]: {
            id: number;
            name: string;
            length: number;
            start: number;
            end: number;
            offset: number;
            lineLength: number;
            lineBytes: number;
        };
    };
}>;
export default class IndexedFasta {
    fasta: GenericFilehandle;
    fai: GenericFilehandle;
    indexes?: ReturnType<typeof readFAI>;
    constructor({ fasta, fai, path, faiPath, }: {
        fasta?: GenericFilehandle;
        fai?: GenericFilehandle;
        path?: string;
        faiPath?: string;
    });
    _getIndexes(opts?: BaseOpts): Promise<{
        name: {
            [k: string]: {
                id: number;
                name: string;
                length: number;
                start: number;
                end: number;
                offset: number;
                lineLength: number;
                lineBytes: number;
            };
        };
        id: {
            [k: string]: {
                id: number;
                name: string;
                length: number;
                start: number;
                end: number;
                offset: number;
                lineLength: number;
                lineBytes: number;
            };
        };
    }>;
    /**
     * @returns {array[string]} array of string sequence
     * names that are present in the index, in which the
     * array index indicates the sequence ID, and the value
     * is the sequence name
     */
    getSequenceNames(opts?: BaseOpts): Promise<string[]>;
    /**
     * @returns {array[string]} array of string sequence
     * names that are present in the index, in which the
     * array index indicates the sequence ID, and the value
     * is the sequence name
     */
    getSequenceSizes(opts?: BaseOpts): Promise<{
        [key: string]: number;
    }>;
    /**
     * @returns {array[string]} array of string sequence
     * names that are present in the index, in which the
     * array index indicates the sequence ID, and the value
     * is the sequence name
     */
    getSequenceSize(seqName: string, opts?: BaseOpts): Promise<number>;
    /**
     *
     * @param {string} name
     * @returns {Promise[boolean]} true if the file contains the given reference sequence name
     */
    hasReferenceSequence(name: string, opts?: BaseOpts): Promise<boolean>;
    /**
     *
     * @param {number} seqId
     * @param {number} min
     * @param {number} max
     */
    getResiduesById(seqId: number, min: number, max: number, opts?: BaseOpts): Promise<string | undefined>;
    /**
     * @param {string} seqName
     * @param {number} min
     * @param {number} max
     */
    getResiduesByName(seqName: string, min: number, max: number, opts?: BaseOpts): Promise<string | undefined>;
    getSequence(seqName: string, min: number, max: number, opts?: BaseOpts): Promise<string | undefined>;
    _fetchFromIndexEntry(indexEntry: IndexEntry, min: number | undefined, max: number, opts?: BaseOpts): Promise<string>;
}
export {};
