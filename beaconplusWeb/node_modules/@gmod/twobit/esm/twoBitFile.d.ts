import { GenericFilehandle } from 'generic-filehandle';
declare type ParserName = 'header' | 'index' | 'record1' | 'record2' | 'record3';
export default class TwoBitFile {
    private filehandle;
    private isBigEndian?;
    private version?;
    /**
     * @param {object} args
     * @param {string} [args.path] filesystem path for the .2bit file to open
     * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.
     *  Only needs to support `filehandle.read(buffer, offset, length, position)`
     */
    constructor({ filehandle, path, }: {
        filehandle?: GenericFilehandle;
        path?: string;
    });
    _getParser(name: ParserName): Promise<any>;
    _detectEndianness(): Promise<void>;
    /**
     * @private
     * detects the file's endianness and instantiates our binary parsers accordingly
     */
    _getParsers(): Promise<{
        header: any;
        index: any;
        record1: any;
        record2: any;
        record3: any;
    }>;
    /**
     * @returns {Promise} for object with the file's header information, like
     *  `{ magic: 0x1a412743, version: 0, sequenceCount: 42, reserved: 0 }`
     */
    getHeader(): Promise<any>;
    /**
     * @returns {Promise} for object with the file's index of offsets, like `{ seqName: fileOffset, ...}`
     */
    getIndex(): Promise<{
        [key: string]: number;
    }>;
    /**
     * @returns {Promise} for an array of string sequence names that are found in the file
     */
    getSequenceNames(): Promise<string[]>;
    /**
     * @returns {Promise} for an object listing the lengths of all sequences like `{seqName: length, ...}`
     */
    getSequenceSizes(): Promise<{
        [key: string]: number;
    }>;
    /**
     * @param {string} seqName name of the sequence
     * @returns {Promise} for the sequence's length, or undefined if it is not in the file
     */
    getSequenceSize(seqName: string): Promise<any>;
    _getSequenceSize(offset: number): Promise<any>;
    _getSequenceRecord(offset: number): Promise<{
        dnaSize: any;
        nBlocks: {
            starts: any;
            sizes: any;
        };
        maskBlocks: {
            starts: any;
            sizes: any;
        };
        dnaPosition: number;
    }>;
    _parseItem(offset: number, length: number, parserName: ParserName): Promise<any>;
    /**
     * @param {string} seqName name of the sequence you want
     * @param {number} [regionStart] optional 0-based half-open start of the sequence region to fetch.
     * @param {number} [regionEnd] optional 0-based half-open end of the sequence region to fetch. defaults to end of the sequence
     * @returns {Promise} for a string of sequence bases
     */
    getSequence(seqName: string, regionStart: number | undefined, regionEnd: number): Promise<string | undefined>;
    _getOverlappingBlocks(regionStart: number, regionEnd: number, blockStarts: number[], blockSizes: number[]): any[];
}
export {};
