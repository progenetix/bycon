import GenericNCList from './nclist';
/**
 * Sequence feature store using nested containment
 * lists held in JSON files that are lazily read.
 *
 * @param {object} args constructor args
 * @param {string} args.baseUrl base URL for resolving relative URLs
 * @param {string} args.urlTemplate Template string for
 *  the root file of each reference sequence. The reference sequence
 *  name will be interpolated into this string where `{refseq}` appears.
 * @param {function} args.readFile function to use for reading remote from URLs.
 */
export default class NCListStore {
    constructor({ baseUrl, urlTemplate, readFile, cacheSize }: {
        baseUrl: any;
        urlTemplate: any;
        readFile: any;
        cacheSize?: number | undefined;
    });
    makeNCList(): GenericNCList;
    loadNCList(refData: any, trackInfo: any, listUrl: any): void;
    getDataRoot(refName: any): any;
    fetchDataRoot(refName: any): Promise<{
        nclist: GenericNCList;
        stats: {
            featureCount: any;
        };
    }>;
    parseTrackInfo(trackInfo: any, url: any): {
        nclist: GenericNCList;
        stats: {
            featureCount: any;
        };
    };
    getRegionStats(query: any): Promise<any>;
    /**
     * fetch binned counts of feature coverage in the given region.
     *
     * @param {object} query
     * @param {string} query.refName reference sequence name
     * @param {number} query.start region start
     * @param {number} query.end region end
     * @param {number} query.numBins number of bins desired in the feature counts
     * @param {number} query.basesPerBin number of bp desired in each feature counting bin
     * @returns {object} as:
     *    `{ bins: hist, stats: statEntry }`
     */
    getRegionFeatureDensities({ refName, start, end, numBins, basesPerBin, }: {
        refName: any;
        start: any;
        end: any;
        numBins: any;
        basesPerBin: any;
    }): Promise<{
        bins: any;
        stats: any;
    }>;
    /**
     * Fetch features in a given region. This method is an asynchronous generator
     * yielding feature objects.
     *
     * @param {object} args
     * @param {string} args.refName reference sequence name
     * @param {number} args.start start of region. 0-based half-open.
     * @param {number} args.end end of region. 0-based half-open.
     * @yields {object}
     */
    getFeatures({ refName, start, end }: {
        refName: any;
        start: any;
        end: any;
    }): AsyncGenerator<any, void, unknown>;
    decorateFeature(accessors: any, feature: any, id: any, parent: any): void;
}
