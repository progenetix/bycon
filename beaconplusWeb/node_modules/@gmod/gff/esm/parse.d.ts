import * as GFF3 from './util';
export declare class FASTAParser {
    seqCallback: (sequence: GFF3.GFF3Sequence) => void;
    currentSequence: {
        id: string;
        sequence: string;
        description?: string;
    } | undefined;
    constructor(seqCallback: (sequence: GFF3.GFF3Sequence) => void);
    addLine(line: string): void;
    private _flush;
    finish(): void;
}
interface ParserArgs {
    featureCallback?(feature: GFF3.GFF3Feature): void;
    endCallback?(): void;
    commentCallback?(comment: GFF3.GFF3Comment): void;
    errorCallback?(error: string): void;
    directiveCallback?(directive: GFF3.GFF3Directive): void;
    sequenceCallback?(sequence: GFF3.GFF3Sequence): void;
    bufferSize?: number;
    disableDerivesFromReferences?: boolean;
}
export default class Parser {
    featureCallback: (feature: GFF3.GFF3Feature) => void;
    endCallback: () => void;
    commentCallback: (comment: GFF3.GFF3Comment) => void;
    errorCallback: (error: string) => void;
    disableDerivesFromReferences: boolean;
    directiveCallback: (directive: GFF3.GFF3Directive) => void;
    sequenceCallback: (sequence: GFF3.GFF3Sequence) => void;
    bufferSize: number;
    fastaParser: FASTAParser | undefined;
    eof: boolean;
    lineNumber: number;
    private _underConstructionTopLevel;
    private _underConstructionById;
    private _completedReferences;
    private _underConstructionOrphans;
    constructor(args: ParserArgs);
    addLine(line: string): void;
    finish(): void;
    private _emitItem;
    private _enforceBufferSizeLimit;
    /**
     * return all under-construction features, called when we know
     * there will be no additional data to attach to them
     */
    private _emitAllUnderConstructionFeatures;
    private _bufferLine;
    private _resolveReferencesTo;
    private _parseError;
    private _resolveReferencesFrom;
}
export {};
