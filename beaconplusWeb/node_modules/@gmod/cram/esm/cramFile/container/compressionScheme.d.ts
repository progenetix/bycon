import CramCodec from '../codecs/_base';
import { CramCompressionHeader } from '../sectionParsers';
import { CramEncoding } from '../encoding';
import { DataSeriesEncodingKey, DataSeriesEncodingMap } from '../codecs/dataSeriesTypes';
declare const dataSeriesTypes: {
    readonly BF: "int";
    readonly CF: "int";
    readonly RI: "int";
    readonly RL: "int";
    readonly AP: "int";
    readonly RG: "int";
    readonly MF: "int";
    readonly NS: "int";
    readonly NP: "int";
    readonly TS: "int";
    readonly NF: "int";
    readonly TC: "byte";
    readonly TN: "int";
    readonly FN: "int";
    readonly FC: "byte";
    readonly FP: "int";
    readonly BS: "byte";
    readonly IN: "byteArray";
    readonly SC: "byteArray";
    readonly DL: "int";
    readonly BA: "byte";
    readonly BB: "byteArray";
    readonly RS: "int";
    readonly PD: "int";
    readonly HC: "int";
    readonly MQ: "int";
    readonly RN: "byteArray";
    readonly QS: "byte";
    readonly QQ: "byteArray";
    readonly TL: "int";
};
export type DataSeriesTypes = typeof dataSeriesTypes;
type DataSeriesCache = {
    [K in DataSeriesEncodingKey]?: CramCodec<DataSeriesTypes[K]>;
};
export default class CramContainerCompressionScheme {
    readNamesIncluded: boolean;
    APdelta: boolean;
    referenceRequired: boolean;
    tagIdsDictionary: Record<number, string[]>;
    substitutionMatrix: string[][];
    dataSeriesCodecCache: DataSeriesCache;
    tagCodecCache: Record<string, CramCodec>;
    tagEncoding: Record<string, CramEncoding>;
    dataSeriesEncoding: DataSeriesEncodingMap;
    private preservation;
    private _endPosition;
    private _size;
    constructor(content: CramCompressionHeader);
    /**
     * @param {string} tagName three-character tag name
     * @private
     */
    getCodecForTag(tagName: string): CramCodec;
    /**
     *
     * @param {number} tagListId ID of the tag list to fetch from the tag dictionary
     * @private
     */
    getTagNames(tagListId: number): string[];
    getCodecForDataSeries<TDataSeries extends DataSeriesEncodingKey>(dataSeriesName: TDataSeries): CramCodec<DataSeriesTypes[TDataSeries]> | undefined;
    toJSON(): any;
}
export {};
