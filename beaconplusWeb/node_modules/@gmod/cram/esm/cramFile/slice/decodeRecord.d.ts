import { ReadFeature } from '../record';
import CramSlice, { SliceHeader } from './index';
import CramContainerCompressionScheme, { DataSeriesTypes } from '../container/compressionScheme';
import { CramFileBlock } from '../file';
import { Cursors, DataTypeMapping } from '../codecs/_base';
import { DataSeriesEncodingKey } from '../codecs/dataSeriesTypes';
export type DataSeriesDecoder = <T extends DataSeriesEncodingKey>(dataSeriesName: T) => DataTypeMapping[DataSeriesTypes[T]];
export default function decodeRecord(slice: CramSlice, decodeDataSeries: DataSeriesDecoder, compressionScheme: CramContainerCompressionScheme, sliceHeader: SliceHeader, coreDataBlock: CramFileBlock, blocksByContentId: Record<number, CramFileBlock>, cursors: Cursors, majorVersion: number, recordNumber: number): {
    readLength: number;
    sequenceId: number;
    cramFlags: number;
    flags: number;
    alignmentStart: number;
    readGroupId: number;
    readName: string | undefined;
    mateToUse: {
        mateFlags: number;
        mateSequenceId: number;
        mateAlignmentStart: number;
        mateReadName: string | undefined;
    } | undefined;
    templateSize: number | undefined;
    mateRecordNumber: number | undefined;
    readFeatures: ReadFeature[] | undefined;
    lengthOnRef: number | undefined;
    mappingQuality: number | undefined;
    qualityScores: number[] | null | undefined;
    readBases: string | null | undefined;
    tags: Record<string, any>;
};
