import CramContainerCompressionScheme from './container/compressionScheme';
import decodeRecord from './slice/decodeRecord';
export interface RefRegion {
    start: number;
    end: number;
    seq: string;
}
export interface ReadFeature {
    code: string;
    pos: number;
    refPos: number;
    data: any;
    ref?: string;
    sub?: string;
}
export interface MateRecord {
    readName?: string;
    sequenceId: number;
    alignmentStart: number;
    flags?: number;
    uniqueId?: number;
}
export declare const BamFlags: readonly [readonly [1, "Paired"], readonly [2, "ProperlyPaired"], readonly [4, "SegmentUnmapped"], readonly [8, "MateUnmapped"], readonly [16, "ReverseComplemented"], readonly [32, "MateReverseComplemented"], readonly [64, "Read1"], readonly [128, "Read2"], readonly [256, "Secondary"], readonly [512, "FailedQc"], readonly [1024, "Duplicate"], readonly [2048, "Supplementary"]];
export declare const CramFlags: readonly [readonly [1, "PreservingQualityScores"], readonly [2, "Detached"], readonly [4, "WithMateDownstream"], readonly [8, "DecodeSequenceAsStar"]];
export declare const MateFlags: readonly [readonly [1, "OnNegativeStrand"], readonly [2, "Unmapped"]];
type FlagsDecoder<Type> = {
    [Property in Type as `is${Capitalize<string & Property>}`]: (flags: number) => boolean;
};
type FlagsEncoder<Type> = {
    [Property in Type as `set${Capitalize<string & Property>}`]: (flags: number) => number;
};
export declare const BamFlagsDecoder: FlagsDecoder<"Paired" | "ProperlyPaired" | "SegmentUnmapped" | "MateUnmapped" | "ReverseComplemented" | "MateReverseComplemented" | "Read1" | "Read2" | "Secondary" | "FailedQc" | "Duplicate" | "Supplementary"> & FlagsEncoder<"Paired" | "ProperlyPaired" | "SegmentUnmapped" | "MateUnmapped" | "ReverseComplemented" | "MateReverseComplemented" | "Read1" | "Read2" | "Secondary" | "FailedQc" | "Duplicate" | "Supplementary">;
export declare const CramFlagsDecoder: FlagsDecoder<"PreservingQualityScores" | "Detached" | "WithMateDownstream" | "DecodeSequenceAsStar"> & FlagsEncoder<"PreservingQualityScores" | "Detached" | "WithMateDownstream" | "DecodeSequenceAsStar">;
export declare const MateFlagsDecoder: FlagsDecoder<"OnNegativeStrand" | "Unmapped"> & FlagsEncoder<"OnNegativeStrand" | "Unmapped">;
/**
 * Class of each CRAM record returned by this API.
 */
export default class CramRecord {
    tags: Record<string, string>;
    flags: number;
    cramFlags: number;
    readBases?: string | null;
    _refRegion?: RefRegion;
    readFeatures?: ReadFeature[];
    alignmentStart: number;
    lengthOnRef: number | undefined;
    readLength: number;
    templateLength?: number;
    templateSize?: number;
    readName?: string;
    mateRecordNumber?: number;
    mate?: MateRecord;
    uniqueId: number;
    sequenceId: number;
    readGroupId: number;
    mappingQuality: number | undefined;
    qualityScores: number[] | null | undefined;
    constructor({ flags, cramFlags, readLength, mappingQuality, lengthOnRef, qualityScores, mateRecordNumber, readBases, readFeatures, mateToUse, readGroupId, readName, sequenceId, uniqueId, templateSize, alignmentStart, tags, }: ReturnType<typeof decodeRecord> & {
        uniqueId: number;
    });
    /**
     * @returns {boolean} true if the read is paired, regardless of whether both segments are mapped
     */
    isPaired(): boolean;
    /** @returns {boolean} true if the read is paired, and both segments are mapped */
    isProperlyPaired(): boolean;
    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */
    isSegmentUnmapped(): boolean;
    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */
    isMateUnmapped(): boolean;
    /** @returns {boolean} true if the read is mapped to the reverse strand */
    isReverseComplemented(): boolean;
    /** @returns {boolean} true if the mate is mapped to the reverse strand */
    isMateReverseComplemented(): boolean;
    /** @returns {boolean} true if this is read number 1 in a pair */
    isRead1(): boolean;
    /** @returns {boolean} true if this is read number 2 in a pair */
    isRead2(): boolean;
    /** @returns {boolean} true if this is a secondary alignment */
    isSecondary(): boolean;
    /** @returns {boolean} true if this read has failed QC checks */
    isFailedQc(): boolean;
    /** @returns {boolean} true if the read is an optical or PCR duplicate */
    isDuplicate(): boolean;
    /** @returns {boolean} true if this is a supplementary alignment */
    isSupplementary(): boolean;
    /**
     * @returns {boolean} true if the read is detached
     */
    isDetached(): boolean;
    /** @returns {boolean} true if the read has a mate in this same CRAM segment */
    hasMateDownStream(): boolean;
    /** @returns {boolean} true if the read contains qual scores */
    isPreservingQualityScores(): boolean;
    /** @returns {boolean} true if the read has no sequence bases */
    isUnknownBases(): boolean;
    /**
     * Get the original sequence of this read.
     * @returns {String} sequence basepairs
     */
    getReadBases(): string | null | undefined;
    /**
     * Get the pair orientation of a paired read. Adapted from igv.js
     * @returns {String} of paired orientatin
     */
    getPairOrientation(): string | null;
    /**
     * Annotates this feature with the given reference sequence basepair
     * information. This will add a `sub` and a `ref` item to base
     * substitution read features given the actual substituted and reference
     * base pairs, and will make the `getReadSequence()` method work.
     *
     * @param {object} refRegion
     * @param {number} refRegion.start
     * @param {number} refRegion.end
     * @param {string} refRegion.seq
     * @param {CramContainerCompressionScheme} compressionScheme
     * @returns {undefined} nothing
     */
    addReferenceSequence(refRegion: RefRegion, compressionScheme: CramContainerCompressionScheme): void;
    toJSON(): any;
}
export {};
