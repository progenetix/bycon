/// <reference path="../../src/typings/binary-parser.d.ts" />
import { Parser } from '@gmod/binary-parser';
import { TupleOf } from '../typescript';
import { ParsedItem } from './util';
import { DataSeriesEncodingMap } from './codecs/dataSeriesTypes';
import { CramEncoding } from './encoding';
declare const cramFileDefinition: {
    parser: Parser<unknown>;
    maxLength: number;
};
export type CramTagDictionary = string[][];
export interface CramPreservationMap {
    MI: boolean;
    UI: boolean;
    PI: boolean;
    RN: boolean;
    AP: boolean;
    RR: boolean;
    SM: [number, number, number, number, number];
    TD: CramTagDictionary;
}
export interface MappedSliceHeader {
    refSeqId: number;
    refSeqStart: number;
    refSeqSpan: number;
    numRecords: number;
    recordCounter: number;
    numBlocks: number;
    numContentIds: number;
    contentIds: number[];
    refBaseBlockId: number;
    md5: TupleOf<number, 16>;
}
export interface UnmappedSliceHeader {
    numRecords: number;
    recordCounter: number;
    numBlocks: number;
    numContentIds: number;
    contentIds: number[];
    md5: TupleOf<number, 16>;
}
export declare function isMappedSliceHeader(header: MappedSliceHeader | UnmappedSliceHeader): header is MappedSliceHeader;
export type CompressionMethod = 'raw' | 'gzip' | 'bzip2' | 'lzma' | 'rans' | 'rans4x16' | 'arith' | 'fqzcomp' | 'tok3';
export interface BlockHeader {
    compressionMethod: CompressionMethod;
    contentType: 'FILE_HEADER' | 'COMPRESSION_HEADER' | 'MAPPED_SLICE_HEADER' | 'UNMAPPED_SLICE_HEADER' | 'EXTERNAL_DATA' | 'CORE_DATA';
    contentId: number;
    compressedSize: number;
    uncompressedSize: number;
}
export type CramCompressionHeader = ParsedItem<{
    preservation: CramPreservationMap;
    dataSeriesEncoding: DataSeriesEncodingMap;
    tagEncoding: Record<string, CramEncoding>;
}>;
declare function getSectionParsers(majorVersion: number): {
    cramFileDefinition: {
        parser: Parser<{
            magic: string;
            majorVersion: number;
            minorVersion: number;
            fileId: string;
        }>;
        maxLength: number;
    };
    cramContainerHeader1: {
        parser: Parser<{
            length: number;
            refSeqId: number;
            refSeqStart: number;
            alignmentSpan: number;
            numRecords: number;
            recordCounter: number;
            numBases: number;
            numBlocks: number;
            numLandmarks: number;
        }>;
        maxLength: number;
    };
    cramContainerHeader2: {
        parser: Parser<{
            numLandmarks: number;
            landmarks: number[];
            crc32: number;
        }>;
        maxLength: (x: number) => number;
    };
    cramBlockHeader: {
        parser: Parser<BlockHeader>;
        maxLength: number;
    };
    cramBlockCrc32: {
        parser: Parser<{
            crc32: number;
        }>;
        maxLength: number;
    };
    cramCompressionHeader: {
        parser: Parser<CramCompressionHeader>;
    };
    cramMappedSliceHeader: {
        parser: Parser<MappedSliceHeader>;
        maxLength: (numContentIds: number) => number;
    };
    cramUnmappedSliceHeader: {
        parser: Parser<UnmappedSliceHeader>;
        maxLength: (numContentIds: number) => number;
    };
};
export { cramFileDefinition, getSectionParsers };
