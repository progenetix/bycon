import CramFile from './cramFile';
import CramRecord from './cramFile/record';
import { SeqFetch } from './cramFile/file';
import { Filehandle } from './cramFile/filehandle';
import { Slice } from './craiIndex';
export interface CramFileSource {
    cramFilehandle?: Filehandle;
    cramUrl?: string;
    cramPath?: string;
}
export interface CramIndexLike {
    getEntriesForRange: (seqId: number, start: number, end: number) => Promise<Slice[]>;
    hasDataForReferenceSequence: (seqId: number) => Promise<boolean>;
}
export default class IndexedCramFile {
    cram: CramFile;
    index: CramIndexLike;
    private fetchSizeLimit;
    /**
     *
     * @param {object} args
     * @param {CramFile} args.cram
     * @param {Index-like} args.index object that supports getEntriesForRange(seqId,start,end) -> Promise[Array[index entries]]
     * @param {number} [args.cacheSize] optional maximum number of CRAM records to cache.  default 20,000
     * @param {number} [args.fetchSizeLimit] optional maximum number of bytes to fetch in a single getRecordsForRange call.  Default 3 MiB.
     * @param {boolean} [args.checkSequenceMD5] - default true. if false, disables verifying the MD5
     * checksum of the reference sequence underlying a slice. In some applications, this check can cause an inconvenient amount (many megabases) of sequences to be fetched.
     */
    constructor(args: {
        index: CramIndexLike;
        fetchSizeLimit?: number;
    } & ({
        cram: CramFile;
    } | ({
        cram?: undefined;
        seqFetch?: SeqFetch;
        checkSequenceMD5?: boolean;
        cacheSize?: number;
    } & CramFileSource)));
    /**
     *
     * @param {number} seq numeric ID of the reference sequence
     * @param {number} start start of the range of interest. 1-based closed coordinates.
     * @param {number} end end of the range of interest. 1-based closed coordinates.
     * @returns {Promise[Array[CramRecord]]}
     */
    getRecordsForRange(seq: number, start: number, end: number, opts?: {
        viewAsPairs?: boolean;
        pairAcrossChr?: boolean;
        maxInsertSize?: number;
    }): Promise<CramRecord[]>;
    getRecordsInSlice({ containerStart, sliceStart, sliceBytes, }: {
        containerStart: number;
        sliceStart: number;
        sliceBytes: number;
    }, filterFunction: (r: CramRecord) => boolean): Promise<CramRecord[]>;
    /**
     *
     * @param {number} seqId
     * @returns {Promise} true if the CRAM file contains data for the given
     * reference sequence numerical ID
     */
    hasDataForReferenceSequence(seqId: number): Promise<boolean>;
}
