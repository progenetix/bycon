/// <reference types="node" />
import { Buffer } from 'buffer';
import { GenericFilehandle } from 'generic-filehandle';
import { Options, IndexData } from './indexFile';
import Chunk from './chunk';
type GetLinesCallback = (line: string, fileOffset: number) => void;
interface GetLinesOpts {
    [key: string]: unknown;
    signal?: AbortSignal;
    lineCallback: GetLinesCallback;
}
export default class TabixIndexedFile {
    private filehandle;
    private index;
    private chunkSizeLimit;
    private yieldTime;
    private renameRefSeq;
    private chunkCache;
    /**
     * @param {object} args
     * @param {string} [args.path]
     * @param {filehandle} [args.filehandle]
     * @param {string} [args.tbiPath]
     * @param {filehandle} [args.tbiFilehandle]
     * @param {string} [args.csiPath]
     * @param {filehandle} [args.csiFilehandle]
     * @param {number} [args.yieldTime] yield to main thread after N milliseconds if reading features is taking a long time to avoid hanging main thread
     * @param {function} [args.renameRefSeqs] optional function with sig `string => string` to transform
     * reference sequence names for the purpose of indexing and querying. note that the data that is returned is
     * not altered, just the names of the reference sequences that are used for querying.
     */
    constructor({ path, filehandle, tbiPath, tbiFilehandle, csiPath, csiFilehandle, yieldTime, chunkSizeLimit, renameRefSeqs, chunkCacheSize, }: {
        path?: string;
        filehandle?: GenericFilehandle;
        tbiPath?: string;
        tbiFilehandle?: GenericFilehandle;
        csiPath?: string;
        csiFilehandle?: GenericFilehandle;
        yieldTime?: number;
        chunkSizeLimit?: number;
        renameRefSeqs?: (n: string) => string;
        chunkCacheSize?: number;
    });
    /**
     * @param refName name of the reference sequence
     * @param start start of the region (in 0-based half-open coordinates)
     * @param end end of the region (in 0-based half-open coordinates)
     * @param opts callback called for each line in the region. can also pass a object param containing obj.lineCallback, obj.signal, etc
     * @returns promise that is resolved when the whole read is finished, rejected on error
     */
    getLines(refName: string, s: number | undefined, e: number | undefined, opts: GetLinesOpts | GetLinesCallback): Promise<void>;
    getMetadata(opts?: Options): Promise<{
        [key: string]: any;
        refNameToId: Record<string, number>;
        refIdToName: string[];
        metaChar: string | null;
        columnNumbers: {
            ref: number;
            start: number;
            end: number;
        };
        coordinateType: string;
        format: string;
    }>;
    /**
     * get a buffer containing the "header" region of
     * the file, which are the bytes up to the first
     * non-meta line
     */
    getHeaderBuffer(opts?: Options): Promise<Buffer>;
    /**
     * get a string containing the "header" region of the
     * file, is the portion up to the first non-meta line
     *
     * @returns {Promise} for a string
     */
    getHeader(opts?: Options): Promise<string>;
    /**
     * get an array of reference sequence names, in the order in which
     * they occur in the file. reference sequence renaming is not applied
     * to these names.
     */
    getReferenceSequenceNames(opts?: Options): Promise<string[]>;
    /**
     * @param {object} metadata metadata object from the parsed index,
     * containing columnNumbers, metaChar, and format
     * @param {string} regionRefName
     * @param {number} regionStart region start coordinate (0-based-half-open)
     * @param {number} regionEnd region end coordinate (0-based-half-open)
     * @param {array[string]} line
     * @returns {object} like `{startCoordinate, overlaps}`. overlaps is boolean,
     * true if line is a data line that overlaps the given region
     */
    checkLine(metadata: IndexData, regionRefName: string, regionStart: number, regionEnd: number, line: string): {
        overlaps: boolean;
        startCoordinate?: undefined;
    } | {
        startCoordinate: number;
        overlaps: boolean;
    };
    _getVcfEnd(startCoordinate: number, refSeq: string, info: any): number;
    /**
     * return the approximate number of data lines in the given reference sequence
     * @param refSeq reference sequence name
     * @returns number of data lines present on that reference sequence
     */
    lineCount(refName: string, opts?: Options): Promise<number>;
    _readRegion(pos: number, size: number, opts?: Options): Promise<Buffer>;
    /**
     * read and uncompress the data in a chunk (composed of one or more
     * contiguous bgzip blocks) of the file
     */
    readChunk(c: Chunk, opts?: Options): Promise<{
        buffer: Buffer;
        cpositions: number[];
        dpositions: number[];
    }>;
}
export {};
