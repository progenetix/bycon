import { GenericFilehandle } from 'generic-filehandle';
import VirtualOffset from './virtualOffset';
import Chunk from './chunk';
export interface Options {
    [key: string]: unknown;
    signal?: AbortSignal;
}
export interface IndexData {
    refNameToId: Record<string, number>;
    refIdToName: string[];
    metaChar: string | null;
    columnNumbers: {
        ref: number;
        start: number;
        end: number;
    };
    coordinateType: string;
    format: string;
    [key: string]: any;
}
export default abstract class IndexFile {
    filehandle: GenericFilehandle;
    renameRefSeq: (arg0: string) => string;
    private parseP?;
    constructor({ filehandle, renameRefSeqs, }: {
        filehandle: GenericFilehandle;
        renameRefSeqs?: (a: string) => string;
    });
    abstract lineCount(refName: string, args: Options): Promise<number>;
    protected abstract _parse(opts: Options): Promise<IndexData>;
    getMetadata(opts?: Options): Promise<{
        [key: string]: any;
        refNameToId: Record<string, number>;
        refIdToName: string[];
        metaChar: string | null;
        columnNumbers: {
            ref: number;
            start: number;
            end: number;
        };
        coordinateType: string;
        format: string;
    }>;
    abstract blocksForRange(refName: string, start: number, end: number, opts: Options): Promise<Chunk[]>;
    _findFirstData(currentFdl: VirtualOffset | undefined, virtualOffset: VirtualOffset): VirtualOffset;
    parse(opts?: Options): Promise<IndexData>;
    hasRefSeq(seqId: number, opts?: Options): Promise<boolean>;
}
