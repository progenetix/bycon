/// <reference types="node" />
import { Buffer } from 'buffer';
import VirtualOffset from './virtualOffset';
import Chunk from './chunk';
import IndexFile, { Options } from './indexFile';
export default class CSI extends IndexFile {
    private maxBinNumber;
    private depth;
    private minShift;
    constructor(args: any);
    lineCount(refName: string, opts?: Options): Promise<number>;
    indexCov(): void;
    parseAuxData(bytes: Buffer, offset: number): {
        refIdToName: string[];
        refNameToId: Record<string, number>;
        skipLines: number;
        metaChar: string | null;
        columnNumbers: {
            ref: number;
            start: number;
            end: number;
        };
        format: string;
        coordinateType: string;
    };
    _parseNameBytes(namesBytes: Buffer): {
        refNameToId: Record<string, number>;
        refIdToName: string[];
    };
    _parse(opts?: Options): Promise<{
        csi: boolean;
        refCount: number;
        maxBlockSize: number;
        firstDataLine: VirtualOffset | undefined;
        csiVersion: number;
        indices: {
            binIndex: Record<string, Chunk[]>;
            stats: {
                lineCount: number;
            } | undefined;
        }[];
        depth: number;
        maxBinNumber: number;
        maxRefLength: number;
        refIdToName: string[];
        refNameToId: Record<string, number>;
        skipLines: number;
        metaChar: string | null;
        columnNumbers: {
            ref: number;
            start: number;
            end: number;
        };
        format: string;
        coordinateType: string;
    } | {
        csi: boolean;
        refCount: number;
        maxBlockSize: number;
        firstDataLine: VirtualOffset | undefined;
        csiVersion: number;
        indices: {
            binIndex: Record<string, Chunk[]>;
            stats: {
                lineCount: number;
            } | undefined;
        }[];
        depth: number;
        maxBinNumber: number;
        maxRefLength: number;
        refIdToName: never[];
        refNameToId: {};
        metaChar: null;
        columnNumbers: {
            ref: number;
            start: number;
            end: number;
        };
        coordinateType: string;
        format: string;
    }>;
    parsePseudoBin(bytes: Buffer, offset: number): {
        lineCount: number;
    };
    blocksForRange(refName: string, min: number, max: number, opts?: Options): Promise<Chunk[]>;
    /**
     * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)
     */
    reg2bins(beg: number, end: number): number[][];
}
