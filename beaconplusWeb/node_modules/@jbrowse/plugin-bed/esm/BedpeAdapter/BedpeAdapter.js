import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';
import { openLocation } from '@jbrowse/core/util/io';
import { ObservableCreate } from '@jbrowse/core/util/rxjs';
import { SimpleFeature } from '@jbrowse/core/util';
import IntervalTree from '@flatten-js/interval-tree';
import { unzip } from '@gmod/bgzf-filehandle';
function isGzip(buf) {
    return buf[0] === 31 && buf[1] === 139 && buf[2] === 8;
}
export function featureData(line, uniqueId, flip, names) {
    const l = line.split('\t');
    const ref1 = l[flip ? 3 : 0];
    const start1 = +l[flip ? 4 : 1];
    const end1 = +l[flip ? 5 : 2];
    const ref2 = l[!flip ? 3 : 0];
    const start2 = +l[!flip ? 4 : 1];
    const end2 = +l[!flip ? 5 : 2];
    const name = l[6];
    const score = +l[7];
    const strand1 = parseStrand(l[8]);
    const strand2 = parseStrand(l[9]);
    const extra = l.slice(10);
    const rest = names
        ? Object.fromEntries(names.slice(10).map((n, idx) => [n, extra[idx]]))
        : extra;
    let ALT;
    if (['DUP', 'TRA', 'INV', 'CNV', 'DEL'].includes(extra[0])) {
        ALT = `<${extra[0]}>`;
    }
    return new SimpleFeature({
        start: start1,
        end: end1,
        refName: ref1,
        ...(ALT ? { ALT: [ALT] } : {}), // it's an array in VCF
        strand: strand1,
        name,
        ...rest,
        score,
        uniqueId,
        mate: { refName: ref2, start: start2, end: end2, strand: strand2 },
    });
}
function parseStrand(strand) {
    if (strand === '+') {
        return 1;
    }
    else if (strand === '-') {
        return -1;
    }
    else if (strand === '.') {
        return 0;
    }
    else {
        return undefined;
    }
}
class BedpeAdapter extends BaseFeatureDataAdapter {
    constructor() {
        super(...arguments);
        this.intervalTrees = {};
    }
    async loadDataP(opts = {}) {
        const pm = this.pluginManager;
        const bedLoc = this.getConf('bedpeLocation');
        const buf = await openLocation(bedLoc, pm).readFile(opts);
        const buffer = isGzip(buf) ? await unzip(buf) : buf;
        // 512MB  max chrome string length is 512MB
        if (buffer.length > 536870888) {
            throw new Error('Data exceeds maximum string length (512MB)');
        }
        const data = new TextDecoder('utf8', { fatal: true }).decode(buffer);
        const lines = data.split(/\n|\r\n|\r/).filter(f => !!f);
        const headerLines = [];
        let i = 0;
        for (; i < lines.length && lines[i].startsWith('#'); i++) {
            headerLines.push(lines[i]);
        }
        const header = headerLines.join('\n');
        const feats1 = {};
        const feats2 = {};
        for (; i < lines.length; i++) {
            const line = lines[i];
            const cols = line.split('\t');
            const r1 = cols[0];
            const r2 = cols[3];
            if (!feats1[r1]) {
                feats1[r1] = [];
            }
            if (!feats2[r2]) {
                feats2[r2] = [];
            }
            feats1[r1].push(line);
            feats2[r2].push(line);
        }
        const columnNames = this.getConf('columnNames');
        return {
            header,
            feats1,
            feats2,
            columnNames,
        };
    }
    async loadData(opts = {}) {
        if (!this.bedpeFeatures) {
            this.bedpeFeatures = this.loadDataP(opts).catch(e => {
                this.bedpeFeatures = undefined;
                throw e;
            });
        }
        return this.bedpeFeatures;
    }
    async getRefNames(opts = {}) {
        const { feats1, feats2 } = await this.loadData(opts);
        return [...new Set([...Object.keys(feats1), ...Object.keys(feats2)])];
    }
    async getHeader(opts = {}) {
        const { header } = await this.loadData(opts);
        return header;
    }
    async getNames() {
        const { header, columnNames } = await this.loadData();
        if (columnNames.length) {
            return columnNames;
        }
        const defs = header.split(/\n|\r\n|\r/).filter(f => !!f);
        const defline = defs.at(-1);
        return (defline === null || defline === void 0 ? void 0 : defline.includes('\t'))
            ? defline
                .slice(1)
                .split('\t')
                .map(field => field.trim())
            : undefined;
    }
    async loadFeatureTreeP(refName) {
        var _a, _b, _c, _d;
        const { feats1, feats2 } = await this.loadData();
        const names = await this.getNames();
        const intervalTree = new IntervalTree();
        const ret1 = (_b = (_a = feats1[refName]) === null || _a === void 0 ? void 0 : _a.map((f, i) => featureData(f, `${this.id}-${refName}-${i}-r1`, false, names))) !== null && _b !== void 0 ? _b : [];
        const ret2 = (_d = (_c = feats2[refName]) === null || _c === void 0 ? void 0 : _c.map((f, i) => featureData(f, `${this.id}-${refName}-${i}-r2`, true, names))) !== null && _d !== void 0 ? _d : [];
        for (const obj of [...ret1, ...ret2]) {
            intervalTree.insert([obj.get('start'), obj.get('end')], obj);
        }
        return intervalTree;
    }
    async loadFeatureTree(refName) {
        if (!this.intervalTrees[refName]) {
            this.intervalTrees[refName] = this.loadFeatureTreeP(refName).catch(e => {
                this.intervalTrees[refName] = undefined;
                throw e;
            });
        }
        return this.intervalTrees[refName];
    }
    getFeatures(query, opts = {}) {
        return ObservableCreate(async (observer) => {
            const { start, end, refName } = query;
            const intervalTree = await this.loadFeatureTree(refName);
            intervalTree === null || intervalTree === void 0 ? void 0 : intervalTree.search([start, end]).forEach(f => observer.next(f));
            observer.complete();
        }, opts.signal);
    }
    freeResources() { }
}
BedpeAdapter.capabilities = ['getFeatures', 'getRefNames'];
export default BedpeAdapter;
