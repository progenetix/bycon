import React, { useState } from 'react';
import { observer } from 'mobx-react';
import { polarToCartesian, getStrokeProps } from '@jbrowse/core/util';
import { readConfObject, } from '@jbrowse/core/configuration';
import { parseBreakend } from '@gmod/vcf';
function bpToRadians(block, pos) {
    const blockStart = block.region.elided ? 0 : block.region.start;
    const blockEnd = block.region.elided ? 0 : block.region.end;
    const bpOffset = block.flipped ? blockEnd - pos : pos - blockStart;
    return bpOffset / block.bpPerRadian + block.startRadians;
}
const Chord = observer(function Chord({ feature, blocksForRefs, radius, config, bezierRadius, selected, onClick, }) {
    var _a, _b, _c, _d, _e;
    const [hovered, setHovered] = useState(false);
    // find the blocks that our start and end points belong to
    const startBlock = blocksForRefs[feature.get('refName')];
    if (!startBlock) {
        return null;
    }
    let svType;
    if (feature.get('INFO')) {
        ;
        [svType] = feature.get('INFO').SVTYPE || [];
    }
    else if (feature.get('mate')) {
        svType = 'mate';
    }
    let endPosition;
    let endBlock;
    const alt = (_a = feature.get('ALT')) === null || _a === void 0 ? void 0 : _a[0];
    const bnd = alt && parseBreakend(alt);
    if (bnd) {
        // VCF BND
        const matePosition = bnd.MatePosition.split(':');
        endPosition = +matePosition[1];
        endBlock = blocksForRefs[matePosition[0]];
    }
    else if (alt === '<TRA>') {
        // VCF TRA
        const chr2 = (_c = (_b = feature.get('INFO')) === null || _b === void 0 ? void 0 : _b.CHR2) === null || _c === void 0 ? void 0 : _c[0];
        const end = (_e = (_d = feature.get('INFO')) === null || _d === void 0 ? void 0 : _d.END) === null || _e === void 0 ? void 0 : _e[0];
        endPosition = parseInt(end, 10);
        endBlock = blocksForRefs[chr2];
    }
    else if (svType === 'mate') {
        // generic simplefeatures arcs
        const mate = feature.get('mate');
        const chr2 = mate.refName;
        endPosition = mate.start;
        endBlock = blocksForRefs[chr2];
    }
    if (endBlock) {
        const startPos = feature.get('start');
        const startRadians = bpToRadians(startBlock, startPos);
        const endRadians = bpToRadians(endBlock, endPosition);
        const startXY = polarToCartesian(radius, startRadians);
        const endXY = polarToCartesian(radius, endRadians);
        const controlXY = polarToCartesian(bezierRadius, (endRadians + startRadians) / 2);
        const strokeColor = selected
            ? readConfObject(config, 'strokeColorSelected', { feature })
            : readConfObject(config, 'strokeColor', { feature });
        const hoverStrokeColor = readConfObject(config, 'strokeColorHover', {
            feature,
        });
        return (React.createElement("path", { "data-testid": `chord-${feature.id()}`, cursor: "crosshair", fill: "none", d: ['M', ...startXY, 'Q', ...controlXY, ...endXY].join(' '), ...getStrokeProps(hovered ? hoverStrokeColor : strokeColor), strokeWidth: hovered ? 3 : 1, onClick: evt => {
                if (endBlock && startBlock) {
                    onClick(feature, startBlock.region, endBlock.region, evt);
                }
            }, onMouseOver: () => {
                if (!selected) {
                    setHovered(true);
                }
            }, onMouseOut: () => {
                if (!selected) {
                    setHovered(false);
                }
            } }));
    }
    return null;
});
export default Chord;
