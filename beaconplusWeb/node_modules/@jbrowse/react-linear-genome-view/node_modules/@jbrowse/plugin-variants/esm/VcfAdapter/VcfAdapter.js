import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';
import { openLocation } from '@jbrowse/core/util/io';
import { ObservableCreate } from '@jbrowse/core/util/rxjs';
import IntervalTree from '@flatten-js/interval-tree';
import { unzip } from '@gmod/bgzf-filehandle';
import VCF from '@gmod/vcf';
// local
import VcfFeature from '../VcfFeature';
const readVcf = (f) => {
    const header = [];
    const rest = [];
    f.split(/\n|\r\n|\r/)
        .map(f => f.trim())
        .filter(f => !!f)
        .forEach(line => {
        if (line.startsWith('#')) {
            header.push(line);
        }
        else if (line) {
            rest.push(line);
        }
    });
    return { header: header.join('\n'), lines: rest };
};
function isGzip(buf) {
    return buf[0] === 31 && buf[1] === 139 && buf[2] === 8;
}
class VcfAdapter extends BaseFeatureDataAdapter {
    async getHeader() {
        const { header } = await this.setup();
        return header;
    }
    async getMetadata() {
        const { header } = await this.setup();
        const parser = new VCF({ header: header });
        return parser.getMetadata();
    }
    // converts lines into an interval tree
    async setupP() {
        const pm = this.pluginManager;
        const buf = await openLocation(this.getConf('vcfLocation'), pm).readFile();
        const buffer = isGzip(buf) ? await unzip(buf) : buf;
        // 512MB  max chrome string length is 512MB
        if (buffer.length > 536870888) {
            throw new Error('Data exceeds maximum string length (512MB)');
        }
        const str = new TextDecoder().decode(buffer);
        const { header, lines } = readVcf(str);
        const intervalTree = {};
        const parser = new VCF({ header });
        let idx = 0;
        for (const line of lines) {
            const f = new VcfFeature({
                variant: parser.parseLine(line),
                parser,
                id: `${this.id}-${idx++}`,
            });
            const key = f.get('refName');
            if (!intervalTree[key]) {
                intervalTree[key] = new IntervalTree();
            }
            intervalTree[key].insert([f.get('start'), f.get('end')], f);
        }
        return { header, intervalTree };
    }
    async setup() {
        if (!this.vcfFeatures) {
            this.vcfFeatures = this.setupP().catch(e => {
                this.vcfFeatures = undefined;
                throw e;
            });
        }
        return this.vcfFeatures;
    }
    async getRefNames(_ = {}) {
        const { intervalTree } = await this.setup();
        return Object.keys(intervalTree);
    }
    getFeatures(region, opts = {}) {
        return ObservableCreate(async (observer) => {
            var _a;
            try {
                const { start, end, refName } = region;
                const { intervalTree } = await this.setup();
                (_a = intervalTree[refName]) === null || _a === void 0 ? void 0 : _a.search([start, end]).forEach((f) => {
                    observer.next(f);
                });
                observer.complete();
            }
            catch (e) {
                observer.error(e);
            }
        }, opts.signal);
    }
    freeResources() { }
}
VcfAdapter.capabilities = ['getFeatures', 'getRefNames'];
export default VcfAdapter;
