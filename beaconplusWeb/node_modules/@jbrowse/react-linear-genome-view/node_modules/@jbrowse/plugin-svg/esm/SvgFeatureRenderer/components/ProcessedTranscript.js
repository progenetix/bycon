import React from 'react';
import { observer } from 'mobx-react';
import { readConfObject, } from '@jbrowse/core/configuration';
import Segments from './Segments';
import { layOutFeature, layOutSubfeatures } from './util';
import { SimpleFeature } from '@jbrowse/core/util';
// returns a callback that will filter features features according to the
// subParts conf var
function makeSubpartsFilter(confKey = 'subParts', config) {
    const filter = readConfObject(config, confKey);
    const ret = typeof filter == 'string' ? filter.split(/\s*,\s*/) : filter;
    return (feature) => ret
        .map(typeName => typeName.toLowerCase())
        .includes(feature.get('type').toLowerCase());
}
function filterSubpart(feature, config) {
    return makeSubpartsFilter('subParts', config)(feature);
}
function isUTR(feature) {
    return /(\bUTR|_UTR|untranslated[_\s]region)\b/.test(feature.get('type') || '');
}
function makeUTRs(parent, subs) {
    // based on Lincoln's UTR-making code in Bio::Graphics::Glyph::processed_transcript
    const subparts = [...subs];
    let codeStart = Infinity;
    let codeEnd = -Infinity;
    let haveLeftUTR;
    let haveRightUTR;
    // gather exons, find coding start and end, and look for UTRs
    const exons = [];
    for (const subpart of subparts) {
        const type = subpart.get('type');
        if (/^cds/i.test(type)) {
            if (codeStart > subpart.get('start')) {
                codeStart = subpart.get('start');
            }
            if (codeEnd < subpart.get('end')) {
                codeEnd = subpart.get('end');
            }
        }
        else if (/exon/i.test(type)) {
            exons.push(subpart);
        }
        else if (isUTR(subpart)) {
            haveLeftUTR = subpart.get('start') === parent.get('start');
            haveRightUTR = subpart.get('end') === parent.get('end');
        }
    }
    // bail if we don't have exons and CDS
    if (!(exons.length && codeStart < Infinity && codeEnd > -Infinity)) {
        return subparts;
    }
    // make sure the exons are sorted by coord
    exons.sort((a, b) => a.get('start') - b.get('start'));
    const strand = parent.get('strand');
    // make the left-hand UTRs
    let start;
    let end;
    if (!haveLeftUTR) {
        for (let i = 0; i < exons.length; i++) {
            start = exons[i].get('start');
            if (start >= codeStart) {
                break;
            }
            end = codeStart > exons[i].get('end') ? exons[i].get('end') : codeStart;
            const type = strand >= 0 ? 'five_prime_UTR' : 'three_prime_UTR';
            subparts.unshift(new SimpleFeature({
                parent,
                id: `${parent.id()}_${type}_${i}`,
                data: { start, end, strand, type },
            }));
        }
    }
    // make the right-hand UTRs
    if (!haveRightUTR) {
        for (let i = exons.length - 1; i >= 0; i--) {
            end = exons[i].get('end');
            if (end <= codeEnd) {
                break;
            }
            start = codeEnd < exons[i].get('start') ? exons[i].get('start') : codeEnd;
            const type = strand >= 0 ? 'three_prime_UTR' : 'five_prime_UTR';
            subparts.push(new SimpleFeature({
                parent,
                id: `${parent.id()}_${type}_${i}`,
                data: { start, end, strand, type },
            }));
        }
    }
    return subparts;
}
function getSubparts(f, config) {
    let c = f.get('subfeatures');
    if (!c || c.length === 0) {
        return [];
    }
    const hasUTRs = c.some(child => isUTR(child));
    const isTranscript = ['mRNA', 'transcript'].includes(f.get('type'));
    const impliedUTRs = !hasUTRs && isTranscript;
    // if we think we should use impliedUTRs, or it is specifically in the
    // config, then makeUTRs
    if (impliedUTRs || readConfObject(config, 'impliedUTRs')) {
        c = makeUTRs(f, c);
    }
    return c.filter(element => filterSubpart(element, config));
}
const ProcessedTranscript = observer(function ProcessedTranscript(props) {
    const { feature, config } = props;
    const subfeatures = getSubparts(feature, config);
    // we manually compute some subfeatures, so pass these separately
    return React.createElement(Segments, { ...props, subfeatures: subfeatures });
});
// @ts-expect-error
ProcessedTranscript.layOut = ({ layout, feature, bpPerPx, reversed, config, extraGlyphs, }) => {
    const subLayout = layOutFeature({
        layout,
        feature,
        bpPerPx,
        reversed,
        config,
        extraGlyphs,
    });
    const subfeatures = getSubparts(feature, config);
    layOutSubfeatures({
        layout: subLayout,
        subfeatures,
        bpPerPx,
        reversed,
        config,
        extraGlyphs,
    });
    return subLayout;
};
export default ProcessedTranscript;
