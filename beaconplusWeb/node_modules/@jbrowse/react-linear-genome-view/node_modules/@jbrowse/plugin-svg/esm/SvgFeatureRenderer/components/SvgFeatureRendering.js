import React, { useEffect, useRef, useState, useCallback } from 'react';
import { observer } from 'mobx-react';
import { readConfObject, } from '@jbrowse/core/configuration';
import { bpToPx, measureText } from '@jbrowse/core/util';
import { SceneGraph } from '@jbrowse/core/util/layouts';
// locals
import FeatureGlyph from './FeatureGlyph';
import SvgOverlay from './SvgOverlay';
import { chooseGlyphComponent, layOut, } from './util';
// used to make features have a little padding for their labels
const xPadding = 3;
const yPadding = 5;
// used so that user can click-away-from-feature below the laid out features
// (issue #1248)
const svgHeightPadding = 100;
function RenderedFeatureGlyph(props) {
    const { feature, detectRerender, bpPerPx, region, config, displayMode, layout, extraGlyphs, } = props;
    // used for unit testing, difficult to mock out so it is in actual source code
    detectRerender === null || detectRerender === void 0 ? void 0 : detectRerender();
    const { reversed } = region;
    const start = feature.get(reversed ? 'end' : 'start');
    const startPx = bpToPx(start, region, bpPerPx);
    const labelAllowed = displayMode !== 'collapsed';
    const rootLayout = new SceneGraph('root', 0, 0, 0, 0);
    const GlyphComponent = chooseGlyphComponent(feature, extraGlyphs);
    const featureLayout = (GlyphComponent.layOut || layOut)({
        layout: rootLayout,
        feature,
        bpPerPx,
        reversed,
        config,
        extraGlyphs,
    });
    let shouldShowName = false;
    let shouldShowDescription = false;
    let name = '';
    let description = '';
    let fontHeight = 0;
    let expansion = 0;
    if (labelAllowed) {
        const showLabels = readConfObject(config, 'showLabels');
        const showDescriptions = readConfObject(config, 'showDescriptions');
        fontHeight = readConfObject(config, ['labels', 'fontSize'], { feature });
        expansion = readConfObject(config, 'maxFeatureGlyphExpansion') || 0;
        name = String(readConfObject(config, ['labels', 'name'], { feature }) || '');
        shouldShowName = /\S/.test(name) && showLabels;
        const getWidth = (text) => {
            const glyphWidth = rootLayout.width + expansion;
            const textWidth = measureText(text, fontHeight);
            return Math.round(Math.min(textWidth, glyphWidth));
        };
        description = String(readConfObject(config, ['labels', 'description'], { feature }) || '');
        shouldShowDescription = /\S/.test(description) && showDescriptions;
        if (shouldShowName) {
            rootLayout.addChild('nameLabel', 0, featureLayout.bottom, getWidth(name), fontHeight);
        }
        if (shouldShowDescription) {
            const aboveLayout = shouldShowName
                ? rootLayout.getSubRecord('nameLabel')
                : featureLayout;
            rootLayout.addChild('descriptionLabel', 0, aboveLayout.bottom, getWidth(description), fontHeight);
        }
    }
    const topPx = layout.addRect(feature.id(), feature.get('start'), feature.get('start') + rootLayout.width * bpPerPx + xPadding * bpPerPx, rootLayout.height + yPadding);
    if (topPx === null) {
        return null;
    }
    rootLayout.move(startPx, topPx);
    return (React.createElement(FeatureGlyph, { rootLayout: rootLayout, name: name, shouldShowName: shouldShowName, description: description, shouldShowDescription: shouldShowDescription, fontHeight: fontHeight, allowedWidthExpansion: expansion, reversed: region.reversed, topLevel: true, ...props }));
}
const RenderedFeatures = observer((props) => {
    const { features = new Map(), isFeatureDisplayed } = props;
    return (React.createElement(React.Fragment, null, [...features.values()]
        .filter(feature => isFeatureDisplayed ? isFeatureDisplayed(feature) : true)
        .map(feature => (React.createElement(RenderedFeatureGlyph, { key: feature.id(), feature: feature, ...props })))));
});
const SvgFeatureRendering = observer(function SvgFeatureRendering(props) {
    const { layout, blockKey, regions = [], bpPerPx, config, displayModel = {}, exportSVG, featureDisplayHandler, onMouseOut, onMouseDown, onMouseLeave, onMouseEnter, onMouseOver, onMouseMove, onMouseUp, onClick, } = props;
    const [region] = regions;
    const width = (region.end - region.start) / bpPerPx;
    const displayMode = readConfObject(config, 'displayMode');
    const ref = useRef(null);
    const [mouseIsDown, setMouseIsDown] = useState(false);
    const [height, setHeight] = useState(0);
    const [movedDuringLastMouseDown, setMovedDuringLastMouseDown] = useState(false);
    const mouseDown = useCallback((event) => {
        setMouseIsDown(true);
        setMovedDuringLastMouseDown(false);
        return onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(event);
    }, [onMouseDown]);
    const mouseUp = useCallback((event) => {
        setMouseIsDown(false);
        return onMouseUp === null || onMouseUp === void 0 ? void 0 : onMouseUp(event);
    }, [onMouseUp]);
    const mouseMove = useCallback((event) => {
        var _a;
        if (!ref.current) {
            return;
        }
        if (mouseIsDown) {
            setMovedDuringLastMouseDown(true);
        }
        const { left, top } = ref.current.getBoundingClientRect();
        const offsetX = event.clientX - left;
        const offsetY = event.clientY - top;
        const px = region.reversed ? width - offsetX : offsetX;
        const clientBp = region.start + bpPerPx * px;
        const featureIdCurrentlyUnderMouse = (_a = displayModel.getFeatureOverlapping) === null || _a === void 0 ? void 0 : _a.call(displayModel, blockKey, clientBp, offsetY);
        if (onMouseMove) {
            onMouseMove(event, featureIdCurrentlyUnderMouse);
        }
    }, [
        blockKey,
        bpPerPx,
        mouseIsDown,
        onMouseMove,
        region.reversed,
        region.start,
        displayModel,
        width,
    ]);
    const click = useCallback((event) => {
        // don't select a feature if we are clicking and dragging
        if (movedDuringLastMouseDown) {
            return;
        }
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
    }, [movedDuringLastMouseDown, onClick]);
    useEffect(() => {
        setHeight(layout.getTotalHeight());
    }, [layout]);
    return exportSVG ? (React.createElement(RenderedFeatures, { displayMode: displayMode, isFeatureDisplayed: featureDisplayHandler, region: region, ...props })) : (React.createElement("svg", { ref: ref, "data-testid": "svgfeatures", width: width, height: height + svgHeightPadding, style: {
            // use block because svg by default is inline, which adds a margin
            display: 'block',
        }, onMouseDown: mouseDown, onMouseUp: mouseUp, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onMouseOver: onMouseOver, onMouseOut: onMouseOut, onMouseMove: mouseMove, onClick: click },
        React.createElement(RenderedFeatures, { displayMode: displayMode, region: region, movedDuringLastMouseDown: movedDuringLastMouseDown, isFeatureDisplayed: featureDisplayHandler, ...props }),
        React.createElement(SvgOverlay, { ...props, region: region, movedDuringLastMouseDown: movedDuringLastMouseDown })));
});
export default SvgFeatureRendering;
