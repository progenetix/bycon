import React from 'react';
import { Region } from '@jbrowse/core/util/types';
import { MenuItem } from '@jbrowse/core/ui';
import { ParsedLocString } from '@jbrowse/core/util';
import BaseResult from '@jbrowse/core/TextSearch/BaseResults';
import { BlockSet, BaseBlock } from '@jbrowse/core/util/blockTypes';
import { Instance } from 'mobx-state-tree';
import PluginManager from '@jbrowse/core/PluginManager';
import { Assembly } from '@jbrowse/core/assemblyManager/assembly';
export interface BpOffset {
    refName?: string;
    index: number;
    offset: number;
    start?: number;
    end?: number;
    coord?: number;
    reversed?: boolean;
    assemblyName?: string;
    oob?: boolean;
}
export interface ExportSvgOptions {
    rasterizeLayers?: boolean;
    filename?: string;
    Wrapper?: React.FC<{
        children: React.ReactNode;
    }>;
    fontSize?: number;
    rulerHeight?: number;
    textHeight?: number;
    paddingHeight?: number;
    headerHeight?: number;
    cytobandHeight?: number;
    trackLabels?: string;
    themeName?: string;
}
export interface NavLocation {
    refName: string;
    start?: number;
    end?: number;
    assemblyName?: string;
}
export declare const HEADER_BAR_HEIGHT = 48;
export declare const HEADER_OVERVIEW_HEIGHT = 20;
export declare const SCALE_BAR_HEIGHT = 17;
export declare const RESIZE_HANDLE_HEIGHT = 3;
export declare const INTER_REGION_PADDING_WIDTH = 2;
export declare const SPACING = 7;
export declare const WIDGET_HEIGHT = 32;
/**
 * #stateModel LinearGenomeView
 * #category view
 *
 * extends
 * - [BaseViewModel](../baseviewmodel)
 */
export declare function stateModelFactory(pluginManager: PluginManager): import("mobx-state-tree").IModelType<{
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    displayName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
    minimized: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
} & {
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    type: import("mobx-state-tree").IType<string | undefined, string, string>;
    offsetPx: import("mobx-state-tree").IType<number | undefined, number, number>;
    bpPerPx: import("mobx-state-tree").IType<number | undefined, number, number>;
    displayedRegions: import("mobx-state-tree").IArrayType<import("mobx-state-tree").IModelType<{
        refName: import("mobx-state-tree").ISimpleType<string>;
        start: import("mobx-state-tree").ISimpleType<number>;
        end: import("mobx-state-tree").ISimpleType<number>;
        reversed: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
    } & {
        assemblyName: import("mobx-state-tree").ISimpleType<string>;
    }, {
        setRefName(newRefName: string): void;
    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
    tracks: import("mobx-state-tree").IArrayType<import("mobx-state-tree").IAnyType>;
    hideHeader: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    hideHeaderOverview: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    hideNoTracksActive: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    trackSelectorType: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    showCenterLine: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
    showCytobandsSetting: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
    trackLabels: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    showGridlines: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    highlight: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").IArrayType<import("mobx-state-tree").IType<Required<ParsedLocString>, Required<ParsedLocString>, Required<ParsedLocString>>>, [undefined]>;
    colorByCDS: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
}, {
    width: number;
} & {
    menuItems(): MenuItem[];
} & {
    setDisplayName(name: string): void;
    setWidth(newWidth: number): void;
    setMinimized(flag: boolean): void;
} & {
    volatileWidth: number | undefined;
    minimumBlockWidth: number;
    draggingTrackId: string | undefined;
    volatileError: unknown;
    afterDisplayedRegionsSetCallbacks: Function[];
    scaleFactor: number;
    trackRefs: Record<string, HTMLDivElement>;
    coarseDynamicBlocks: BaseBlock[];
    coarseTotalBp: number;
    leftOffset: BpOffset | undefined;
    rightOffset: BpOffset | undefined;
} & {
    /**
     * #getter
     * this is the effective value of the track labels setting, incorporating
     * both the config and view state. use this instead of view.trackLabels
     */
    readonly trackLabelsSetting: any;
    /**
     * #getter
     */
    readonly width: number;
    /**
     * #getter
     */
    readonly interRegionPaddingWidth: number;
    /**
     * #getter
     */
    readonly assemblyNames: string[];
} & {
    /**
     * #method
     */
    MiniControlsComponent(): React.FC<any>;
    /**
     * #method
     */
    HeaderComponent(): React.FC<any>;
    /**
     * #getter
     */
    readonly assemblyErrors: string;
    /**
     * #getter
     */
    readonly assembliesInitialized: boolean;
    /**
     * #getter
     */
    readonly initialized: boolean;
    /**
     * #getter
     */
    readonly hasDisplayedRegions: boolean;
    /**
     * #getter
     */
    readonly scaleBarHeight: number;
    /**
     * #getter
     */
    readonly headerHeight: number;
    /**
     * #getter
     */
    readonly trackHeights: number;
    /**
     * #getter
     */
    readonly trackHeightsWithResizeHandles: number;
    /**
     * #getter
     */
    readonly height: number;
    /**
     * #getter
     */
    readonly totalBp: number;
    /**
     * #getter
     */
    readonly maxBpPerPx: number;
    /**
     * #getter
     */
    readonly minBpPerPx: number;
    /**
     * #getter
     */
    readonly error: {};
    /**
     * #getter
     */
    readonly maxOffset: number;
    /**
     * #getter
     */
    readonly minOffset: number;
    /**
     * #getter
     */
    readonly displayedRegionsTotalPx: number;
    /**
     * #method
     */
    renderProps(): any;
    /**
     * #method
     */
    searchScope(assemblyName: string): {
        assemblyName: string;
        includeAggregateIndexes: boolean;
        tracks: import("mobx-state-tree").IMSTArray<import("mobx-state-tree").IAnyType> & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IArrayType<import("mobx-state-tree").IAnyType>>;
    };
    /**
     * #method
     */
    getTrack(id: string): any;
    /**
     * #method
     */
    rankSearchResults(results: BaseResult[]): BaseResult[];
    /**
     * #method
     * modifies view menu action onClick to apply to all tracks of same type
     */
    rewriteOnClicks(trackType: string, viewMenuActions: MenuItem[]): void;
    /**
     * #getter
     */
    readonly trackTypeActions: Map<string, MenuItem[]>;
} & {
    /**
     * #action
     */
    setColorByCDS(flag: boolean): void;
    /**
     * #action
     */
    setShowCytobands(flag: boolean): void;
    /**
     * #action
     */
    setWidth(newWidth: number): void;
    /**
     * #action
     */
    setError(error: unknown): void;
    /**
     * #action
     */
    setHideHeader(b: boolean): void;
    /**
     * #action
     */
    setHideHeaderOverview(b: boolean): void;
    /**
     * #action
     */
    setHideNoTracksActive(b: boolean): void;
    /**
     * #action
     */
    setShowGridlines(b: boolean): void;
    /**
     * #action
     */
    addToHighlights(highlight: Required<ParsedLocString>): void;
    /**
     * #action
     */
    setHighlight(highlight: Required<ParsedLocString>[] | undefined): void;
    /**
     * #action
     */
    removeHighlight(highlight: Required<ParsedLocString>): void;
    /**
     * #action
     */
    scrollTo(offsetPx: number): number;
    /**
     * #action
     */
    zoomTo(bpPerPx: number, offset?: number, centerAtOffset?: boolean): number;
    /**
     * #action
     * sets offsets of rubberband, used in the get sequence dialog can call
     * view.getSelectedRegions(view.leftOffset,view.rightOffset) to compute
     * the selected regions from the offsets
     */
    setOffsets(left?: BpOffset, right?: BpOffset): void;
    /**
     * #action
     */
    setSearchResults(searchResults: BaseResult[], searchQuery: string, assemblyName?: string): void;
    /**
     * #action
     */
    setNewView(bpPerPx: number, offsetPx: number): void;
    /**
     * #action
     */
    horizontallyFlip(): void;
    /**
     * #action
     */
    showTrack(trackId: string, initialSnapshot?: {}, displayInitialSnapshot?: {}): any;
    /**
     * #action
     */
    hideTrack(trackId: string): number;
} & {
    /**
     * #action
     */
    moveTrackDown(id: string): void;
    /**
     * #action
     */
    moveTrackUp(id: string): void;
    /**
     * #action
     */
    moveTrackToTop(id: string): void;
    /**
     * #action
     */
    moveTrackToBottom(id: string): void;
    /**
     * #action
     */
    moveTrack(movingId: string, targetId: string): void;
    /**
     * #action
     */
    closeView(): void;
    /**
     * #action
     */
    toggleTrack(trackId: string): boolean;
    /**
     * #action
     */
    setTrackLabels(setting: 'overlapping' | 'offset' | 'hidden'): void;
    /**
     * #action
     */
    setShowCenterLine(b: boolean): void;
    /**
     * #action
     */
    setDisplayedRegions(regions: Region[]): void;
    /**
     * #action
     */
    activateTrackSelector(): import("@jbrowse/core/util").Widget;
    /**
     * #method
     * Helper method for the fetchSequence.
     * Retrieves the corresponding regions that were selected by the
     * rubberband
     *
     * @param leftOffset - `object as {start, end, index, offset}`, offset = start
     * of user drag
     * @param rightOffset - `object as {start, end, index, offset}`,
     * offset = end of user drag
     * @returns array of Region[]
     */
    getSelectedRegions(leftOffset?: BpOffset, rightOffset?: BpOffset): {
        start: number;
        end: number;
        regionNumber?: number | undefined;
        reversed?: boolean | undefined;
        refName: string;
        assemblyName: string;
        key: string;
        offsetPx: number;
        widthPx: number;
        variant?: string | undefined;
        isLeftEndOfDisplayedRegion?: boolean | undefined;
    }[];
    /**
     * #action
     * schedule something to be run after the next time displayedRegions is
     * set
     */
    afterDisplayedRegionsSet(cb: Function): void;
    /**
     * #action
     */
    horizontalScroll(distance: number): number;
    /**
     * #action
     */
    center(): void;
    /**
     * #action
     */
    showAllRegions(): void;
    /**
     * #action
     */
    showAllRegionsInAssembly(assemblyName?: string): void;
    /**
     * #action
     */
    setDraggingTrackId(idx?: string): void;
    /**
     * #action
     */
    setScaleFactor(factor: number): void;
    /**
     * #action
     * this "clears the view" and makes the view return to the import form
     */
    clearView(): void;
    /**
     * #method
     * creates an svg export and save using FileSaver
     */
    exportSvg(opts?: ExportSvgOptions): Promise<void>;
} & {
    slide: (viewWidths: number) => void;
} & {
    zoom: (targetBpPerPx: number) => void;
} & {
    /**
     * #getter
     */
    readonly canShowCytobands: boolean;
    /**
     * #getter
     */
    readonly showCytobands: boolean;
    /**
     * #getter
     */
    readonly anyCytobandsExist: boolean;
    /**
     * #getter
     * the cytoband is displayed to the right of the chromosome name, and
     * that offset is calculated manually with this method
     */
    readonly cytobandOffset: number;
} & {
    /**
     * #method
     * return the view menu items
     */
    menuItems(): MenuItem[];
} & {
    /**
     * #getter
     * static blocks are an important concept jbrowse uses to avoid
     * re-rendering when you scroll to the side. when you horizontally
     * scroll to the right, old blocks to the left may be removed, and new
     * blocks may be instantiated on the right. tracks may use the static
     * blocks to render their data for the region represented by the block
     */
    readonly staticBlocks: BlockSet;
    /**
     * #getter
     * dynamic blocks represent the exact coordinates of the currently
     * visible genome regions on the screen. they are similar to static
     * blocks, but static blocks can go offscreen while dynamic blocks
     * represent exactly what is on screen
     */
    readonly dynamicBlocks: BlockSet;
    /**
     * #getter
     * rounded dynamic blocks are dynamic blocks without fractions of bp
     */
    readonly roundedDynamicBlocks: BaseBlock[];
    /**
     * #getter
     * a single "combo-locstring" representing all the regions visible on
     * the screen
     */
    readonly visibleLocStrings: string;
    /**
     * #getter
     * same as visibleLocStrings, but only updated every 300ms
     */
    readonly coarseVisibleLocStrings: string;
} & {
    /**
     * #action
     */
    setCoarseDynamicBlocks(blocks: BlockSet): void;
    afterAttach(): void;
} & {
    /**
     * #action
     * offset is the base-pair-offset in the displayed region, index is the
     * index of the displayed region in the linear genome view
     *
     * @param start - object as `{start, end, offset, index}`
     * @param end - object as `{start, end, offset, index}`
     */
    moveTo(start?: BpOffset, end?: BpOffset): void;
    /**
     * #action
     * Navigate to the given locstring, will change displayed regions if
     * needed, and wait for assemblies to be initialized
     *
     * @param input - e.g. "chr1:1-100", "chr1:1-100 chr2:1-100", "chr 1 100"
     * @param optAssemblyName - (optional) the assembly name to use when
     * navigating to the locstring
     */
    navToLocString(input: string, optAssemblyName?: string): Promise<void>;
    /**
     * #action
     * Performs a text index search, and navigates to it immediately if a
     * single result is returned. Will pop up a search dialog if multiple
     * results are returned
     */
    navToSearchString({ input, assembly, }: {
        input: string;
        assembly: Assembly;
    }): Promise<void>;
    /**
     * #action
     * Similar to `navToLocString`, but accepts parsed location objects
     * instead of strings. Will try to perform `setDisplayedRegions` if
     * changing regions
     */
    navToLocations(parsedLocStrings: ParsedLocString[], assemblyName?: string): Promise<void>;
    /**
     * #action
     * Navigate to a location based on its refName and optionally start, end,
     * and assemblyName. Will not try to change displayed regions, use
     * `navToLocations` instead. Only navigates to a location if it is
     * entirely within a displayedRegion. Navigates to the first matching
     * location encountered.
     *
     * Throws an error if navigation was unsuccessful
     *
     * @param query - a proposed location to navigate to
     */
    navTo(query: NavLocation): void;
    /**
     * #action
     * Navigate to a location based on its refName and optionally start, end,
     * and assemblyName. Will not try to change displayed regions, use
     * navToLocations instead. Only navigates to a location if it is entirely
     * within a displayedRegion. Navigates to the first matching location
     * encountered.
     *
     * Throws an error if navigation was unsuccessful
     *
     * @param locations - proposed location to navigate to
     */
    navToMultiple(locations: NavLocation[]): void;
} & {
    /**
     * #method
     */
    rubberBandMenuItems(): MenuItem[];
    /**
     * #method
     */
    bpToPx({ refName, coord, regionNumber, }: {
        refName: string;
        coord: number;
        regionNumber?: number;
    }): {
        index: number;
        offsetPx: number;
    } | undefined;
    /**
     * #method
     * scrolls the view to center on the given bp. if that is not in any of
     * the displayed regions, does nothing
     *
     * @param coord - basepair at which you want to center the view
     * @param refName - refName of the displayedRegion you are centering at
     * @param regionNumber - index of the displayedRegion
     */
    centerAt(coord: number, refName: string, regionNumber?: number): void;
    /**
     * #method
     */
    pxToBp(px: number): {
        coord: number;
        index: number;
        refName: string;
        oob: boolean;
        assemblyName: string;
        offset: number;
        start: number;
        end: number;
        reversed: boolean;
    };
    /**
     * #getter
     */
    readonly centerLineInfo: {
        coord: number;
        index: number;
        refName: string;
        oob: boolean;
        assemblyName: string;
        offset: number;
        start: number;
        end: number;
        reversed: boolean;
    } | undefined;
} & {
    afterCreate(): void;
}, import("mobx-state-tree").ModelCreationType<import("mobx-state-tree/dist/internal").ExtractCFromProps<{
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    displayName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
    minimized: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
} & {
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    type: import("mobx-state-tree").IType<string | undefined, string, string>;
    offsetPx: import("mobx-state-tree").IType<number | undefined, number, number>;
    bpPerPx: import("mobx-state-tree").IType<number | undefined, number, number>;
    displayedRegions: import("mobx-state-tree").IArrayType<import("mobx-state-tree").IModelType<{
        refName: import("mobx-state-tree").ISimpleType<string>;
        start: import("mobx-state-tree").ISimpleType<number>;
        end: import("mobx-state-tree").ISimpleType<number>;
        reversed: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
    } & {
        assemblyName: import("mobx-state-tree").ISimpleType<string>;
    }, {
        setRefName(newRefName: string): void;
    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
    tracks: import("mobx-state-tree").IArrayType<import("mobx-state-tree").IAnyType>;
    hideHeader: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    hideHeaderOverview: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    hideNoTracksActive: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    trackSelectorType: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    showCenterLine: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
    showCytobandsSetting: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
    trackLabels: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    showGridlines: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    highlight: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").IArrayType<import("mobx-state-tree").IType<Required<ParsedLocString>, Required<ParsedLocString>, Required<ParsedLocString>>>, [undefined]>;
    colorByCDS: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
}>>, import("mobx-state-tree")._NotCustomized>;
export type LinearGenomeViewStateModel = ReturnType<typeof stateModelFactory>;
export type LinearGenomeViewModel = Instance<LinearGenomeViewStateModel>;
export { default as ReactComponent, default as LinearGenomeView, } from './components/LinearGenomeView';
export { default as RefNameAutocomplete } from './components/RefNameAutocomplete';
export { default as SearchBox } from './components/SearchBox';
export { default as ZoomControls } from './components/ZoomControls';
export { renderToSvg } from './svgcomponents/SVGLinearGenomeView';
