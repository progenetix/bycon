/* eslint-disable @typescript-eslint/no-explicit-any */
import React from 'react';
import { getConf } from '@jbrowse/core/configuration';
import { getContainingView } from '@jbrowse/core/util';
import { autorun } from 'mobx';
import { addDisposer, isAlive, types } from 'mobx-state-tree';
import TooLargeMessage from '../components/TooLargeMessage';
import { getDisplayStr, getFeatureDensityStatsPre } from './util';
import autorunFeatureDensityStats from './autorunFeatureDensityStats';
/**
 * #stateModel FeatureDensityMixin
 * #category display
 */
export default function FeatureDensityMixin() {
    return types
        .model({
        /**
         * #property
         */
        userBpPerPxLimit: types.maybe(types.number),
        /**
         * #property
         */
        userByteSizeLimit: types.maybe(types.number),
    })
        .volatile(() => ({
        featureDensityStatsP: undefined,
        featureDensityStats: undefined,
        currStatsBpPerPx: 0,
    }))
        .views(self => ({
        /**
         * #getter
         */
        get currentBytesRequested() {
            var _a;
            return ((_a = self.featureDensityStats) === null || _a === void 0 ? void 0 : _a.bytes) || 0;
        },
        /**
         * #getter
         */
        get currentFeatureScreenDensity() {
            var _a;
            const view = getContainingView(self);
            return (((_a = self.featureDensityStats) === null || _a === void 0 ? void 0 : _a.featureDensity) || 0) * view.bpPerPx;
        },
        /**
         * #getter
         */
        get maxFeatureScreenDensity() {
            // @ts-expect-error
            return getConf(self, 'maxFeatureScreenDensity');
        },
        /**
         * #getter
         */
        get featureDensityStatsReady() {
            const view = getContainingView(self);
            return (self.currStatsBpPerPx === view.bpPerPx &&
                (!!self.featureDensityStats || !!self.userBpPerPxLimit));
        },
        /**
         * #getter
         */
        get maxAllowableBytes() {
            var _a;
            return (self.userByteSizeLimit ||
                ((_a = self.featureDensityStats) === null || _a === void 0 ? void 0 : _a.fetchSizeLimit) ||
                // @ts-expect-error
                getConf(self, 'fetchSizeLimit'));
        },
    }))
        .actions(self => ({
        afterAttach() {
            addDisposer(self, autorun(() => autorunFeatureDensityStats(self)));
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        setCurrStatsBpPerPx(n) {
            self.currStatsBpPerPx = n;
        },
        /**
         * #action
         */
        setFeatureDensityStatsLimit(stats) {
            const view = getContainingView(self);
            if (stats === null || stats === void 0 ? void 0 : stats.bytes) {
                self.userByteSizeLimit = stats.bytes;
            }
            else {
                self.userBpPerPxLimit = view.bpPerPx;
            }
        },
        /**
         * #action
         */
        async getFeatureDensityStats() {
            if (!self.featureDensityStatsP) {
                self.featureDensityStatsP = getFeatureDensityStatsPre(self).catch(e => {
                    if (isAlive(self)) {
                        this.setFeatureDensityStatsP(undefined);
                    }
                    throw e;
                });
            }
            return self.featureDensityStatsP;
        },
        /**
         * #action
         */
        setFeatureDensityStatsP(arg) {
            self.featureDensityStatsP = arg;
        },
        /**
         * #action
         */
        setFeatureDensityStats(featureDensityStats) {
            self.featureDensityStats = featureDensityStats;
        },
        /**
         * #action
         */
        clearFeatureDensityStats() {
            self.featureDensityStatsP = undefined;
            self.featureDensityStats = undefined;
        },
    }))
        .views(self => ({
        /**
         * #getter
         * region is too large if:
         * - stats are ready
         * - region is greater than 20kb (don't warn when zoomed in less than that)
         * - and bytes is greater than max allowed bytes or density greater than max
         *   density
         */
        get regionTooLarge() {
            const view = getContainingView(self);
            if (!self.featureDensityStatsReady ||
                view.dynamicBlocks.totalBp < 20000) {
                return false;
            }
            return (self.currentBytesRequested > self.maxAllowableBytes ||
                (self.userBpPerPxLimit
                    ? view.bpPerPx > self.userBpPerPxLimit
                    : self.currentFeatureScreenDensity > self.maxFeatureScreenDensity));
        },
        /**
         * #getter
         * only shows a message of bytes requested is defined, the feature density
         * based stats don't produce any helpful message besides to zoom in
         */
        get regionTooLargeReason() {
            const req = self.currentBytesRequested;
            const max = self.maxAllowableBytes;
            return req && req > max
                ? `Requested too much data (${getDisplayStr(req)})`
                : '';
        },
    }))
        .views(self => ({
        /**
         * #method
         */
        regionCannotBeRenderedText(_region) {
            return self.regionTooLarge ? 'Force load to see features' : '';
        },
        /**
         * #method
         * @param region -
         * @returns falsy if the region is fine to try rendering. Otherwise,
         *  return a react node + string of text.
         *  string of text describes why it cannot be rendered
         *  react node allows user to force load at current setting
         */
        regionCannotBeRendered(_region) {
            return self.regionTooLarge ? (React.createElement(TooLargeMessage, { model: self })) : null;
        },
    }));
}
