import { BaseDisplay } from '@jbrowse/core/pluggableElementTypes/models';
import { ConfigurationReference } from '@jbrowse/core/configuration';
import { getContainingView, getContainingTrack, getSession, isSelectionContainer, isSessionModelWithWidgets, isFeature, } from '@jbrowse/core/util';
import CompositeMap from '@jbrowse/core/util/compositeMap';
import { getParentRenderProps } from '@jbrowse/core/util/tracks';
import { autorun } from 'mobx';
import { addDisposer, isAlive, types } from 'mobx-state-tree';
// icons
import MenuOpenIcon from '@mui/icons-material/MenuOpen';
import { Tooltip } from '../components/BaseLinearDisplay';
import BlockState from './serverSideRenderedBlock';
import configSchema from './configSchema';
import TrackHeightMixin from './TrackHeightMixin';
import FeatureDensityMixin from './FeatureDensityMixin';
/**
 * #stateModel BaseLinearDisplay
 * #category display
 *
 * BaseLinearDisplay is used as the basis for many linear genome view tracks.
 * It is block based, and can use 'static blocks' or 'dynamic blocks'
 *
 * extends
 * - [BaseDisplay](../basedisplay)
 * - [TrackHeightMixin](../trackheightmixin)
 * - [FeatureDensityMixin](../featuredensitymixin)
 */
function stateModelFactory() {
    return types
        .compose('BaseLinearDisplay', BaseDisplay, TrackHeightMixin(), FeatureDensityMixin(), types.model({
        /**
         * #property
         * updated via autorun
         */
        blockState: types.map(BlockState),
        /**
         * #property
         */
        configuration: ConfigurationReference(configSchema),
    }))
        .volatile(() => ({
        featureIdUnderMouse: undefined,
        contextMenuFeature: undefined,
    }))
        .views(self => ({
        /**
         * #getter
         */
        get blockType() {
            return 'staticBlocks';
        },
        /**
         * #getter
         */
        get blockDefinitions() {
            const view = getContainingView(self);
            if (!view.initialized) {
                throw new Error('view not initialized yet');
            }
            return view[this.blockType];
        },
    }))
        .views(self => ({
        /**
         * #getter
         * how many milliseconds to wait for the display to
         * "settle" before re-rendering a block
         */
        get renderDelay() {
            return 50;
        },
        /**
         * #getter
         */
        get TooltipComponent() {
            return Tooltip;
        },
        /**
         * #getter
         * returns a string feature ID if the globally-selected object
         * is probably a feature
         */
        get selectedFeatureId() {
            if (isAlive(self)) {
                const { selection } = getSession(self);
                // does it quack like a feature?
                if (isFeature(selection)) {
                    return selection.id();
                }
            }
            return undefined;
        },
        /**
         * #getter
         * if a display-level message should be displayed instead of the blocks,
         * make this return a react component
         */
        get DisplayMessageComponent() {
            return undefined;
        },
    }))
        .views(self => ({
        /**
         * #getter
         * a CompositeMap of `featureId -> feature obj` that
         * just looks in all the block data for that feature
         */
        get features() {
            const featureMaps = [];
            for (const block of self.blockState.values()) {
                if (block === null || block === void 0 ? void 0 : block.features) {
                    featureMaps.push(block.features);
                }
            }
            return new CompositeMap(featureMaps);
        },
        /**
         * #getter
         */
        get featureUnderMouse() {
            const feat = self.featureIdUnderMouse;
            return feat ? this.features.get(feat) : undefined;
        },
        /**
         * #getter
         */
        getFeatureOverlapping(blockKey, x, y) {
            var _a, _b;
            return (_b = (_a = self.blockState.get(blockKey)) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.getByCoord(x, y);
        },
        /**
         * #getter
         */
        getFeatureByID(blockKey, id) {
            var _a, _b;
            return (_b = (_a = self.blockState.get(blockKey)) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.getByID(id);
        },
        /**
         * #getter
         */
        searchFeatureByID(id) {
            let ret;
            self.blockState.forEach(block => {
                var _a;
                const val = (_a = block === null || block === void 0 ? void 0 : block.layout) === null || _a === void 0 ? void 0 : _a.getByID(id);
                if (val) {
                    ret = val;
                }
            });
            return ret;
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        addBlock(key, block) {
            self.blockState.set(key, BlockState.create({
                key,
                region: block.toRegion(),
            }));
        },
        /**
         * #action
         */
        deleteBlock(key) {
            self.blockState.delete(key);
        },
        /**
         * #action
         */
        selectFeature(feature) {
            const session = getSession(self);
            if (isSessionModelWithWidgets(session)) {
                const featureWidget = session.addWidget('BaseFeatureWidget', 'baseFeature', {
                    view: getContainingView(self),
                    track: getContainingTrack(self),
                    featureData: feature.toJSON(),
                });
                session.showWidget(featureWidget);
            }
            if (isSelectionContainer(session)) {
                session.setSelection(feature);
            }
        },
        /**
         * #action
         */
        clearFeatureSelection() {
            getSession(self).clearSelection();
        },
        /**
         * #action
         */
        setFeatureIdUnderMouse(feature) {
            self.featureIdUnderMouse = feature;
        },
        /**
         * #action
         */
        setContextMenuFeature(feature) {
            self.contextMenuFeature = feature;
        },
    }))
        .actions(self => {
        const { reload: superReload } = self;
        return {
            /**
             * #action
             */
            async reload() {
                self.setError();
                self.setCurrStatsBpPerPx(0);
                self.clearFeatureDensityStats();
                [...self.blockState.values()].map(val => val.doReload());
                superReload();
            },
        };
    })
        .views(self => ({
        /**
         * #method
         */
        trackMenuItems() {
            return [];
        },
        /**
         * #method
         */
        contextMenuItems() {
            return [
                ...(self.contextMenuFeature
                    ? [
                        {
                            label: 'Open feature details',
                            icon: MenuOpenIcon,
                            onClick: () => {
                                if (self.contextMenuFeature) {
                                    self.selectFeature(self.contextMenuFeature);
                                }
                            },
                        },
                    ]
                    : []),
            ];
        },
        /**
         * #method
         */
        renderProps() {
            return {
                ...getParentRenderProps(self),
                notReady: !self.featureDensityStatsReady,
                rpcDriverName: self.rpcDriverName,
                displayModel: self,
                onFeatureClick(_, featureId) {
                    const f = featureId || self.featureIdUnderMouse;
                    if (!f) {
                        self.clearFeatureSelection();
                    }
                    else {
                        const feature = self.features.get(f);
                        if (feature) {
                            self.selectFeature(feature);
                        }
                    }
                },
                onClick() {
                    self.clearFeatureSelection();
                },
                // similar to click but opens a menu with further options
                onFeatureContextMenu(_, featureId) {
                    const f = featureId || self.featureIdUnderMouse;
                    if (!f) {
                        self.clearFeatureSelection();
                    }
                    else {
                        // feature id under mouse passed to context menu
                        self.setContextMenuFeature(self.features.get(f));
                    }
                },
                onMouseMove(_, featureId) {
                    self.setFeatureIdUnderMouse(featureId);
                },
                onMouseLeave(_) {
                    self.setFeatureIdUnderMouse(undefined);
                },
                onContextMenu() {
                    self.setContextMenuFeature(undefined);
                    self.clearFeatureSelection();
                },
            };
        },
    }))
        .actions(self => ({
        /**
         * #method
         */
        async renderSvg(opts) {
            const { renderBaseLinearDisplaySvg } = await import('./renderSvg');
            return renderBaseLinearDisplaySvg(self, opts);
        },
        afterAttach() {
            // watch the parent's blocks to update our block state when they change,
            // then we recreate the blocks on our own model (creating and deleting to
            // match the parent blocks)
            addDisposer(self, autorun(() => {
                const blocksPresent = {};
                const view = getContainingView(self);
                if (!view.initialized) {
                    return;
                }
                self.blockDefinitions.contentBlocks.forEach(block => {
                    blocksPresent[block.key] = true;
                    if (!self.blockState.has(block.key)) {
                        self.addBlock(block.key, block);
                    }
                });
                self.blockState.forEach((_, key) => {
                    if (!blocksPresent[key]) {
                        self.deleteBlock(key);
                    }
                });
            }));
        },
    }))
        .preProcessSnapshot(snap => {
        if (!snap) {
            return snap;
        }
        // rewrite "height" from older snapshots to "heightPreConfig", this allows
        // us to maintain a height "getter" going forward
        // @ts-expect-error
        const { height, ...rest } = snap;
        return { heightPreConfig: height, ...rest };
    })
        .postProcessSnapshot(self => {
        // xref https://github.com/mobxjs/mobx-state-tree/issues/1524 for Omit
        const r = self;
        const { blockState, ...rest } = r;
        return rest;
    });
}
export const BaseLinearDisplay = stateModelFactory();
