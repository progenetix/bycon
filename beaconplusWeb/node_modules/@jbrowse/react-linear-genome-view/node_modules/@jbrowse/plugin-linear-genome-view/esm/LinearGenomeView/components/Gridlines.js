import React from 'react';
import { ContentBlock, ElidedBlock, InterRegionPaddingBlock, } from '@jbrowse/core/util/blockTypes';
import { makeStyles } from 'tss-react/mui';
import { observer } from 'mobx-react';
import { ContentBlock as ContentBlockComponent, ElidedBlock as ElidedBlockComponent, InterRegionPaddingBlock as InterRegionPaddingBlockComponent, } from '../../BaseLinearDisplay/components/Block';
import { makeTicks } from '../util';
const useStyles = makeStyles()(theme => ({
    verticalGuidesZoomContainer: {
        position: 'absolute',
        height: '100%',
        width: '100%',
        zIndex: 1,
        pointerEvents: 'none',
    },
    verticalGuidesContainer: {
        position: 'absolute',
        height: '100%',
        zIndex: 1,
        pointerEvents: 'none',
        display: 'flex',
    },
    tick: {
        position: 'absolute',
        height: '100%',
        width: 1,
    },
    majorTick: {
        background: theme.palette.action.disabled,
    },
    minorTick: {
        background: theme.palette.divider,
    },
}));
function RenderedBlockLines({ block, bpPerPx, }) {
    const { classes, cx } = useStyles();
    const ticks = makeTicks(block.start, block.end, bpPerPx);
    return (React.createElement(ContentBlockComponent, { block: block }, ticks.map(({ type, base }) => {
        const x = (block.reversed ? block.end - base : base - block.start) / bpPerPx;
        return (React.createElement("div", { key: base, className: cx(classes.tick, type === 'major' || type === 'labeledMajor'
                ? classes.majorTick
                : classes.minorTick), style: { left: x } }));
    })));
}
const RenderedVerticalGuides = observer(({ model }) => {
    const { staticBlocks, bpPerPx } = model;
    return (React.createElement(React.Fragment, null, staticBlocks.map((block, index) => {
        const k = `${block.key}-${index}`;
        if (block instanceof ContentBlock) {
            return React.createElement(RenderedBlockLines, { key: k, block: block, bpPerPx: bpPerPx });
        }
        else if (block instanceof ElidedBlock) {
            return React.createElement(ElidedBlockComponent, { key: k, width: block.widthPx });
        }
        else if (block instanceof InterRegionPaddingBlock) {
            return (React.createElement(InterRegionPaddingBlockComponent, { key: k, width: block.widthPx, boundary: block.variant === 'boundary' }));
        }
        return null;
    })));
});
const Gridlines = observer(function ({ model }) {
    const { classes } = useStyles();
    // find the block that needs pinning to the left side for context
    const offsetLeft = model.staticBlocks.offsetPx - model.offsetPx;
    return (React.createElement("div", { className: classes.verticalGuidesZoomContainer, style: {
            transform: model.scaleFactor !== 1 ? `scaleX(${model.scaleFactor})` : undefined,
        } },
        React.createElement("div", { className: classes.verticalGuidesContainer, style: {
                left: offsetLeft,
                width: model.staticBlocks.totalWidthPx,
            } },
            React.createElement(RenderedVerticalGuides, { model: model }))));
});
export default Gridlines;
