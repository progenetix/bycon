import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';
import { ObservableCreate } from '@jbrowse/core/util/rxjs';
import { SimpleFeature, min, max } from '@jbrowse/core/util';
import { merge } from 'rxjs';
import { map } from 'rxjs/operators';
function getFilename(uri) {
    const filename = uri.slice(uri.lastIndexOf('/') + 1);
    return filename.slice(0, filename.lastIndexOf('.'));
}
class MultiWiggleAdapter extends BaseFeatureDataAdapter {
    async getAdapters() {
        const getSubAdapter = this.getSubAdapter;
        if (!getSubAdapter) {
            throw new Error('no getSubAdapter available');
        }
        let subConfs = this.getConf('subadapters');
        if (!(subConfs === null || subConfs === void 0 ? void 0 : subConfs.length)) {
            const entries = this.getConf('bigWigs');
            subConfs = entries.map(entry => ({
                type: 'BigWigAdapter',
                source: getFilename(entry),
                bigWigLocation: {
                    uri: entry,
                },
            }));
        }
        return Promise.all(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        subConfs.map(async (conf) => {
            const dataAdapter = (await getSubAdapter(conf))
                .dataAdapter;
            return {
                source: conf.name || dataAdapter.id,
                ...conf,
                dataAdapter,
            };
        }));
    }
    // note: can't really have dis-agreeing refNames
    async getRefNames(opts) {
        const adapters = await this.getAdapters();
        const allNames = await Promise.all(adapters.map(a => a.dataAdapter.getRefNames(opts)));
        return [...new Set(allNames.flat())];
    }
    async getGlobalStats(opts) {
        const adapters = await this.getAdapters();
        const stats = (await Promise.all(
        // @ts-expect-error
        adapters.map(adp => { var _a, _b; return (_b = (_a = adp.dataAdapter).getGlobalStats) === null || _b === void 0 ? void 0 : _b.call(_a, opts); }))).filter(f => !!f);
        const scoreMin = min(stats.map(s => s.scoreMin));
        const scoreMax = max(stats.map(s => s.scoreMax));
        return { scoreMin, scoreMax };
    }
    getFeatures(region, opts = {}) {
        return ObservableCreate(async (observer) => {
            const adapters = await this.getAdapters();
            merge(...adapters.map(adp => adp.dataAdapter.getFeatures(region, opts).pipe(map(p => 
            // add source field if it does not exist
            p.get('source')
                ? p
                : new SimpleFeature({
                    ...p.toJSON(),
                    uniqueId: `${adp.source}-${p.id()}`,
                    source: adp.source,
                }))))).subscribe(observer);
        }, opts.signal);
    }
    // always render bigwig instead of calculating a feature density for it
    async getMultiRegionFeatureDensityStats(_regions) {
        return { featureDensity: 0 };
    }
    // in another adapter type, this could be dynamic depending on region or
    // something, but it is static for this particular multi-wiggle adapter type
    async getSources() {
        const adapters = await this.getAdapters();
        return adapters.map(({ dataAdapter, source, name, ...rest }) => ({
            name: source,
            __name: name,
            ...rest,
        }));
    }
    freeResources() { }
}
MultiWiggleAdapter.capabilities = [
    'hasResolution',
    'hasLocalStats',
    'hasGlobalStats',
];
export default MultiWiggleAdapter;
