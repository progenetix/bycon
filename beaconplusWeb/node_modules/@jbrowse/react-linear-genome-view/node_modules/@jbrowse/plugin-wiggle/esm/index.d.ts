/// <reference types="react" />
import Plugin from '@jbrowse/core/Plugin';
import PluginManager from '@jbrowse/core/PluginManager';
import WiggleBaseRenderer from './WiggleBaseRenderer';
import * as utils from './util';
import { modelFactory as linearWiggleDisplayModelFactory } from './LinearWiggleDisplay';
import { XYPlotRenderer } from './XYPlotRenderer';
export default class WigglePlugin extends Plugin {
    name: string;
    install(pm: PluginManager): void;
    exports: {
        LinearWiggleDisplayReactComponent: (props: {
            model: {
                id: string;
                type: "LinearWiggleDisplay";
                rpcDriverName: string | undefined;
                heightPreConfig: number | undefined;
                userBpPerPxLimit: number | undefined;
                userByteSizeLimit: number | undefined;
                blockState: import("mobx-state-tree").IMSTMap<import("mobx-state-tree").IModelType<{
                    key: import("mobx-state-tree").ISimpleType<string>;
                    region: import("mobx-state-tree").IModelType<{
                        refName: import("mobx-state-tree").ISimpleType<string>;
                        start: import("mobx-state-tree").ISimpleType<number>;
                        end: import("mobx-state-tree").ISimpleType<number>;
                        reversed: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
                    } & {
                        assemblyName: import("mobx-state-tree").ISimpleType<string>;
                    }, {
                        setRefName(newRefName: string): void;
                    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
                    reloadFlag: import("mobx-state-tree").IType<number | undefined, number, number>;
                    isLeftEndOfDisplayedRegion: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
                    isRightEndOfDisplayedRegion: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
                }, {
                    renderInProgress: AbortController | undefined;
                    filled: boolean;
                    reactElement: import("react").ReactElement<any, string | import("react").JSXElementConstructor<any>> | undefined;
                    features: Map<string, import("@jbrowse/core/util").Feature> | undefined;
                    layout: any;
                    status: string;
                    error: unknown;
                    message: string | undefined;
                    maxHeightReached: boolean;
                    ReactComponent: ({ model, }: {
                        model: {
                            error?: unknown;
                            reload: () => void;
                            message: import("react").ReactNode;
                            filled?: boolean | undefined;
                            status?: string | undefined;
                            reactElement?: import("react").ReactElement<any, string | import("react").JSXElementConstructor<any>> | undefined;
                        };
                    }) => import("react").JSX.Element | undefined;
                    renderProps: any;
                } & {
                    doReload(): void;
                    afterAttach(): void;
                    setStatus(message: string): void;
                    setLoading(abortController: AbortController): void;
                    setMessage(messageText: string): void;
                    setRendered(props: {
                        reactElement: import("react").ReactElement<any, string | import("react").JSXElementConstructor<any>>;
                        features: Map<string, import("@jbrowse/core/util").Feature>;
                        layout: any;
                        maxHeightReached: boolean;
                        renderProps: any;
                    } | undefined): void;
                    setError(error: unknown): void;
                    reload(): void;
                    beforeDestroy(): void;
                }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>> & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IMapType<import("mobx-state-tree").IModelType<{
                    key: import("mobx-state-tree").ISimpleType<string>;
                    region: import("mobx-state-tree").IModelType<{
                        refName: import("mobx-state-tree").ISimpleType<string>;
                        start: import("mobx-state-tree").ISimpleType<number>;
                        end: import("mobx-state-tree").ISimpleType<number>;
                        reversed: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
                    } & {
                        assemblyName: import("mobx-state-tree").ISimpleType<string>;
                    }, {
                        setRefName(newRefName: string): void;
                    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
                    reloadFlag: import("mobx-state-tree").IType<number | undefined, number, number>;
                    isLeftEndOfDisplayedRegion: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
                    isRightEndOfDisplayedRegion: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
                }, {
                    renderInProgress: AbortController | undefined;
                    filled: boolean;
                    reactElement: import("react").ReactElement<any, string | import("react").JSXElementConstructor<any>> | undefined;
                    features: Map<string, import("@jbrowse/core/util").Feature> | undefined;
                    layout: any;
                    status: string;
                    error: unknown;
                    message: string | undefined;
                    maxHeightReached: boolean;
                    ReactComponent: ({ model, }: {
                        model: {
                            error?: unknown;
                            reload: () => void;
                            message: import("react").ReactNode;
                            filled?: boolean | undefined;
                            status?: string | undefined;
                            reactElement?: import("react").ReactElement<any, string | import("react").JSXElementConstructor<any>> | undefined;
                        };
                    }) => import("react").JSX.Element | undefined;
                    renderProps: any;
                } & {
                    doReload(): void;
                    afterAttach(): void;
                    setStatus(message: string): void;
                    setLoading(abortController: AbortController): void;
                    setMessage(messageText: string): void;
                    setRendered(props: {
                        reactElement: import("react").ReactElement<any, string | import("react").JSXElementConstructor<any>>;
                        features: Map<string, import("@jbrowse/core/util").Feature>;
                        layout: any;
                        maxHeightReached: boolean;
                        renderProps: any;
                    } | undefined): void;
                    setError(error: unknown): void;
                    reload(): void;
                    beforeDestroy(): void;
                }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>>;
                configuration: {
                    [x: string]: any;
                } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
                    setSubschema(slotName: string, data: unknown): any;
                } & import("mobx-state-tree").IStateTreeNode<import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaType<{
                    maxFeatureScreenDensity: {
                        type: string;
                        description: string;
                        defaultValue: number;
                    };
                    fetchSizeLimit: {
                        type: string;
                        defaultValue: number;
                        description: string;
                    };
                    height: {
                        type: string;
                        defaultValue: number;
                        description: string;
                    };
                    mouseover: {
                        type: string;
                        description: string;
                        defaultValue: string;
                        contextVariable: string[];
                    };
                }, import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaOptions<undefined, "displayId">> & import("@jbrowse/core/configuration").AnyConfigurationSchemaType>;
                selectedRendering: string;
                resolution: number;
                fill: boolean | undefined;
                minSize: number | undefined;
                color: string | undefined;
                posColor: string | undefined;
                negColor: string | undefined;
                summaryScoreMode: string | undefined;
                rendererTypeNameState: string | undefined;
                scale: string | undefined;
                autoscale: string | undefined;
                displayCrossHatches: boolean | undefined;
                constraints: {
                    max: number | undefined;
                    min: number | undefined;
                } & import("mobx-state-tree/dist/internal").NonEmptyObject & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").IModelType<{
                    max: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
                    min: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
                }, {}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>, [undefined]>>;
            } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
                rendererTypeName: string;
                error: unknown;
                message: string | undefined;
            } & {
                readonly RenderingComponent: import("react").FC<{
                    model: {
                        id: string;
                        type: string;
                        rpcDriverName: string | undefined;
                    } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
                        rendererTypeName: string;
                        error: unknown;
                        message: string | undefined;
                    } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
                        id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
                        type: import("mobx-state-tree").ISimpleType<string>;
                        rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
                    }, {
                        rendererTypeName: string;
                        error: unknown;
                        message: string | undefined;
                    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
                    onHorizontalScroll?: Function | undefined;
                    blockState?: Record<string, any> | undefined;
                }>;
                readonly DisplayBlurb: import("react").FC<{
                    model: {
                        id: string;
                        type: string;
                        rpcDriverName: string | undefined;
                    } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
                        rendererTypeName: string;
                        error: unknown;
                        message: string | undefined;
                    } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
                        id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
                        type: import("mobx-state-tree").ISimpleType<string>;
                        rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
                    }, {
                        rendererTypeName: string;
                        error: unknown;
                        message: string | undefined;
                    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
                }> | null;
                readonly adapterConfig: any;
                readonly parentTrack: any;
                renderProps(): any;
                readonly rendererType: import("@jbrowse/core/pluggableElementTypes").RendererType;
                readonly DisplayMessageComponent: import("react").FC<any> | undefined;
                trackMenuItems(): import("@jbrowse/core/ui").MenuItem[];
                readonly viewMenuActions: import("@jbrowse/core/ui").MenuItem[];
                regionCannotBeRendered(): null;
            } & {
                setMessage(arg?: string | undefined): void;
                setError(error?: unknown): void;
                setRpcDriverName(rpcDriverName: string): void;
                reload(): void;
            } & {
                scrollTop: number;
            } & {
                readonly height: number;
            } & {
                setScrollTop(scrollTop: number): void;
                setHeight(displayHeight: number): number;
                resizeHeight(distance: number): number;
            } & {
                featureDensityStatsP: Promise<import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats> | undefined;
                featureDensityStats: import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats | undefined;
                currStatsBpPerPx: number;
            } & {
                readonly currentBytesRequested: number;
                readonly currentFeatureScreenDensity: number;
                readonly maxFeatureScreenDensity: any;
                readonly featureDensityStatsReady: boolean;
                readonly maxAllowableBytes: number;
            } & {
                afterAttach(): void;
            } & {
                setCurrStatsBpPerPx(n: number): void;
                setFeatureDensityStatsLimit(stats?: import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats | undefined): void;
                getFeatureDensityStats(): Promise<import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats>;
                setFeatureDensityStatsP(arg: any): void;
                setFeatureDensityStats(featureDensityStats?: import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats | undefined): void;
                clearFeatureDensityStats(): void;
            } & {
                readonly regionTooLarge: boolean;
                readonly regionTooLargeReason: string;
            } & {
                regionCannotBeRenderedText(_region: import("@jbrowse/core/util/types").Region): "" | "Force load to see features";
                regionCannotBeRendered(_region: import("@jbrowse/core/util/types").Region): import("react").JSX.Element | null;
            } & {
                featureIdUnderMouse: string | undefined;
                contextMenuFeature: import("@jbrowse/core/util").Feature | undefined;
            } & {
                readonly blockType: "dynamicBlocks" | "staticBlocks";
                readonly blockDefinitions: import("@jbrowse/core/util/blockTypes").BlockSet;
            } & {
                readonly renderDelay: number;
                readonly TooltipComponent: import("react").FC<any>;
                readonly selectedFeatureId: string | undefined;
                readonly DisplayMessageComponent: import("react").FC<any> | undefined;
            } & {
                readonly features: import("@jbrowse/core/util/compositeMap").default<string, import("@jbrowse/core/util").Feature>;
                readonly featureUnderMouse: import("@jbrowse/core/util").Feature | undefined;
                getFeatureOverlapping(blockKey: string, x: number, y: number): string | undefined;
                getFeatureByID(blockKey: string, id: string): [number, number, number, number] | undefined;
                searchFeatureByID(id: string): [number, number, number, number] | undefined;
            } & {
                addBlock(key: string, block: import("@jbrowse/core/util/blockTypes").BaseBlock): void;
                deleteBlock(key: string): void;
                selectFeature(feature: import("@jbrowse/core/util").Feature): void;
                clearFeatureSelection(): void;
                setFeatureIdUnderMouse(feature?: string | undefined): void;
                setContextMenuFeature(feature?: import("@jbrowse/core/util").Feature | undefined): void;
            } & {
                reload(): Promise<void>;
            } & {
                trackMenuItems(): import("@jbrowse/core/ui").MenuItem[];
                contextMenuItems(): import("@jbrowse/core/ui").MenuItem[];
                renderProps(): any;
            } & {
                renderSvg(opts: import("@jbrowse/plugin-linear-genome-view").ExportSvgDisplayOptions): Promise<import("react").JSX.Element>;
                afterAttach(): void;
            } & {
                message: string | undefined;
                stats: {
                    scoreMin: number;
                    scoreMax: number;
                } | undefined;
                statsFetchInProgress: AbortController | undefined;
            } & {
                updateQuantitativeStats(stats: {
                    scoreMin: number;
                    scoreMax: number;
                }): void;
                setColor(color?: string | undefined): void;
                setPosColor(color?: string | undefined): void;
                setNegColor(color?: string | undefined): void;
                setLoading(aborter: AbortController): void;
                selectFeature(feature: import("@jbrowse/core/util").Feature): void;
                setResolution(res: number): void;
                setFill(fill: number): void;
                toggleLogScale(): void;
                setScaleType(scale?: string | undefined): void;
                setSummaryScoreMode(val: string): void;
                setAutoscale(val: string): void;
                setMaxScore(val?: number | undefined): void;
                setRendererType(val: string): void;
                setMinScore(val?: number | undefined): void;
                toggleCrossHatches(): void;
                setCrossHatches(cross: boolean): void;
            } & {
                readonly adapterTypeName: any;
                readonly rendererTypeNameSimple: any;
                readonly filters: undefined;
                readonly scaleType: any;
                readonly maxScore: any;
                readonly minScore: any;
            } & {
                readonly adapterCapabilities: string[];
                readonly rendererConfig: {
                    [x: string]: any;
                } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
                    setSubschema(slotName: string, data: unknown): any;
                } & import("mobx-state-tree").IStateTreeNode<import("@jbrowse/core/configuration").AnyConfigurationSchemaType>;
                readonly autoscaleType: any;
            } & {
                readonly domain: number[] | undefined;
            } & {
                readonly filled: boolean;
                readonly summaryScoreModeSetting: string;
                readonly scaleOpts: {
                    domain: number[] | undefined;
                    stats: {
                        scoreMin: number;
                        scoreMax: number;
                    } | undefined;
                    autoscaleType: any;
                    scaleType: any;
                    inverted: any;
                };
                readonly canHaveFill: boolean;
                readonly displayCrossHatchesSetting: boolean;
                readonly hasResolution: boolean;
                readonly hasGlobalStats: boolean;
            } & {
                scoreTrackMenuItems(): ({
                    label: string;
                    subMenu: {
                        label: string;
                        onClick: () => void;
                    }[];
                    onClick?: undefined;
                } | {
                    label: string;
                    subMenu: {
                        label: string;
                        type: string;
                        checked: boolean;
                        onClick: () => void;
                    }[];
                    onClick?: undefined;
                } | {
                    label: string;
                    onClick: () => void;
                    subMenu?: undefined;
                })[];
            } & {
                reload(): Promise<void>;
            } & {
                readonly TooltipComponent: import("react").FC<{}>;
                readonly rendererTypeName: string;
            } & {
                readonly ticks: {
                    range: number[];
                    values: number[];
                    format: (d: import("d3-scale").NumberValue) => string;
                    position: import("d3-scale").ScaleLinear<number, number, never> | import("d3-scale").ScaleQuantize<number, never>;
                } | undefined;
            } & {
                renderProps(): any;
                readonly needsScalebar: boolean;
                readonly fillSetting: 2 | 0 | 1;
            } & {
                trackMenuItems(): (import("@jbrowse/core/ui").MenuDivider | import("@jbrowse/core/ui").MenuSubHeader | import("@jbrowse/core/ui").NormalMenuItem | import("@jbrowse/core/ui").CheckboxMenuItem | import("@jbrowse/core/ui").RadioMenuItem | import("@jbrowse/core/ui").SubMenuItem | {
                    label: string;
                    subMenu: ({
                        label: string;
                        subMenu: {
                            label: string;
                            onClick: () => void;
                        }[];
                        onClick?: undefined;
                    } | {
                        label: string;
                        subMenu: {
                            label: string;
                            type: string;
                            checked: boolean;
                            onClick: () => void;
                        }[];
                        onClick?: undefined;
                    } | {
                        label: string;
                        onClick: () => void;
                        subMenu?: undefined;
                    })[];
                    type?: undefined;
                    checked?: undefined;
                    onClick?: undefined;
                } | {
                    label: string;
                    subMenu: {
                        label: string;
                        type: string;
                        checked: boolean;
                        onClick: () => void;
                    }[];
                    type?: undefined;
                    checked?: undefined;
                    onClick?: undefined;
                } | {
                    type: string;
                    label: string;
                    checked: boolean;
                    onClick: () => void;
                    subMenu?: undefined;
                })[];
            } & {
                afterAttach(): void;
                renderSvg(opts: import("@jbrowse/plugin-linear-genome-view").ExportSvgDisplayOptions): Promise<import("react").JSX.Element>;
            } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
                id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
                type: import("mobx-state-tree").ISimpleType<string>;
                rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
            } & {
                heightPreConfig: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
            } & {
                userBpPerPxLimit: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
                userByteSizeLimit: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
            } & {
                blockState: import("mobx-state-tree").IMapType<import("mobx-state-tree").IModelType<{
                    key: import("mobx-state-tree").ISimpleType<string>;
                    region: import("mobx-state-tree").IModelType<{
                        refName: import("mobx-state-tree").ISimpleType<string>;
                        start: import("mobx-state-tree").ISimpleType<number>;
                        end: import("mobx-state-tree").ISimpleType<number>;
                        reversed: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
                    } & {
                        assemblyName: import("mobx-state-tree").ISimpleType<string>;
                    }, {
                        setRefName(newRefName: string): void;
                    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
                    reloadFlag: import("mobx-state-tree").IType<number | undefined, number, number>;
                    isLeftEndOfDisplayedRegion: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
                    isRightEndOfDisplayedRegion: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
                }, {
                    renderInProgress: AbortController | undefined;
                    filled: boolean;
                    reactElement: import("react").ReactElement<any, string | import("react").JSXElementConstructor<any>> | undefined;
                    features: Map<string, import("@jbrowse/core/util").Feature> | undefined;
                    layout: any;
                    status: string;
                    error: unknown;
                    message: string | undefined;
                    maxHeightReached: boolean;
                    ReactComponent: ({ model, }: {
                        model: {
                            error?: unknown;
                            reload: () => void;
                            message: import("react").ReactNode;
                            filled?: boolean | undefined;
                            status?: string | undefined;
                            reactElement?: import("react").ReactElement<any, string | import("react").JSXElementConstructor<any>> | undefined;
                        };
                    }) => import("react").JSX.Element | undefined;
                    renderProps: any;
                } & {
                    doReload(): void;
                    afterAttach(): void;
                    setStatus(message: string): void;
                    setLoading(abortController: AbortController): void;
                    setMessage(messageText: string): void;
                    setRendered(props: {
                        reactElement: import("react").ReactElement<any, string | import("react").JSXElementConstructor<any>>;
                        features: Map<string, import("@jbrowse/core/util").Feature>;
                        layout: any;
                        maxHeightReached: boolean;
                        renderProps: any;
                    } | undefined): void;
                    setError(error: unknown): void;
                    reload(): void;
                    beforeDestroy(): void;
                }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
                configuration: import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaType<{
                    maxFeatureScreenDensity: {
                        type: string;
                        description: string;
                        defaultValue: number;
                    };
                    fetchSizeLimit: {
                        type: string;
                        defaultValue: number;
                        description: string;
                    };
                    height: {
                        type: string;
                        defaultValue: number;
                        description: string;
                    };
                    mouseover: {
                        type: string;
                        description: string;
                        defaultValue: string;
                        contextVariable: string[];
                    };
                }, import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaOptions<undefined, "displayId">>;
            } & {
                selectedRendering: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
                resolution: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<number>, [undefined]>;
                fill: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<boolean>>;
                minSize: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
                color: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
                posColor: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
                negColor: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
                summaryScoreMode: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
                rendererTypeNameState: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
                scale: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
                autoscale: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
                displayCrossHatches: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<boolean>>;
                constraints: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").IModelType<{
                    max: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
                    min: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
                }, {}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>, [undefined]>;
                configuration: import("@jbrowse/core/configuration").AnyConfigurationSchemaType;
            } & {
                type: import("mobx-state-tree").ISimpleType<"LinearWiggleDisplay">;
            }, {
                rendererTypeName: string;
                error: unknown;
                message: string | undefined;
            } & {
                readonly RenderingComponent: import("react").FC<{
                    model: {
                        id: string;
                        type: string;
                        rpcDriverName: string | undefined;
                    } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
                        rendererTypeName: string;
                        error: unknown;
                        message: string | undefined;
                    } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
                        id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
                        type: import("mobx-state-tree").ISimpleType<string>;
                        rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
                    }, {
                        rendererTypeName: string;
                        error: unknown;
                        message: string | undefined;
                    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
                    onHorizontalScroll?: Function | undefined;
                    blockState?: Record<string, any> | undefined;
                }>;
                readonly DisplayBlurb: import("react").FC<{
                    model: {
                        id: string;
                        type: string;
                        rpcDriverName: string | undefined;
                    } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
                        rendererTypeName: string;
                        error: unknown;
                        message: string | undefined;
                    } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
                        id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
                        type: import("mobx-state-tree").ISimpleType<string>;
                        rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
                    }, {
                        rendererTypeName: string;
                        error: unknown;
                        message: string | undefined;
                    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
                }> | null;
                readonly adapterConfig: any;
                readonly parentTrack: any;
                renderProps(): any;
                readonly rendererType: import("@jbrowse/core/pluggableElementTypes").RendererType;
                readonly DisplayMessageComponent: import("react").FC<any> | undefined;
                trackMenuItems(): import("@jbrowse/core/ui").MenuItem[];
                readonly viewMenuActions: import("@jbrowse/core/ui").MenuItem[];
                regionCannotBeRendered(): null;
            } & {
                setMessage(arg?: string | undefined): void;
                setError(error?: unknown): void;
                setRpcDriverName(rpcDriverName: string): void;
                reload(): void;
            } & {
                scrollTop: number;
            } & {
                readonly height: number;
            } & {
                setScrollTop(scrollTop: number): void;
                setHeight(displayHeight: number): number;
                resizeHeight(distance: number): number;
            } & {
                featureDensityStatsP: Promise<import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats> | undefined;
                featureDensityStats: import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats | undefined;
                currStatsBpPerPx: number;
            } & {
                readonly currentBytesRequested: number;
                readonly currentFeatureScreenDensity: number;
                readonly maxFeatureScreenDensity: any;
                readonly featureDensityStatsReady: boolean;
                readonly maxAllowableBytes: number;
            } & {
                afterAttach(): void;
            } & {
                setCurrStatsBpPerPx(n: number): void;
                setFeatureDensityStatsLimit(stats?: import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats | undefined): void;
                getFeatureDensityStats(): Promise<import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats>;
                setFeatureDensityStatsP(arg: any): void;
                setFeatureDensityStats(featureDensityStats?: import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats | undefined): void;
                clearFeatureDensityStats(): void;
            } & {
                readonly regionTooLarge: boolean;
                readonly regionTooLargeReason: string;
            } & {
                regionCannotBeRenderedText(_region: import("@jbrowse/core/util/types").Region): "" | "Force load to see features";
                regionCannotBeRendered(_region: import("@jbrowse/core/util/types").Region): import("react").JSX.Element | null;
            } & {
                featureIdUnderMouse: string | undefined;
                contextMenuFeature: import("@jbrowse/core/util").Feature | undefined;
            } & {
                readonly blockType: "dynamicBlocks" | "staticBlocks";
                readonly blockDefinitions: import("@jbrowse/core/util/blockTypes").BlockSet;
            } & {
                readonly renderDelay: number;
                readonly TooltipComponent: import("react").FC<any>;
                readonly selectedFeatureId: string | undefined;
                readonly DisplayMessageComponent: import("react").FC<any> | undefined;
            } & {
                readonly features: import("@jbrowse/core/util/compositeMap").default<string, import("@jbrowse/core/util").Feature>;
                readonly featureUnderMouse: import("@jbrowse/core/util").Feature | undefined;
                getFeatureOverlapping(blockKey: string, x: number, y: number): string | undefined;
                getFeatureByID(blockKey: string, id: string): [number, number, number, number] | undefined;
                searchFeatureByID(id: string): [number, number, number, number] | undefined;
            } & {
                addBlock(key: string, block: import("@jbrowse/core/util/blockTypes").BaseBlock): void;
                deleteBlock(key: string): void;
                selectFeature(feature: import("@jbrowse/core/util").Feature): void;
                clearFeatureSelection(): void;
                setFeatureIdUnderMouse(feature?: string | undefined): void;
                setContextMenuFeature(feature?: import("@jbrowse/core/util").Feature | undefined): void;
            } & {
                reload(): Promise<void>;
            } & {
                trackMenuItems(): import("@jbrowse/core/ui").MenuItem[];
                contextMenuItems(): import("@jbrowse/core/ui").MenuItem[];
                renderProps(): any;
            } & {
                renderSvg(opts: import("@jbrowse/plugin-linear-genome-view").ExportSvgDisplayOptions): Promise<import("react").JSX.Element>;
                afterAttach(): void;
            } & {
                message: string | undefined;
                stats: {
                    scoreMin: number;
                    scoreMax: number;
                } | undefined;
                statsFetchInProgress: AbortController | undefined;
            } & {
                updateQuantitativeStats(stats: {
                    scoreMin: number;
                    scoreMax: number;
                }): void;
                setColor(color?: string | undefined): void;
                setPosColor(color?: string | undefined): void;
                setNegColor(color?: string | undefined): void;
                setLoading(aborter: AbortController): void;
                selectFeature(feature: import("@jbrowse/core/util").Feature): void;
                setResolution(res: number): void;
                setFill(fill: number): void;
                toggleLogScale(): void;
                setScaleType(scale?: string | undefined): void;
                setSummaryScoreMode(val: string): void;
                setAutoscale(val: string): void;
                setMaxScore(val?: number | undefined): void;
                setRendererType(val: string): void;
                setMinScore(val?: number | undefined): void;
                toggleCrossHatches(): void;
                setCrossHatches(cross: boolean): void;
            } & {
                readonly adapterTypeName: any;
                readonly rendererTypeNameSimple: any;
                readonly filters: undefined;
                readonly scaleType: any;
                readonly maxScore: any;
                readonly minScore: any;
            } & {
                readonly adapterCapabilities: string[];
                readonly rendererConfig: {
                    [x: string]: any;
                } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
                    setSubschema(slotName: string, data: unknown): any;
                } & import("mobx-state-tree").IStateTreeNode<import("@jbrowse/core/configuration").AnyConfigurationSchemaType>;
                readonly autoscaleType: any;
            } & {
                readonly domain: number[] | undefined;
            } & {
                readonly filled: boolean;
                readonly summaryScoreModeSetting: string;
                readonly scaleOpts: {
                    domain: number[] | undefined;
                    stats: {
                        scoreMin: number;
                        scoreMax: number;
                    } | undefined;
                    autoscaleType: any;
                    scaleType: any;
                    inverted: any;
                };
                readonly canHaveFill: boolean;
                readonly displayCrossHatchesSetting: boolean;
                readonly hasResolution: boolean;
                readonly hasGlobalStats: boolean;
            } & {
                scoreTrackMenuItems(): ({
                    label: string;
                    subMenu: {
                        label: string;
                        onClick: () => void;
                    }[];
                    onClick?: undefined;
                } | {
                    label: string;
                    subMenu: {
                        label: string;
                        type: string;
                        checked: boolean;
                        onClick: () => void;
                    }[];
                    onClick?: undefined;
                } | {
                    label: string;
                    onClick: () => void;
                    subMenu?: undefined;
                })[];
            } & {
                reload(): Promise<void>;
            } & {
                readonly TooltipComponent: import("react").FC<{}>;
                readonly rendererTypeName: string;
            } & {
                readonly ticks: {
                    range: number[];
                    values: number[];
                    format: (d: import("d3-scale").NumberValue) => string;
                    position: import("d3-scale").ScaleLinear<number, number, never> | import("d3-scale").ScaleQuantize<number, never>;
                } | undefined;
            } & {
                renderProps(): any;
                readonly needsScalebar: boolean;
                readonly fillSetting: 2 | 0 | 1;
            } & {
                trackMenuItems(): (import("@jbrowse/core/ui").MenuDivider | import("@jbrowse/core/ui").MenuSubHeader | import("@jbrowse/core/ui").NormalMenuItem | import("@jbrowse/core/ui").CheckboxMenuItem | import("@jbrowse/core/ui").RadioMenuItem | import("@jbrowse/core/ui").SubMenuItem | {
                    label: string;
                    subMenu: ({
                        label: string;
                        subMenu: {
                            label: string;
                            onClick: () => void;
                        }[];
                        onClick?: undefined;
                    } | {
                        label: string;
                        subMenu: {
                            label: string;
                            type: string;
                            checked: boolean;
                            onClick: () => void;
                        }[];
                        onClick?: undefined;
                    } | {
                        label: string;
                        onClick: () => void;
                        subMenu?: undefined;
                    })[];
                    type?: undefined;
                    checked?: undefined;
                    onClick?: undefined;
                } | {
                    label: string;
                    subMenu: {
                        label: string;
                        type: string;
                        checked: boolean;
                        onClick: () => void;
                    }[];
                    type?: undefined;
                    checked?: undefined;
                    onClick?: undefined;
                } | {
                    type: string;
                    label: string;
                    checked: boolean;
                    onClick: () => void;
                    subMenu?: undefined;
                })[];
            } & {
                afterAttach(): void;
                renderSvg(opts: import("@jbrowse/plugin-linear-genome-view").ExportSvgDisplayOptions): Promise<import("react").JSX.Element>;
            }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
        }) => import("react").JSX.Element;
        XYPlotRendererReactComponent: (props: {
            regions: import("@jbrowse/core/util/types").Region[];
            features: Map<string, import("@jbrowse/core/util").Feature>;
            bpPerPx: number;
            width: number;
            height: number;
            onMouseLeave: Function;
            onMouseMove: Function;
            onFeatureClick: Function;
            blockKey: string;
        }) => import("react").JSX.Element;
        XYPlotRenderer: typeof XYPlotRenderer;
        WiggleBaseRenderer: typeof WiggleBaseRenderer;
        linearWiggleDisplayModelFactory: typeof linearWiggleDisplayModelFactory;
        xyPlotRendererConfigSchema: import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaType<{
            filled: {
                type: string;
                defaultValue: boolean;
            };
            displayCrossHatches: {
                type: string;
                description: string;
                defaultValue: boolean;
            };
            summaryScoreMode: {
                type: string;
                model: import("mobx-state-tree").ISimpleType<string>;
                description: string;
                defaultValue: string;
            };
            minSize: {
                type: string;
                defaultValue: number;
            };
        }, import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaOptions<import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaType<{
            color: {
                type: string;
                description: string;
                defaultValue: string;
            };
            posColor: {
                type: string;
                description: string;
                defaultValue: string;
            };
            negColor: {
                type: string;
                description: string;
                defaultValue: string;
            };
            clipColor: {
                type: string;
                description: string;
                defaultValue: string;
            };
            bicolorPivot: {
                type: string;
                model: import("mobx-state-tree").ISimpleType<string>;
                description: string;
                defaultValue: string;
            };
            bicolorPivotValue: {
                type: string;
                defaultValue: number;
                description: string;
            };
        }, import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaOptions<undefined, undefined>>, undefined>>;
        utils: typeof utils;
    };
}
export * from './util';
export { default as WiggleRendering } from './WiggleRendering';
export { Tooltip, ReactComponent as LinearWiggleDisplayReactComponent, modelFactory as linearWiggleDisplayModelFactory, } from './LinearWiggleDisplay';
export { type TooltipContentsComponent } from './Tooltip';
export { default as WiggleBaseRenderer } from './WiggleBaseRenderer';
