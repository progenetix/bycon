import React from 'react';
import { Instance } from 'mobx-state-tree';
import { AnyConfigurationSchemaType } from '@jbrowse/core/configuration';
import { Feature } from '@jbrowse/core/util';
import PluginManager from '@jbrowse/core/PluginManager';
import { ExportSvgDisplayOptions } from '@jbrowse/plugin-linear-genome-view';
interface Source {
    name: string;
    color?: string;
    group?: string;
}
/**
 * #stateModel MultiLinearWiggleDisplay
 * extends
 * - [SharedWiggleMixin](../sharedwigglemixin)
 */
export declare function stateModelFactory(pluginManager: PluginManager, configSchema: AnyConfigurationSchemaType): import("mobx-state-tree").IModelType<{
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    type: import("mobx-state-tree").ISimpleType<string>;
    rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
} & {
    heightPreConfig: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
} & {
    userBpPerPxLimit: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
    userByteSizeLimit: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
} & {
    blockState: import("mobx-state-tree").IMapType<import("mobx-state-tree").IModelType<{
        key: import("mobx-state-tree").ISimpleType<string>;
        region: import("mobx-state-tree").IModelType<{
            refName: import("mobx-state-tree").ISimpleType<string>;
            start: import("mobx-state-tree").ISimpleType<number>;
            end: import("mobx-state-tree").ISimpleType<number>;
            reversed: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
        } & {
            assemblyName: import("mobx-state-tree").ISimpleType<string>;
        }, {
            setRefName(newRefName: string): void;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
        reloadFlag: import("mobx-state-tree").IType<number | undefined, number, number>;
        isLeftEndOfDisplayedRegion: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
        isRightEndOfDisplayedRegion: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    }, {
        renderInProgress: AbortController | undefined;
        filled: boolean;
        reactElement: React.ReactElement<any, string | React.JSXElementConstructor<any>> | undefined;
        features: Map<string, Feature> | undefined;
        layout: any;
        status: string;
        error: unknown;
        message: string | undefined;
        maxHeightReached: boolean;
        ReactComponent: ({ model, }: {
            model: {
                error?: unknown;
                reload: () => void;
                message: React.ReactNode;
                filled?: boolean | undefined;
                status?: string | undefined;
                reactElement?: React.ReactElement<any, string | React.JSXElementConstructor<any>> | undefined;
            };
        }) => React.JSX.Element | undefined;
        renderProps: any;
    } & {
        doReload(): void;
        afterAttach(): void;
        setStatus(message: string): void;
        setLoading(abortController: AbortController): void;
        setMessage(messageText: string): void;
        setRendered(props: {
            reactElement: React.ReactElement<any, string | React.JSXElementConstructor<any>>; /**
             * #getter
             */
            features: Map<string, Feature>;
            layout: any;
            maxHeightReached: boolean;
            renderProps: any;
        } | undefined): void;
        setError(error: unknown): void;
        reload(): void;
        beforeDestroy(): void;
    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
    configuration: import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaType<{
        maxFeatureScreenDensity: {
            type: string;
            description: string;
            defaultValue: number;
        };
        fetchSizeLimit: {
            type: string;
            defaultValue: number;
            description: string;
        };
        height: {
            type: string;
            defaultValue: number;
            description: string;
        };
        mouseover: {
            type: string;
            description: string;
            defaultValue: string;
            contextVariable: string[];
        };
    }, import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaOptions<undefined, "displayId">>;
} & {
    selectedRendering: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    resolution: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<number>, [undefined]>;
    fill: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<boolean>>;
    minSize: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
    color: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
    posColor: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
    negColor: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
    summaryScoreMode: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
    rendererTypeNameState: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
    scale: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
    autoscale: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
    displayCrossHatches: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<boolean>>; /**
     * #property
     */
    constraints: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").IModelType<{
        max: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
        min: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
    }, {}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>, [undefined]>;
    configuration: AnyConfigurationSchemaType;
} & {
    /**
     * #property
     */
    type: import("mobx-state-tree").ISimpleType<"MultiLinearWiggleDisplay">;
    /**
     * #property
     */
    layout: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").IType<Source[], Source[], Source[]>, [undefined]>;
}, {
    rendererTypeName: string;
    error: unknown;
    message: string | undefined;
} & {
    readonly RenderingComponent: React.FC<{
        model: {
            id: string;
            type: string;
            rpcDriverName: string | undefined;
        } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
            rendererTypeName: string;
            error: unknown;
            message: string | undefined;
        } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
            id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
            type: import("mobx-state-tree").ISimpleType<string>;
            rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
        }, {
            rendererTypeName: string;
            error: unknown;
            message: string | undefined;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
        onHorizontalScroll?: Function | undefined;
        blockState?: Record<string, any> | undefined;
    }>;
    readonly DisplayBlurb: React.FC<{
        model: {
            id: string;
            type: string;
            rpcDriverName: string | undefined;
        } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
            rendererTypeName: string;
            error: unknown;
            message: string | undefined;
        } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
            id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>; /**
             * #action
             */
            type: import("mobx-state-tree").ISimpleType<string>;
            rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>; /**
             * #getter
             */
        }, {
            rendererTypeName: string;
            error: unknown;
            message: string | undefined;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
    }> | null;
    readonly adapterConfig: any;
    readonly parentTrack: any;
    renderProps(): any;
    readonly rendererType: import("@jbrowse/core/pluggableElementTypes").RendererType;
    readonly DisplayMessageComponent: React.FC<any> | undefined;
    trackMenuItems(): import("@jbrowse/core/ui").MenuItem[];
    readonly viewMenuActions: import("@jbrowse/core/ui").MenuItem[];
    regionCannotBeRendered(): null;
} & {
    setMessage(arg?: string | undefined): void;
    setError(error?: unknown): void;
    setRpcDriverName(rpcDriverName: string): void;
    reload(): void;
} & {
    scrollTop: number;
} & {
    readonly height: number;
} & {
    setScrollTop(scrollTop: number): void;
    setHeight(displayHeight: number): number;
    resizeHeight(distance: number): number;
} & {
    featureDensityStatsP: Promise<import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats> | undefined;
    featureDensityStats: import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats | undefined;
    currStatsBpPerPx: number;
} & {
    readonly currentBytesRequested: number;
    readonly currentFeatureScreenDensity: number;
    readonly maxFeatureScreenDensity: any; /**
     * #property
     */
    readonly featureDensityStatsReady: boolean;
    readonly maxAllowableBytes: number;
} & {
    afterAttach(): void;
} & {
    setCurrStatsBpPerPx(n: number): void;
    setFeatureDensityStatsLimit(stats?: import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats | undefined): void;
    getFeatureDensityStats(): Promise<import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats>;
    setFeatureDensityStatsP(arg: any): void;
    setFeatureDensityStats(featureDensityStats?: import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats | undefined): void;
    clearFeatureDensityStats(): void;
} & {
    readonly regionTooLarge: boolean;
    readonly regionTooLargeReason: string;
} & {
    regionCannotBeRenderedText(_region: import("@jbrowse/core/util").Region): "" | "Force load to see features";
    regionCannotBeRendered(_region: import("@jbrowse/core/util").Region): React.JSX.Element | null;
} & {
    featureIdUnderMouse: string | undefined;
    contextMenuFeature: Feature | undefined;
} & {
    readonly blockType: "dynamicBlocks" | "staticBlocks";
    readonly blockDefinitions: import("@jbrowse/core/util/blockTypes").BlockSet;
} & {
    readonly renderDelay: number;
    readonly TooltipComponent: React.FC<any>;
    readonly selectedFeatureId: string | undefined;
    readonly DisplayMessageComponent: React.FC<any> | undefined;
} & {
    readonly features: import("@jbrowse/core/util/compositeMap").default<string, Feature>;
    readonly featureUnderMouse: Feature | undefined;
    getFeatureOverlapping(blockKey: string, x: number, y: number): string | undefined;
    getFeatureByID(blockKey: string, id: string): [number, number, number, number] | undefined;
    searchFeatureByID(id: string): [number, number, number, number] | undefined;
} & {
    addBlock(key: string, block: import("@jbrowse/core/util/blockTypes").BaseBlock): void;
    deleteBlock(key: string): void;
    selectFeature(feature: Feature): void;
    clearFeatureSelection(): void;
    setFeatureIdUnderMouse(feature?: string | undefined): void;
    setContextMenuFeature(feature?: Feature | undefined): void;
} & {
    reload(): Promise<void>;
} & {
    trackMenuItems(): import("@jbrowse/core/ui").MenuItem[];
    contextMenuItems(): import("@jbrowse/core/ui").MenuItem[];
    renderProps(): any;
} & {
    renderSvg(opts: ExportSvgDisplayOptions): Promise<React.JSX.Element>;
    afterAttach(): void;
} & {
    message: string | undefined;
    stats: {
        scoreMin: number;
        scoreMax: number;
    } | undefined; /**
     * #action
     */
    statsFetchInProgress: AbortController | undefined;
} & {
    updateQuantitativeStats(stats: {
        scoreMin: number;
        scoreMax: number;
    }): void;
    setColor(color?: string | undefined): void;
    setPosColor(color?: string | undefined): void;
    setNegColor(color?: string | undefined): void;
    setLoading(aborter: AbortController): void;
    selectFeature(feature: Feature): void;
    setResolution(res: number): void;
    setFill(fill: number): void;
    toggleLogScale(): void;
    setScaleType(scale?: string | undefined): void;
    setSummaryScoreMode(val: string): void;
    setAutoscale(val: string): void;
    setMaxScore(val?: number | undefined): void;
    setRendererType(val: string): void;
    setMinScore(val?: number | undefined): void;
    toggleCrossHatches(): void;
    setCrossHatches(cross: boolean): void;
} & {
    readonly adapterTypeName: any;
    readonly rendererTypeNameSimple: any;
    readonly filters: undefined;
    readonly scaleType: any;
    readonly maxScore: any;
    readonly minScore: any;
} & {
    readonly adapterCapabilities: string[];
    readonly rendererConfig: {
        [x: string]: any;
    } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
        setSubschema(slotName: string, data: unknown): any;
    } & import("mobx-state-tree").IStateTreeNode<AnyConfigurationSchemaType>;
    readonly autoscaleType: any;
} & {
    readonly domain: number[] | undefined;
} & {
    readonly filled: boolean;
    readonly summaryScoreModeSetting: string;
    readonly scaleOpts: {
        domain: number[] | undefined;
        stats: {
            scoreMin: number;
            scoreMax: number;
        } | undefined;
        autoscaleType: any;
        scaleType: any;
        inverted: any;
    };
    readonly canHaveFill: boolean;
    readonly displayCrossHatchesSetting: boolean;
    readonly hasResolution: boolean;
    readonly hasGlobalStats: boolean;
} & {
    scoreTrackMenuItems(): ({
        label: string;
        subMenu: {
            label: string;
            onClick: () => void;
        }[];
        onClick?: undefined;
    } | {
        label: string;
        subMenu: {
            label: string;
            type: string;
            checked: boolean;
            onClick: () => void;
        }[];
        onClick?: undefined;
    } | {
        label: string;
        onClick: () => void;
        subMenu?: undefined;
    })[];
} & {
    reload(): Promise<void>;
} & {
    featureUnderMouseVolatile: Feature | undefined;
    sourcesVolatile: Source[] | undefined;
} & {
    /**
     * #action
     */
    setLayout(layout: Source[]): void;
    /**
     * #action
     */
    clearLayout(): void;
    /**
     * #action
     */
    setSources(sources: Source[]): void;
    /**
     * #action
     */
    setFeatureUnderMouse(f?: Feature): void;
} & {
    /**
     * #getter
     */
    readonly featureUnderMouse: Feature | undefined;
    /**
     * #getter
     */
    readonly TooltipComponent: React.FC<{}>;
    /**
     * #getter
     */
    readonly rendererTypeName: string;
} & {
    /**
     * #getter
     */
    readonly needsScalebar: boolean;
    /**
     * #getter
     */
    readonly needsFullHeightScalebar: boolean;
    /**
     * #getter
     */
    readonly isMultiRow: boolean;
    /**
     * #getter
     * can be used to give it a "color scale" like a R heatmap, not
     * implemented like this yet but flag can be used for this
     */
    readonly needsCustomLegend: boolean;
    readonly canHaveFill: boolean;
    /**
     * #getter
     * the multirowxy and multiline don't need to use colors on the legend
     * boxes since their track is drawn with the color. sort of a stylistic
     * choice
     */
    readonly renderColorBoxes: boolean;
    /**
     * #getter
     * positions multi-row below the tracklabel even if using overlap
     * tracklabels for everything else
     */
    readonly prefersOffset: boolean;
    /**
     * #getter
     */
    readonly sources: {
        color: string;
        name: string;
        group?: string | undefined;
    }[] | undefined;
} & {
    /**
     * #getter
     */
    readonly rowHeight: number;
    /**
     * #getter
     */
    readonly rowHeightTooSmallForScalebar: boolean;
    /**
     * #getter
     */
    readonly useMinimalTicks: any;
} & {
    /**
     * #getter
     */
    readonly ticks: {
        range: number[];
        values: number[];
        format: (d: import("d3-scale").NumberValue) => string;
        position: import("d3-scale").ScaleLinear<number, number, never> | import("d3-scale").ScaleQuantize<number, never>;
    } | undefined;
    /**
     * #getter
     */
    readonly colors: string[];
} & {
    /**
     * #method
     */
    renderProps(): any;
    /**
     * #getter
     */
    readonly hasResolution: boolean;
    /**
     * #getter
     */
    readonly hasGlobalStats: boolean;
    /**
     * #getter
     */
    readonly fillSetting: 2 | 0 | 1;
} & {
    /**
     * #method
     */
    trackMenuItems(): (import("@jbrowse/core/ui").MenuDivider | import("@jbrowse/core/ui").MenuSubHeader | import("@jbrowse/core/ui").NormalMenuItem | import("@jbrowse/core/ui").CheckboxMenuItem | import("@jbrowse/core/ui").RadioMenuItem | import("@jbrowse/core/ui").SubMenuItem | {
        label: string;
        subMenu: ({
            label: string;
            subMenu: {
                label: string;
                onClick: () => void;
            }[];
            onClick?: undefined;
        } | {
            label: string;
            subMenu: {
                label: string;
                type: string;
                checked: boolean;
                onClick: () => void;
            }[];
            onClick?: undefined;
        } | {
            label: string;
            onClick: () => void;
            subMenu?: undefined;
        })[];
        type?: undefined;
        checked?: undefined;
        onClick?: undefined;
    } | {
        label: string;
        subMenu: {
            label: string;
            type: string;
            checked: boolean;
            onClick: () => void;
        }[];
        type?: undefined;
        checked?: undefined;
        onClick?: undefined;
    } | {
        type: string;
        label: string;
        checked: boolean;
        onClick: () => void;
        subMenu?: undefined;
    })[];
} & {
    afterAttach(): void;
    /**
     * #action
     */
    renderSvg(opts: ExportSvgDisplayOptions): Promise<React.JSX.Element>;
}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
export type WiggleDisplayStateModel = ReturnType<typeof stateModelFactory>;
export type WiggleDisplayModel = Instance<WiggleDisplayStateModel>;
export default stateModelFactory;
