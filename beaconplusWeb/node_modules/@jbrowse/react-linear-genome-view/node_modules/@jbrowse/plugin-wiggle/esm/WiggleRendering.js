import { observer } from 'mobx-react';
import React, { useRef } from 'react';
import { PrerenderedCanvas } from '@jbrowse/core/ui';
const WiggleRendering = observer(function (props) {
    const { regions, features, bpPerPx, width, height, onMouseLeave = () => { }, onMouseMove = () => { }, onFeatureClick = () => { }, } = props;
    const [region] = regions;
    const ref = useRef(null);
    function getFeatureUnderMouse(eventClientX) {
        // calculates feature under mouse
        let offset = 0;
        if (ref.current) {
            offset = ref.current.getBoundingClientRect().left;
        }
        const offsetX = eventClientX - offset;
        const px = region.reversed ? width - offsetX : offsetX;
        const clientBp = region.start + bpPerPx * px;
        let featureUnderMouse;
        for (const feature of features.values()) {
            // bpPerPx added to the end to accommodate "reduced features" (one feature per px)
            if (clientBp <= feature.get('end') + bpPerPx &&
                clientBp >= feature.get('start')) {
                featureUnderMouse = feature;
                break;
            }
        }
        return featureUnderMouse;
    }
    return (React.createElement("div", { ref: ref, "data-testid": "wiggle-rendering-test", onMouseMove: event => { var _a; return onMouseMove(event, (_a = getFeatureUnderMouse(event.clientX)) === null || _a === void 0 ? void 0 : _a.id()); }, onClick: event => { var _a; return onFeatureClick(event, (_a = getFeatureUnderMouse(event.clientX)) === null || _a === void 0 ? void 0 : _a.id()); }, onMouseLeave: event => onMouseLeave(event), style: {
            overflow: 'visible',
            position: 'relative',
            height,
        } },
        React.createElement(PrerenderedCanvas, { ...props })));
});
export default WiggleRendering;
