import { ConfigurationReference, getConf, } from '@jbrowse/core/configuration';
import { types } from 'mobx-state-tree';
import { getSession, isSessionModelWithWidgets, getContainingView, getContainingTrack, isSelectionContainer, } from '@jbrowse/core/util';
import { BaseDisplay } from '@jbrowse/core/pluggableElementTypes';
import { FeatureDensityMixin, TrackHeightMixin, } from '@jbrowse/plugin-linear-genome-view';
/**
 * #stateModel LinearPairedArcDisplay
 * this is a non-block-based track type, and can connect arcs across multiple
 * displayedRegions
 *
 * extends
 * - [BaseDisplay](../basedisplay)
 * - [TrackHeightMixin](../trackheightmixin)
 * - [FeatureDensityMixin](../featuredensitymixin)
 */
export function stateModelFactory(configSchema) {
    return types
        .compose('LinearPairedArcDisplay', BaseDisplay, TrackHeightMixin(), FeatureDensityMixin(), types.model({
        /**
         * #property
         */
        type: types.literal('LinearPairedArcDisplay'),
        /**
         * #property
         */
        configuration: ConfigurationReference(configSchema),
        /**
         * #property
         */
        displayMode: types.maybe(types.string),
    }))
        .volatile(() => ({
        lastDrawnOffsetPx: 0,
        features: undefined,
        loading: false,
        drawn: true,
    }))
        .views(self => ({
        /**
         * #getter
         */
        get displayModeSetting() {
            var _a;
            return (_a = self.displayMode) !== null && _a !== void 0 ? _a : getConf(self, ['renderer', 'displayMode']);
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        selectFeature(feature) {
            const session = getSession(self);
            if (isSessionModelWithWidgets(session)) {
                const featureWidget = session.addWidget('VariantFeatureWidget', 'variantFeature', {
                    view: getContainingView(self),
                    track: getContainingTrack(self),
                    featureData: feature.toJSON(),
                });
                session.showWidget(featureWidget);
            }
            if (isSelectionContainer(session)) {
                session.setSelection(feature);
            }
        },
        /**
         * #action
         */
        setLoading(flag) {
            self.loading = flag;
        },
        /**
         * #action
         */
        setFeatures(f) {
            self.features = f;
        },
        /**
         * #action
         */
        setDisplayMode(flag) {
            self.displayMode = flag;
        },
    }))
        .actions(self => ({
        afterAttach() {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            ;
            (async () => {
                try {
                    const { doAfterAttach } = await import('./afterAttach');
                    doAfterAttach(self);
                }
                catch (e) {
                    console.error(e);
                    self.setError(e);
                }
            })();
        },
        /**
         * #action
         */
        async renderSvg(opts) {
            const { renderArcSvg } = await import('./renderSvg');
            // @ts-expect-error
            return renderArcSvg(self, opts);
        },
    }));
}
