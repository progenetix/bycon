import { addDisposer, isAlive, types, } from 'mobx-state-tree';
import { localStorageGetItem, localStorageSetItem } from '@jbrowse/core/util';
import { autorun } from 'mobx';
import { isConfigurationModel, } from '@jbrowse/core/configuration';
import { isBaseSession } from './BaseSession';
const minDrawerWidth = 128;
/**
 * #stateModel DrawerWidgetSessionMixin
 */
export function DrawerWidgetSessionMixin(pluginManager) {
    const widgetStateModelType = pluginManager.pluggableMstType('widget', 'stateModel');
    return types
        .model({
        /**
         * #property
         */
        drawerPosition: types.optional(types.string, () => localStorageGetItem('drawerPosition') || 'right'),
        /**
         * #property
         */
        drawerWidth: types.optional(types.refinement(types.integer, width => width >= minDrawerWidth), 384),
        /**
         * #property
         */
        widgets: types.map(widgetStateModelType),
        /**
         * #property
         */
        activeWidgets: types.map(types.safeReference(widgetStateModelType)),
        /**
         * #property
         */
        minimized: types.optional(types.boolean, false),
    })
        .views(self => ({
        /**
         * #getter
         */
        get visibleWidget() {
            if (isAlive(self)) {
                // returns most recently added item in active widgets
                return [...self.activeWidgets.values()][self.activeWidgets.size - 1];
            }
            return undefined;
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        setDrawerPosition(arg) {
            self.drawerPosition = arg;
            localStorage.setItem('drawerPosition', arg);
        },
        /**
         * #action
         */
        updateDrawerWidth(drawerWidth) {
            if (drawerWidth === self.drawerWidth) {
                return self.drawerWidth;
            }
            let newDrawerWidth = drawerWidth;
            if (newDrawerWidth < minDrawerWidth) {
                newDrawerWidth = minDrawerWidth;
            }
            self.drawerWidth = newDrawerWidth;
            return newDrawerWidth;
        },
        /**
         * #action
         */
        resizeDrawer(distance) {
            if (self.drawerPosition === 'left') {
                distance *= -1;
            }
            const oldDrawerWidth = self.drawerWidth;
            const newDrawerWidth = this.updateDrawerWidth(oldDrawerWidth - distance);
            return oldDrawerWidth - newDrawerWidth;
        },
        /**
         * #action
         */
        addWidget(typeName, id, initialState = {}, conf) {
            const typeDefinition = pluginManager.getElementType('widget', typeName);
            if (!typeDefinition) {
                throw new Error(`unknown widget type ${typeName}`);
            }
            const data = {
                ...initialState,
                id,
                type: typeName,
                configuration: conf || { type: typeName },
            };
            self.widgets.set(id, data);
            return self.widgets.get(id);
        },
        /**
         * #action
         */
        showWidget(widget) {
            if (self.activeWidgets.has(widget.id)) {
                self.activeWidgets.delete(widget.id);
            }
            self.activeWidgets.set(widget.id, widget);
            self.minimized = false;
        },
        /**
         * #action
         */
        hasWidget(widget) {
            return self.activeWidgets.has(widget.id);
        },
        /**
         * #action
         */
        hideWidget(widget) {
            self.activeWidgets.delete(widget.id);
        },
        /**
         * #action
         */
        minimizeWidgetDrawer() {
            self.minimized = true;
        },
        /**
         * #action
         */
        showWidgetDrawer() {
            self.minimized = false;
        },
        /**
         * #action
         */
        hideAllWidgets() {
            self.activeWidgets.clear();
        },
        /**
         * #action
         * opens a configuration editor to configure the given thing,
         * and sets the current task to be configuring it
         * @param configuration -
         */
        editConfiguration(configuration) {
            if (!isConfigurationModel(configuration)) {
                throw new Error('must pass a configuration model to editConfiguration');
            }
            const editor = this.addWidget('ConfigurationEditorWidget', 'configEditor', { target: configuration });
            this.showWidget(editor);
        },
        afterAttach() {
            addDisposer(self, autorun(() => {
                localStorageSetItem('drawerPosition', self.drawerPosition);
            }));
        },
    }));
}
/** Type guard for SessionWithDrawerWidgets */
export function isSessionWithDrawerWidgets(session) {
    return (isBaseSession(session) &&
        'widgets' in session &&
        'drawerPosition' in session);
}
