import RpcServer from 'librpc-web-mod';
import PluginManager from '@jbrowse/core/PluginManager';
import { remoteAbortRpcHandler } from '@jbrowse/core/rpc/remoteAbortSignals';
import PluginLoader from '@jbrowse/core/PluginLoader';
import { serializeError } from 'serialize-error';
// waits for a message from the main thread containing our configuration, which
// must be sent on boot
function receiveConfiguration() {
    const configurationP = new Promise(resolve => {
        function listener(e) {
            if (e.data.message === 'config') {
                resolve(e.data.config);
                removeEventListener('message', listener);
            }
        }
        self.addEventListener('message', listener);
    });
    postMessage({ message: 'readyForConfig' });
    return configurationP;
}
async function getPluginManager(corePlugins, opts) {
    // Load runtime plugins
    const config = await receiveConfiguration();
    const pluginLoader = new PluginLoader(config.plugins, opts).installGlobalReExports(self);
    return new PluginManager([
        ...corePlugins.map(p => ({ plugin: p })),
        ...(await pluginLoader.load(config.windowHref)),
    ].map(P => new P.plugin()))
        .createPluggableElements()
        .configure();
}
function wrapForRpc(func) {
    return (args) => {
        const { channel, rpcDriverClassName } = args;
        return func({
            ...args,
            statusCallback: (message) => {
                // @ts-expect-error
                self.rpcServer.emit(channel, message);
            },
        }, rpcDriverClassName);
    };
}
export async function initializeWorker(corePlugins, opts) {
    try {
        const pluginManager = await getPluginManager(corePlugins, opts);
        const rpcConfig = Object.fromEntries(pluginManager
            .getRpcElements()
            .map(e => [e.name, wrapForRpc(e.execute.bind(e))]));
        // @ts-expect-error
        self.rpcServer = new RpcServer.Server({
            ...rpcConfig,
            ...remoteAbortRpcHandler(),
            ping: async () => {
                // the ping method is required by the worker driver for checking the
                // health of the worker
            },
        });
        postMessage({ message: 'ready' });
    }
    catch (e) {
        postMessage({ message: 'error', error: serializeError(e) });
    }
    /* do nothing */
}
