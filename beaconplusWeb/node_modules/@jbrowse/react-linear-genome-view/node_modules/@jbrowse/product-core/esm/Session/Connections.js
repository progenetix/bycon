import { readConfObject, } from '@jbrowse/core/configuration';
import { types } from 'mobx-state-tree';
import { isBaseSession } from './BaseSession';
/**
 * #stateModel ConnectionManagementSessionMixin
 */
export function ConnectionManagementSessionMixin(pluginManager) {
    return types
        .model({
        /**
         * #property
         */
        connectionInstances: types.array(pluginManager.pluggableMstType('connection', 'stateModel')),
    })
        .views(self => ({
        /**
         * #getter
         */
        get connections() {
            const { jbrowse } = self;
            return jbrowse.connections;
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        makeConnection(configuration, initialSnapshot = {}) {
            const type = configuration.type;
            if (!type) {
                throw new Error('track configuration has no `type` listed');
            }
            const name = readConfObject(configuration, 'name');
            const connectionType = pluginManager.getConnectionType(type);
            if (!connectionType) {
                throw new Error(`unknown connection type ${type}`);
            }
            const length = self.connectionInstances.push({
                ...initialSnapshot,
                name,
                // @ts-expect-error unsure why ts doesn't like `type` here, but is
                // needed
                type,
                configuration,
            });
            return self.connectionInstances[length - 1];
        },
        /**
         * #action
         */
        prepareToBreakConnection(configuration) {
            const root = self;
            const callbacksToDeref = [];
            const derefTypeCount = {};
            const name = readConfObject(configuration, 'name');
            const connection = self.connectionInstances.find(c => c.name === name);
            if (!connection) {
                return undefined;
            }
            for (const track of connection.tracks) {
                const ref = root.getReferring(track);
                root.removeReferring(ref, track, callbacksToDeref, derefTypeCount);
            }
            return [
                () => {
                    callbacksToDeref.forEach(cb => cb());
                    this.breakConnection(configuration);
                },
                derefTypeCount,
            ];
        },
        /**
         * #action
         */
        breakConnection(configuration) {
            const name = readConfObject(configuration, 'name');
            const connection = self.connectionInstances.find(c => c.name === name);
            if (!connection) {
                throw new Error(`no connection found with name ${name}`);
            }
            self.connectionInstances.remove(connection);
        },
        /**
         * #action
         */
        deleteConnection(configuration) {
            const { jbrowse } = self;
            return jbrowse.deleteConnectionConf(configuration);
        },
        /**
         * #action
         */
        addConnectionConf(connectionConf) {
            const { jbrowse } = self;
            return jbrowse.addConnectionConf(connectionConf);
        },
        /**
         * #action
         */
        clearConnections() {
            self.connectionInstances.clear();
        },
    }));
}
/** Type guard for SessionWithConnections */
export function isSessionWithConnections(session) {
    return isBaseSession(session) && 'connectionInstances' in session;
}
