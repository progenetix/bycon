import { types, cast, getEnv, getSnapshot, isAlive } from 'mobx-state-tree';
import { observable } from 'mobx';
import { getConf, readConfObject, } from '@jbrowse/core/configuration';
import { linearWiggleDisplayModelFactory } from '@jbrowse/plugin-wiggle';
import { getContainingView } from '@jbrowse/core/util';
import SerializableFilterChain from '@jbrowse/core/pluggableElementTypes/renderers/util/serializableFilterChain';
// locals
import Tooltip from '../components/Tooltip';
import { FilterModel, getUniqueModificationValues } from '../../shared';
import { createAutorun, modificationColors } from '../../util';
import { randomColor } from '../../util';
// using a map because it preserves order
const rendererTypes = new Map([['snpcoverage', 'SNPCoverageRenderer']]);
/**
 * #stateModel LinearSNPCoverageDisplay
 * extends
 * - [LinearWiggleDisplay](../linearwiggledisplay)
 */
function stateModelFactory(pluginManager, configSchema) {
    return types
        .compose('LinearSNPCoverageDisplay', linearWiggleDisplayModelFactory(pluginManager, configSchema), types.model({
        /**
         * #property
         */
        type: types.literal('LinearSNPCoverageDisplay'),
        /**
         * #property
         */
        drawInterbaseCounts: types.maybe(types.boolean),
        /**
         * #property
         */
        drawIndicators: types.maybe(types.boolean),
        /**
         * #property
         */
        drawArcs: types.maybe(types.boolean),
        /**
         * #property
         */
        filterBy: types.optional(FilterModel, {}),
        /**
         * #property
         */
        colorBy: types.maybe(types.model({
            type: types.string,
            tag: types.maybe(types.string),
        })),
        /**
         * #property
         */
        jexlFilters: types.optional(types.array(types.string), []),
    }))
        .volatile(() => ({
        modificationTagMap: observable.map({}),
        modificationsReady: false,
    }))
        .actions(self => ({
        /**
         * #action
         */
        setConfig(configuration) {
            self.configuration = configuration;
        },
        /**
         * #action
         */
        setFilterBy(filter) {
            self.filterBy = cast(filter);
        },
        /**
         * #action
         */
        setColorBy(colorBy) {
            self.colorBy = cast(colorBy);
        },
        /**
         * #action
         */
        setJexlFilters(filters) {
            self.jexlFilters = cast(filters);
        },
        /**
         * #action
         */
        updateModificationColorMap(uniqueModifications) {
            uniqueModifications.forEach(value => {
                if (!self.modificationTagMap.has(value)) {
                    self.modificationTagMap.set(value, modificationColors[value] || randomColor());
                }
            });
        },
    }))
        .views(self => {
        const { renderProps: superRenderProps } = self;
        return {
            /**
             * #getter
             */
            get rendererConfig() {
                var _a, _b, _c;
                const configBlob = getConf(self, ['renderers', self.rendererTypeName]) || {};
                return self.rendererType.configSchema.create({
                    ...configBlob,
                    drawInterbaseCounts: (_a = self.drawInterbaseCounts) !== null && _a !== void 0 ? _a : configBlob.drawInterbaseCounts,
                    drawIndicators: (_b = self.drawIndicators) !== null && _b !== void 0 ? _b : configBlob.drawIndicators,
                    drawArcs: (_c = self.drawArcs) !== null && _c !== void 0 ? _c : configBlob.drawArcs,
                }, getEnv(self));
            },
            /**
             * #getter
             */
            get drawArcsSetting() {
                var _a;
                return ((_a = self.drawArcs) !== null && _a !== void 0 ? _a : readConfObject(this.rendererConfig, 'drawArcs'));
            },
            /**
             * #getter
             */
            get drawInterbaseCountsSetting() {
                var _a;
                return ((_a = self.drawInterbaseCounts) !== null && _a !== void 0 ? _a : readConfObject(this.rendererConfig, 'drawInterbaseCounts'));
            },
            /**
             * #getter
             */
            get drawIndicatorsSetting() {
                var _a;
                return ((_a = self.drawIndicators) !== null && _a !== void 0 ? _a : readConfObject(this.rendererConfig, 'drawIndicators'));
            },
            /**
             * #getter
             */
            get autorunReady() {
                const view = getContainingView(self);
                return (view.initialized &&
                    self.featureDensityStatsReady &&
                    !self.regionTooLarge &&
                    !self.error);
            },
            get renderReady() {
                const superProps = superRenderProps();
                return !superProps.notReady && self.modificationsReady;
            },
            get ready() {
                return this.renderReady;
            },
            /**
             * #method
             */
            renderProps() {
                const superProps = superRenderProps();
                const { colorBy, filterBy, modificationTagMap } = self;
                return {
                    ...superProps,
                    notReady: !this.ready,
                    filters: self.filters,
                    modificationTagMap: Object.fromEntries(modificationTagMap.toJSON()),
                    // must use getSnapshot because otherwise changes to e.g. just the
                    // colorBy.type are not read
                    colorBy: colorBy ? getSnapshot(colorBy) : undefined,
                    filterBy: filterBy ? getSnapshot(filterBy) : undefined,
                };
            },
        };
    })
        .actions(self => ({
        /**
         * #action
         */
        setModificationsReady(flag) {
            self.modificationsReady = flag;
        },
        /**
         * #action
         */
        toggleDrawIndicators() {
            self.drawIndicators = !self.drawIndicatorsSetting;
        },
        /**
         * #action
         */
        toggleDrawInterbaseCounts() {
            self.drawInterbaseCounts = !self.drawInterbaseCountsSetting;
        },
        /**
         * #action
         */
        toggleDrawArcs() {
            self.drawArcs = !self.drawArcsSetting;
        },
    }))
        .actions(self => ({
        afterAttach() {
            createAutorun(self, async () => {
                self.setModificationsReady(false);
                if (!self.autorunReady) {
                    return;
                }
                const view = getContainingView(self);
                const { staticBlocks } = view;
                const { colorBy } = self;
                if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'modifications') {
                    const adapter = getConf(self.parentTrack, 'adapter');
                    const vals = await getUniqueModificationValues(self, adapter, colorBy, staticBlocks);
                    if (isAlive(self)) {
                        self.updateModificationColorMap(vals);
                        self.setModificationsReady(true);
                    }
                }
                else {
                    self.setModificationsReady(true);
                }
            }, { delay: 1000 });
        },
    }))
        .views(self => {
        const { trackMenuItems: superTrackMenuItems } = self;
        return {
            /**
             * #getter
             */
            get TooltipComponent() {
                return Tooltip;
            },
            /**
             * #getter
             */
            get adapterConfig() {
                const subadapter = getConf(self.parentTrack, 'adapter');
                return {
                    type: 'SNPCoverageAdapter',
                    subadapter,
                };
            },
            /**
             * #getter
             */
            get rendererTypeName() {
                return rendererTypes.get('snpcoverage');
            },
            /**
             * #getter
             */
            get needsScalebar() {
                return true;
            },
            /**
             * #method
             */
            contextMenuItems() {
                return [];
            },
            /**
             * #method
             */
            trackMenuItems() {
                return [
                    ...superTrackMenuItems(),
                    {
                        label: 'Draw insertion/clipping indicators',
                        type: 'checkbox',
                        checked: self.drawIndicatorsSetting,
                        onClick: () => self.toggleDrawIndicators(),
                    },
                    {
                        label: 'Draw insertion/clipping counts',
                        type: 'checkbox',
                        checked: self.drawInterbaseCountsSetting,
                        onClick: () => self.toggleDrawInterbaseCounts(),
                    },
                    {
                        label: 'Draw arcs',
                        type: 'checkbox',
                        checked: self.drawArcsSetting,
                        onClick: () => self.toggleDrawArcs(),
                    },
                ];
            },
            /**
             * #getter
             */
            get filters() {
                return new SerializableFilterChain({ filters: self.jexlFilters });
            },
        };
    });
}
export default stateModelFactory;
