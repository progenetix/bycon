import React from 'react';
import { Instance } from 'mobx-state-tree';
import { AnyConfigurationSchemaType } from '@jbrowse/core/configuration';
import { IFilter } from '../shared';
import { ChainData } from '../shared/fetchChains';
/**
 * #stateModel LinearReadArcsDisplay
 * the arc display is a non-block-based track, so draws to a single canvas and
 * can connect multiple regions
 * extends
 * - [BaseDisplay](../basedisplay)
 * - [TrackHeightMixin](../trackheightmixin)
 * - [FeatureDensityMixin](../featuredensitymixin)
 */
declare function stateModelFactory(configSchema: AnyConfigurationSchemaType): import("mobx-state-tree").IModelType<{
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    type: import("mobx-state-tree").ISimpleType<string>;
    rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
} & {
    heightPreConfig: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
} & {
    userBpPerPxLimit: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
    userByteSizeLimit: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
} & {
    type: import("mobx-state-tree").ISimpleType<"LinearReadArcsDisplay">;
    configuration: AnyConfigurationSchemaType;
    filterBy: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").IModelType<{
        flagInclude: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<number>, [undefined]>;
        flagExclude: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<number>, [undefined]>;
        readName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
        tagFilter: import("mobx-state-tree").IMaybe<import("mobx-state-tree").IModelType<{
            tag: import("mobx-state-tree").ISimpleType<string>;
            value: import("mobx-state-tree").ISimpleType<string>; /**
             * #property
             */
        }, {}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
    }, {}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>, [undefined]>;
    lineWidth: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
    jitter: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<number>>;
    colorBy: import("mobx-state-tree").IMaybe<import("mobx-state-tree").IModelType<{
        type: import("mobx-state-tree").ISimpleType<string>;
        tag: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
        extra: import("mobx-state-tree").IType<any, any, any>;
    }, {}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
    drawInter: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    drawLongRange: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
}, {
    rendererTypeName: string;
    error: unknown;
    message: string | undefined;
} & {
    readonly RenderingComponent: React.FC<{
        model: {
            id: string;
            type: string;
            rpcDriverName: string | undefined;
        } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
            rendererTypeName: string;
            error: unknown;
            message: string | undefined;
        } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
            id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
            type: import("mobx-state-tree").ISimpleType<string>;
            rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>; /**
             * #property
             */
        }, {
            rendererTypeName: string;
            error: unknown;
            message: string | undefined;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
        onHorizontalScroll?: Function | undefined;
        blockState?: Record<string, any> | undefined;
    }>;
    readonly DisplayBlurb: React.FC<{
        model: {
            id: string;
            type: string;
            rpcDriverName: string | undefined;
        } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
            rendererTypeName: string;
            error: unknown;
            message: string | undefined;
        } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
            id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>; /**
             * #action
             */
            type: import("mobx-state-tree").ISimpleType<string>;
            rpcDriverName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
        }, {
            rendererTypeName: string;
            error: unknown;
            message: string | undefined;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
    }> | null;
    readonly adapterConfig: any;
    readonly parentTrack: any;
    renderProps(): any;
    readonly rendererType: import("@jbrowse/core/pluggableElementTypes").RendererType;
    readonly DisplayMessageComponent: React.FC<any> | undefined;
    trackMenuItems(): import("@jbrowse/core/ui").MenuItem[];
    readonly viewMenuActions: import("@jbrowse/core/ui").MenuItem[];
    regionCannotBeRendered(): null;
} & {
    setMessage(arg?: string | undefined): void;
    setError(error?: unknown): void; /**
     * #getter
     */
    setRpcDriverName(rpcDriverName: string): void;
    reload(): void;
} & {
    scrollTop: number;
} & {
    readonly height: number;
} & {
    setScrollTop(scrollTop: number): void;
    setHeight(displayHeight: number): number;
    resizeHeight(distance: number): number;
} & {
    featureDensityStatsP: Promise<import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats> | undefined;
    featureDensityStats: import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats | undefined;
    currStatsBpPerPx: number;
} & {
    readonly currentBytesRequested: number;
    readonly currentFeatureScreenDensity: number; /**
     * #property
     */
    readonly maxFeatureScreenDensity: any;
    readonly featureDensityStatsReady: boolean;
    readonly maxAllowableBytes: number;
} & {
    afterAttach(): void;
} & {
    setCurrStatsBpPerPx(n: number): void;
    setFeatureDensityStatsLimit(stats?: import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats | undefined): void;
    getFeatureDensityStats(): Promise<import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats>;
    setFeatureDensityStatsP(arg: any): void;
    setFeatureDensityStats(featureDensityStats?: import("@jbrowse/core/data_adapters/BaseAdapter").FeatureDensityStats | undefined): void;
    clearFeatureDensityStats(): void;
} & {
    readonly regionTooLarge: boolean;
    readonly regionTooLargeReason: string;
} & {
    regionCannotBeRenderedText(_region: import("@jbrowse/core/util").Region): "" | "Force load to see features";
    regionCannotBeRendered(_region: import("@jbrowse/core/util").Region): React.JSX.Element | null;
} & {
    loading: boolean;
    chainData: ChainData | undefined;
    lastDrawnOffsetPx: number | undefined;
    lastDrawnBpPerPx: number;
    ref: HTMLCanvasElement | null;
} & {
    /**
     * #action
     */
    setLastDrawnOffsetPx(n: number): void;
    /**
     * #action
     */
    setLastDrawnBpPerPx(n: number): void;
    /**
     * #action
     */
    setLoading(f: boolean): void;
    /**
     * #action
     */
    reload(): void;
    /**
     * #action
     * internal, a reference to a HTMLCanvas because we use a autorun to draw
     * the canvas
     */
    setRef(ref: HTMLCanvasElement | null): void;
    /**
     * #action
     */
    setColorScheme(s: {
        type: string;
    }): void;
    /**
     * #action
     */
    setChainData(args: ChainData): void;
    /**
     * #action
     */
    setDrawInter(f: boolean): void;
    /**
     * #action
     */
    setDrawLongRange(f: boolean): void;
    /**
     * #action
     */
    setFilterBy(filter: IFilter): void;
    /**
     * #action
     * thin, bold, extrabold, etc
     */
    setLineWidth(n: number): void;
    /**
     * #action
     * jitter val, helpful to jitter the x direction so you see better
     * evidence when e.g. 100 long reads map to same x position
     */
    setJitter(n: number): void;
} & {
    /**
     * #getter
     */
    readonly drawn: boolean;
    /**
     * #getter
     */
    readonly lineWidthSetting: any;
    /**
     * #getter
     */
    readonly jitterVal: number;
} & {
    /**
     * #method
     * only used to tell system it's ready for export
     */
    renderProps(): any;
    /**
     * #method
     */
    trackMenuItems(): (import("@jbrowse/core/ui").MenuDivider | import("@jbrowse/core/ui").MenuSubHeader | import("@jbrowse/core/ui").NormalMenuItem | import("@jbrowse/core/ui").CheckboxMenuItem | import("@jbrowse/core/ui").RadioMenuItem | import("@jbrowse/core/ui").SubMenuItem | {
        label: string;
        icon: import("@mui/material/OverridableComponent").OverridableComponent<import("@mui/material").SvgIconTypeMap<{}, "svg">> & {
            muiName: string;
        };
        onClick: () => void;
        subMenu?: undefined;
        type?: undefined;
        checked?: undefined;
    } | {
        label: string;
        subMenu: {
            type: string;
            checked: boolean;
            label: string;
            onClick: () => void;
        }[];
        icon?: undefined;
        onClick?: undefined;
        type?: undefined;
        checked?: undefined;
    } | {
        label: string;
        type: string;
        checked: boolean;
        onClick: () => void;
        icon?: undefined;
        subMenu?: undefined;
    } | {
        label: string;
        icon: import("@mui/material/OverridableComponent").OverridableComponent<import("@mui/material").SvgIconTypeMap<{}, "svg">> & {
            muiName: string;
        };
        subMenu: {
            label: string;
            onClick: () => void;
        }[];
        onClick?: undefined;
        type?: undefined;
        checked?: undefined;
    })[];
} & {
    /**
     * #method
     */
    renderSvg(opts: {
        rasterizeLayers?: boolean;
    }): Promise<React.ReactNode>;
} & {
    afterAttach(): void;
}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
export type LinearReadArcsDisplayStateModel = ReturnType<typeof stateModelFactory>;
export type LinearReadArcsDisplayModel = Instance<LinearReadArcsDisplayStateModel>;
export default stateModelFactory;
