import { getConf } from '@jbrowse/core/configuration';
import { max, min } from '@jbrowse/core/util';
import { fillRectCtx, strokeRectCtx } from './util';
import { getPairedInsertSizeAndOrientationColor, getPairedInsertSizeColor, getPairedOrientationColor, } from '../shared/color';
export function drawPairChains({ ctx, self, chainData, view, asm, }) {
    var _a, _b, _c, _d, _e, _f, _g;
    const coords = [];
    const featureHeight = getConf(self, 'featureHeight');
    const type = ((_a = self.colorBy) === null || _a === void 0 ? void 0 : _a.type) || 'insertSizeAndOrientation';
    const { chains, stats } = chainData;
    for (const chain of chains) {
        // if we're looking at a paired read (flag 1) then assume it is just
        // two reads (some small cases may defy this assumption such as
        // secondary alignments but this may be uncommon)
        if (chain.length > 1) {
            const v0 = chain[0];
            const v1 = chain[1];
            const ra1 = asm.getCanonicalRefName(v0.refName) || v0.refName;
            const ra2 = asm.getCanonicalRefName(v1.refName) || v1.refName;
            const r1s = (_b = view.bpToPx({ refName: ra1, coord: v0.start })) === null || _b === void 0 ? void 0 : _b.offsetPx;
            const r1e = (_c = view.bpToPx({ refName: ra1, coord: v0.end })) === null || _c === void 0 ? void 0 : _c.offsetPx;
            const r2s = (_d = view.bpToPx({ refName: ra2, coord: v1.start })) === null || _d === void 0 ? void 0 : _d.offsetPx;
            const r2e = (_e = view.bpToPx({ refName: ra2, coord: v1.end })) === null || _e === void 0 ? void 0 : _e.offsetPx;
            let distance = 0;
            if (r1s !== undefined &&
                r1e !== undefined &&
                r2s !== undefined &&
                r2e !== undefined) {
                if (v0.refName === v1.refName) {
                    const s = Math.min(v0.start, v1.start);
                    const e = Math.max(v0.end, v1.end);
                    distance = Math.abs(e - s);
                }
                coords.push({
                    r1s,
                    r1e,
                    r2s,
                    r2e,
                    v0,
                    v1,
                    distance,
                });
            }
        }
        else if (self.drawSingletons) {
            const v0 = chain[0];
            const ra1 = asm.getCanonicalRefName(v0.refName) || v0.refName;
            const r1s = (_f = view.bpToPx({ refName: ra1, coord: v0.start })) === null || _f === void 0 ? void 0 : _f.offsetPx;
            const r1e = (_g = view.bpToPx({ refName: ra1, coord: v0.end })) === null || _g === void 0 ? void 0 : _g.offsetPx;
            if (r1s !== undefined && r1e !== undefined) {
                const w1 = Math.max(r1e - r1s, 2);
                fillRectCtx(r1s - view.offsetPx, 0, w1, featureHeight, ctx, '#f00');
                strokeRectCtx(r1s - view.offsetPx, 0, w1, featureHeight, ctx, '#a00');
            }
        }
    }
    const maxD = Math.log(max(coords.map(c => c.distance)));
    const minD = Math.max(Math.log(min(coords.map(c => c.distance))) - 1, 0);
    const scaler = (self.height - 20) / (maxD - minD);
    for (const { r1e, r1s, r2e, r2s, distance, v0, v1 } of coords) {
        const w1 = Math.max(r1e - r1s, 2);
        const w2 = Math.max(r2e - r2s, 2);
        const [fill, stroke] = getPairedColor({ type, v0, v1, stats }) || [];
        const top = (Math.log(distance) - minD) * scaler;
        const halfHeight = featureHeight / 2 - 0.5;
        const w = r2s - r1e;
        fillRectCtx(r1e - view.offsetPx, top + halfHeight, w, 1, ctx, 'black');
        strokeRectCtx(r1s - view.offsetPx, top, w1, featureHeight, ctx, stroke);
        strokeRectCtx(r2s - view.offsetPx, top, w2, featureHeight, ctx, stroke);
        fillRectCtx(r1s - view.offsetPx, top, w1, featureHeight, ctx, fill);
        fillRectCtx(r2s - view.offsetPx, top, w2, featureHeight, ctx, fill);
    }
}
export function getPairedColor({ type, v0, v1, stats, }) {
    if (type === 'insertSizeAndOrientation') {
        return getPairedInsertSizeAndOrientationColor(v0, v1, stats);
    }
    else if (type === 'orientation') {
        return getPairedOrientationColor(v0);
    }
    else if (type === 'insertSize') {
        return getPairedInsertSizeColor(v0, v1, stats);
    }
    else if (type === 'gradient') {
        const s = Math.min(v0.start, v1.start);
        const e = Math.max(v0.end, v1.end);
        return [
            `hsl(${Math.log10(Math.abs(e - s)) * 10},50%,50%)`,
            `hsl(${Math.log10(Math.abs(e - s)) * 10},50%,30%)`,
        ];
    }
    return undefined;
}
