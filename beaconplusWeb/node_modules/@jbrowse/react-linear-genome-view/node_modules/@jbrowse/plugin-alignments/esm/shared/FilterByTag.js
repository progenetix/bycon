import React, { useState } from 'react';
import { observer } from 'mobx-react';
import { Button, DialogActions, DialogContent, Link, Paper, TextField, Typography, } from '@mui/material';
import { Dialog } from '@jbrowse/core/ui';
import { makeStyles } from 'tss-react/mui';
const useStyles = makeStyles()(theme => ({
    paper: {
        padding: theme.spacing(2),
        margin: theme.spacing(2),
    },
    field: {
        margin: theme.spacing(2),
    },
}));
const flagNames = [
    'read paired',
    'read mapped in proper pair',
    'read unmapped',
    'mate unmapped',
    'read reverse strand',
    'mate reverse strand',
    'first in pair',
    'second in pair',
    'not primary alignment',
    'read fails platform/vendor quality checks',
    'read is PCR or optical duplicate',
    'supplementary alignment',
];
function Bitmask(props) {
    const { flag = 0, setFlag } = props;
    return (React.createElement(React.Fragment, null,
        React.createElement(TextField, { type: "number", value: flag, onChange: event => setFlag(+event.target.value) }),
        flagNames.map((name, index) => {
            const val = flag & (1 << index);
            const key = `${name}_${val}`;
            return (React.createElement("div", { key: key },
                React.createElement("input", { type: "checkbox", checked: Boolean(val), onChange: event => {
                        if (event.target.checked) {
                            setFlag(flag | (1 << index));
                        }
                        else {
                            setFlag(flag & ~(1 << index));
                        }
                    } }),
                React.createElement("label", { htmlFor: key }, name)));
        })));
}
const FilterByTagDialog = observer(function (props) {
    var _a, _b;
    const { model, handleClose } = props;
    const { classes } = useStyles();
    const { filterBy } = model;
    const [flagInclude, setFlagInclude] = useState(filterBy.flagInclude);
    const [flagExclude, setFlagExclude] = useState(filterBy.flagExclude);
    const [tag, setTag] = useState(((_a = filterBy.tagFilter) === null || _a === void 0 ? void 0 : _a.tag) || '');
    const [tagValue, setTagValue] = useState(((_b = filterBy.tagFilter) === null || _b === void 0 ? void 0 : _b.value) || '');
    const [readName, setReadName] = useState(filterBy.readName || '');
    const validTag = tag.match(/^[A-Za-z][A-Za-z0-9]$/);
    const site = 'https://broadinstitute.github.io/picard/explain-flags.html';
    return (React.createElement(Dialog, { open: true, onClose: handleClose, title: "Filter options" },
        React.createElement(DialogContent, null,
            React.createElement(Typography, null,
                "Set filter bitmask options. Refer to ",
                React.createElement(Link, { href: site }, site),
                ' ',
                "for details"),
            React.createElement(Paper, { className: classes.paper, variant: "outlined" },
                React.createElement("div", { style: { display: 'flex' } },
                    React.createElement("div", null,
                        React.createElement(Typography, null, "Read must have ALL these flags"),
                        React.createElement(Bitmask, { flag: flagInclude, setFlag: setFlagInclude })),
                    React.createElement("div", null,
                        React.createElement(Typography, null, "Read must have NONE of these flags"),
                        React.createElement(Bitmask, { flag: flagExclude, setFlag: setFlagExclude })))),
            React.createElement(Paper, { className: classes.paper, variant: "outlined" },
                React.createElement(Typography, null, "Filter by tag name and value. Use * in the value field to get all reads containing any value for that tag. Example: filter tag name SA with value * to get all split/supplementary reads. Other examples include HP for haplotype, or RG for read group"),
                React.createElement(TextField, { className: classes.field, value: tag, onChange: event => setTag(event.target.value), placeholder: "Enter tag name", inputProps: { maxLength: 2 }, error: tag.length === 2 && !validTag, helperText: tag.length === 2 && !validTag ? 'Not a valid tag' : '' }),
                React.createElement(TextField, { className: classes.field, value: tagValue, onChange: event => setTagValue(event.target.value), placeholder: "Enter tag value" })),
            React.createElement(Paper, { className: classes.paper, variant: "outlined" },
                React.createElement(Typography, null, "Filter by read name"),
                React.createElement(TextField, { className: classes.field, value: readName, onChange: event => setReadName(event.target.value), placeholder: "Enter read name" })),
            React.createElement(DialogActions, null,
                React.createElement(Button, { variant: "contained", color: "primary", autoFocus: true, type: "submit", onClick: () => {
                        model.setFilterBy({
                            flagInclude,
                            flagExclude,
                            readName,
                            tagFilter: tag !== ''
                                ? {
                                    tag,
                                    value: tagValue,
                                }
                                : undefined,
                        });
                        handleClose();
                    } }, "Submit"),
                React.createElement(Button, { variant: "contained", color: "secondary", onClick: () => handleClose() }, "Cancel")))));
});
export default FilterByTagDialog;
