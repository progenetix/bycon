import React from 'react';
import { autorun, when } from 'mobx';
import { addDisposer, getSnapshot, isAlive, types, } from 'mobx-state-tree';
import deepEqual from 'fast-deep-equal';
// jbrowse
import { getConf, } from '@jbrowse/core/configuration';
import { BaseDisplay } from '@jbrowse/core/pluggableElementTypes/models';
// locals
import { LinearAlignmentsDisplayMixin } from './alignmentsModel';
import { getLowerPanelDisplays } from './util';
const minDisplayHeight = 20;
function deepSnap(x1, x2) {
    return deepEqual(x1 ? getSnapshot(x1) : undefined, x2 ? getSnapshot(x2) : undefined);
}
function preCheck(self) {
    const { PileupDisplay, SNPCoverageDisplay } = self;
    return (PileupDisplay ||
        isAlive(PileupDisplay) ||
        SNPCoverageDisplay ||
        isAlive(SNPCoverageDisplay));
}
function propagateColorBy(self) {
    const { PileupDisplay, SNPCoverageDisplay } = self;
    if (!preCheck(self) || !PileupDisplay.colorBy) {
        return;
    }
    if (!deepSnap(PileupDisplay.colorBy, SNPCoverageDisplay.colorBy)) {
        SNPCoverageDisplay.setColorBy(getSnapshot(PileupDisplay.colorBy));
    }
}
function propagateFilterBy(self) {
    const { PileupDisplay, SNPCoverageDisplay } = self;
    if (!preCheck(self) || !PileupDisplay.filterBy) {
        return;
    }
    if (!deepSnap(PileupDisplay.filterBy, SNPCoverageDisplay.filterBy)) {
        SNPCoverageDisplay.setFilterBy(getSnapshot(PileupDisplay.filterBy));
    }
}
/**
 * #stateModel LinearAlignmentsDisplay
 * extends
 * - [BaseDisplay](../basedisplay)
 * - [LinearAlignmentsDisplayMixin](../linearalignmentsdisplaymixin)
 */
function stateModelFactory(pluginManager, configSchema) {
    return types
        .compose('LinearAlignmentsDisplay', BaseDisplay, LinearAlignmentsDisplayMixin(pluginManager, configSchema))
        .volatile(() => ({
        scrollTop: 0,
    }))
        .actions(self => ({
        /**
         * #action
         */
        setScrollTop(scrollTop) {
            self.scrollTop = scrollTop;
        },
        /**
         * #action
         */
        setSNPCoverageHeight(n) {
            self.snpCovHeight = n;
        },
    }))
        .views(self => ({
        /**
         * #getter
         */
        get height() {
            var _a;
            return (_a = self.heightPreConfig) !== null && _a !== void 0 ? _a : getConf(self, 'height');
        },
        /**
         * #getter
         */
        get featureIdUnderMouse() {
            return (self.PileupDisplay.featureIdUnderMouse ||
                self.SNPCoverageDisplay.featureIdUnderMouse);
        },
    }))
        .views(self => ({
        /**
         * #getter
         */
        get pileupConf() {
            const conf = getConf(self, 'pileupDisplay');
            return {
                ...conf,
                type: self.lowerPanelType,
                displayId: `${self.configuration.displayId}_${self.lowerPanelType}_xyz`, // xyz to avoid someone accidentally naming the displayId similar to this
            };
        },
        /**
         * #method
         */
        getFeatureByID(blockKey, id) {
            return self.PileupDisplay.getFeatureByID(blockKey, id);
        },
        /**
         * #method
         */
        searchFeatureByID(id) {
            var _a, _b;
            return (_b = (_a = self.PileupDisplay).searchFeatureByID) === null || _b === void 0 ? void 0 : _b.call(_a, id);
        },
        /**
         * #getter
         */
        get features() {
            return self.PileupDisplay.features;
        },
        /**
         * #getter
         */
        get DisplayBlurb() {
            var _a;
            return (_a = self.PileupDisplay) === null || _a === void 0 ? void 0 : _a.DisplayBlurb;
        },
        /**
         * #getter
         */
        get sortedBy() {
            return self.PileupDisplay.sortedBy;
        },
        /**
         * #getter
         */
        get coverageConf() {
            const conf = getConf(self, 'snpCoverageDisplay');
            return {
                ...conf,
                displayId: `${self.configuration.displayId}_snpcoverage_xyz`, // xyz to avoid someone accidentally naming the displayId similar to this
            };
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        setSNPCoverageDisplay(configuration) {
            self.SNPCoverageDisplay = {
                type: 'LinearSNPCoverageDisplay',
                configuration,
                height: self.snpCovHeight,
            };
        },
        /**
         * #action
         */
        setFeatureDensityStatsLimit(stats) {
            self.PileupDisplay.setFeatureDensityStatsLimit(stats);
            self.SNPCoverageDisplay.setFeatureDensityStatsLimit(stats);
        },
        /**
         * #action
         */
        setPileupDisplay(configuration) {
            self.PileupDisplay = {
                type: configuration.type || 'LinearPileupDisplay',
                configuration,
            };
        },
        /**
         * #action
         */
        setHeight(n) {
            self.heightPreConfig = Math.max(n, minDisplayHeight);
            return self.heightPreConfig;
        },
        /**
         * #action
         */
        setLowerPanelType(type) {
            self.lowerPanelType = type;
        },
        /**
         * #action
         */
        resizeHeight(distance) {
            const oldHeight = self.height;
            const newHeight = this.setHeight(self.height + distance);
            return newHeight - oldHeight;
        },
    }))
        .actions(self => ({
        afterAttach() {
            addDisposer(self, autorun(() => {
                const { SNPCoverageDisplay, PileupDisplay, coverageConf, pileupConf, } = self;
                if (!SNPCoverageDisplay) {
                    self.setSNPCoverageDisplay(coverageConf);
                }
                else if (!deepEqual(coverageConf, getSnapshot(SNPCoverageDisplay.configuration))) {
                    SNPCoverageDisplay.setHeight(self.snpCovHeight);
                    SNPCoverageDisplay.setConfig(self.coverageConf);
                }
                if (!PileupDisplay || self.lowerPanelType !== PileupDisplay.type) {
                    self.setPileupDisplay(pileupConf);
                }
                else if (!deepEqual(pileupConf, getSnapshot(PileupDisplay.configuration))) {
                    PileupDisplay.setConfig(self.pileupConf);
                }
                propagateColorBy(self);
                propagateFilterBy(self);
            }));
            addDisposer(self, autorun(() => {
                self.setSNPCoverageHeight(self.SNPCoverageDisplay.height);
            }));
            addDisposer(self, autorun(() => {
                self.PileupDisplay.setHeight(self.height - self.SNPCoverageDisplay.height);
            }));
        },
        /**
         * #action
         */
        async renderSvg(opts) {
            const pileupHeight = self.height - self.SNPCoverageDisplay.height;
            await when(() => !self.PileupDisplay.renderProps().notReady &&
                !self.SNPCoverageDisplay.renderProps().notReady);
            return (React.createElement(React.Fragment, null,
                React.createElement("g", null, await self.SNPCoverageDisplay.renderSvg(opts)),
                React.createElement("g", { transform: `translate(0 ${self.SNPCoverageDisplay.height})` }, await self.PileupDisplay.renderSvg({
                    ...opts,
                    overrideHeight: pileupHeight,
                }))));
        },
    }))
        .views(self => {
        const { trackMenuItems: superTrackMenuItems } = self;
        return {
            /**
             * #method
             */
            trackMenuItems() {
                if (!self.PileupDisplay) {
                    return [];
                }
                const extra = getLowerPanelDisplays(pluginManager).map(d => ({
                    type: 'radio',
                    label: d.displayName,
                    checked: d.name === self.PileupDisplay.type,
                    onClick: () => self.setLowerPanelType(d.name),
                }));
                return [
                    ...superTrackMenuItems(),
                    {
                        type: 'subMenu',
                        label: 'Pileup settings',
                        subMenu: self.PileupDisplay.trackMenuItems(),
                    },
                    {
                        type: 'subMenu',
                        label: 'SNPCoverage settings',
                        subMenu: self.SNPCoverageDisplay.trackMenuItems(),
                    },
                    {
                        type: 'subMenu',
                        label: `Replace lower panel with...`,
                        subMenu: extra,
                    },
                ];
            },
        };
    })
        .preProcessSnapshot(snap => {
        if (!snap) {
            return snap;
        }
        // @ts-expect-error
        const { height, ...rest } = snap;
        return { heightPreConfig: height, ...rest };
    });
}
export default stateModelFactory;
