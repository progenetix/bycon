import { getConf } from '@jbrowse/core/configuration';
import { max, min } from '@jbrowse/core/util';
import { fillColor, strokeColor } from '../shared/color';
import { fillRectCtx, strokeRectCtx } from './util';
export function drawLongReadChains({ ctx, self, chainData, view, asm, }) {
    var _a, _b, _c, _d, _e;
    const distances = [];
    const minXs = [];
    const { chains } = chainData;
    const { height } = self;
    const featureHeight = getConf(self, 'featureHeight');
    // get bounds on the 'distances' (pixel span that a particular split long
    // read 'chain' would have in view)
    for (const chain of chains) {
        let minX = Number.MAX_VALUE;
        let maxX = Number.MIN_VALUE;
        for (const elt of chain) {
            const refName = asm.getCanonicalRefName(elt.refName) || elt.refName;
            const rs = (_a = view.bpToPx({ refName, coord: elt.start })) === null || _a === void 0 ? void 0 : _a.offsetPx;
            const re = (_b = view.bpToPx({ refName, coord: elt.end })) === null || _b === void 0 ? void 0 : _b.offsetPx;
            if (rs !== undefined && re !== undefined) {
                minX = Math.min(minX, rs);
                maxX = Math.max(maxX, re);
            }
        }
        const distance = Math.abs(maxX - minX);
        distances.push(distance);
        minXs.push(minX);
    }
    const maxD = Math.log(max(distances));
    const minD = Math.max(Math.log(min(distances)) - 1, 0);
    const scaler = (height - 20) / (maxD - minD);
    const halfHeight = featureHeight / 2 - 0.5;
    // draw split long read 'chains' as connected entities
    for (let i = 0; i < chains.length; i++) {
        const chain = chains[i];
        const w = distances[i];
        const top = (Math.log(w) - minD) * scaler;
        const min = minXs[i];
        fillRectCtx(min - view.offsetPx, top + halfHeight, w, 1, ctx, 'black');
        const c1 = chain[0];
        let primaryStrand;
        if (!(c1.flags & 2048)) {
            primaryStrand = c1.strand;
        }
        else {
            const res = (_c = c1.SA) === null || _c === void 0 ? void 0 : _c.split(';')[0].split(',')[2];
            primaryStrand = res === '-' ? -1 : 1;
        }
        for (const v0 of chain) {
            const ra = asm.getCanonicalRefName(v0.refName) || v0.refName;
            const rs = (_d = view.bpToPx({ refName: ra, coord: v0.start })) === null || _d === void 0 ? void 0 : _d.offsetPx;
            const re = (_e = view.bpToPx({ refName: ra, coord: v0.end })) === null || _e === void 0 ? void 0 : _e.offsetPx;
            if (rs !== undefined && re !== undefined) {
                const w = Math.max(re - rs, 2);
                const l = rs - view.offsetPx;
                const effectiveStrand = v0.strand * primaryStrand;
                const c = effectiveStrand === -1 ? 'color_rev_strand' : 'color_fwd_strand';
                strokeRectCtx(l, top, w, featureHeight, ctx, strokeColor[c]);
                fillRectCtx(l, top, w, featureHeight, ctx, fillColor[c]);
            }
        }
    }
}
