import { readConfObject, } from '@jbrowse/core/configuration';
import { fillColor } from '../shared/color';
import { orientationTypes } from '../util';
export function colorByInsertSize(feature) {
    return feature.get('is_paired') &&
        feature.get('refName') !== feature.get('next_ref')
        ? '#555'
        : `hsl(${Math.abs(feature.get('template_length')) / 10},50%,50%)`;
}
export function colorByMappingQuality(feature) {
    return `hsl(${feature.get('score')},50%,50%)`;
}
function getOrientation(feature, config) {
    const orientationType = readConfObject(config, 'orientationType');
    const type = orientationTypes[orientationType];
    const orientation = type[feature.get('pair_orientation')];
    return {
        LR: 'color_pair_lr',
        RR: 'color_pair_rr',
        RL: 'color_pair_rl',
        LL: 'color_pair_ll',
    }[orientation];
}
export function colorByStrand(feature) {
    return feature.get('strand') === -1 ? '#8F8FD8' : '#EC8B8B';
}
export function colorByOrientation(feature, config) {
    return fillColor[getOrientation(feature, config) || 'color_nostrand'];
}
function getStranded(feature) {
    const flags = feature.get('flags');
    const strand = feature.get('strand');
    // is paired
    if (flags & 1) {
        // first-of-pair?
        const flipper = flags & 64 ? -1 : 1;
        // proper pairing
        if (flags & 2) {
            return strand * flipper === 1 ? 'color_rev_strand' : 'color_fwd_strand';
        }
        // mate missing, separate color
        else if (flags & 8) {
            return strand * flipper === 1
                ? 'color_rev_missing_mate'
                : 'color_fwd_missing_mate';
        }
        // same chrom without proper pairing gets separate color
        else if (feature.get('refName') === feature.get('next_ref')) {
            return strand * flipper === 1
                ? 'color_rev_strand_not_proper'
                : 'color_fwd_strand_not_proper';
        }
        // abberant chrom
        else {
            return strand === 1 ? 'color_fwd_diff_chr' : 'color_rev_diff_chr';
        }
    }
    return 'color_unknown';
}
export function colorByStrandedRnaSeq(feature) {
    return fillColor[getStranded(feature)];
}
