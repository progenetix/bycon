import BoxRendererType from '@jbrowse/core/pluggableElementTypes/renderers/BoxRendererType';
import { notEmpty, renderToAbstractCanvas, } from '@jbrowse/core/util';
import { readConfObject } from '@jbrowse/core/configuration';
import { getAdapter } from '@jbrowse/core/data_adapters/dataAdapterCache';
import { PileupLayoutSession, } from './PileupLayoutSession';
// locals
import { fetchSequence, shouldFetchReferenceSequence } from '../util';
import { layoutFeats } from './layoutFeatures';
export default class PileupRenderer extends BoxRendererType {
    constructor() {
        super(...arguments);
        this.supportsSVG = true;
    }
    async fetchSequence(renderProps) {
        const { sessionId, regions, adapterConfig } = renderProps;
        const { sequenceAdapter } = adapterConfig;
        if (!sequenceAdapter) {
            return undefined;
        }
        const pm = this.pluginManager;
        const { dataAdapter } = await getAdapter(pm, sessionId, sequenceAdapter);
        const [region] = regions;
        return fetchSequence(region, dataAdapter);
    }
    getExpandedRegion(region, renderArgs) {
        const { config, showSoftClip } = renderArgs;
        const { start, end } = region;
        const maxClippingSize = readConfObject(config, 'maxClippingSize');
        const bpExpansion = showSoftClip ? Math.round(maxClippingSize) : 0;
        return {
            // xref https://github.com/mobxjs/mobx-state-tree/issues/1524 for Omit
            ...region,
            start: Math.floor(Math.max(start - bpExpansion, 0)),
            end: Math.ceil(end + bpExpansion),
        };
    }
    async render(renderProps) {
        var _a;
        const features = await this.getFeatures(renderProps);
        const layout = this.createLayoutInWorker(renderProps);
        const { regions, bpPerPx } = renderProps;
        const [region] = regions;
        const layoutRecords = layoutFeats({
            ...renderProps,
            features,
            layout,
        });
        // only need reference sequence if there are features and only for some
        // cases
        const regionSequence = features.size && shouldFetchReferenceSequence((_a = renderProps.colorBy) === null || _a === void 0 ? void 0 : _a.type)
            ? await this.fetchSequence(renderProps)
            : undefined;
        const width = (region.end - region.start) / bpPerPx;
        const height = Math.max(layout.getTotalHeight(), 1);
        const { makeImageData } = await import('./makeImageData');
        const res = await renderToAbstractCanvas(width, height, renderProps, ctx => makeImageData({
            ctx,
            layoutRecords: layoutRecords.filter(notEmpty),
            canvasWidth: width,
            renderArgs: {
                ...renderProps,
                layout,
                features,
                regionSequence,
            },
        }));
        const results = await super.render({
            ...renderProps,
            ...res,
            features,
            layout,
            height,
            width,
        });
        return {
            ...results,
            ...res,
            features: new Map(),
            layout,
            height,
            width,
            maxHeightReached: layout.maxHeightReached,
        };
    }
    createSession(args) {
        return new PileupLayoutSession(args);
    }
}
