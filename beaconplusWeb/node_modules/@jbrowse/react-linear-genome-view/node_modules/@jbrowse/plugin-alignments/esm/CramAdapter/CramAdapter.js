import { CraiIndex, IndexedCramFile } from '@gmod/cram';
import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';
import { checkAbortSignal, updateStatus, toLocale, } from '@jbrowse/core/util';
import { openLocation } from '@jbrowse/core/util/io';
import { ObservableCreate } from '@jbrowse/core/util/rxjs';
import { toArray } from 'rxjs/operators';
import { firstValueFrom } from 'rxjs';
// locals
import CramSlightlyLazyFeature from './CramSlightlyLazyFeature';
export default class CramAdapter extends BaseFeatureDataAdapter {
    constructor() {
        super(...arguments);
        this.samHeader = {};
        // maps a seqId to original refname, passed specially to render args, to a seqid
        this.seqIdToOriginalRefName = [];
    }
    async configurePre() {
        const cramLocation = this.getConf('cramLocation');
        const craiLocation = this.getConf('craiLocation');
        const pm = this.pluginManager;
        const cram = new IndexedCramFile({
            cramFilehandle: openLocation(cramLocation, pm),
            index: new CraiIndex({ filehandle: openLocation(craiLocation, pm) }),
            seqFetch: (...args) => this.seqFetch(...args),
            checkSequenceMD5: false,
            fetchSizeLimit: 200000000, // just make this a large size to avoid hitting it
        });
        if (!this.getSubAdapter) {
            throw new Error('Error getting subadapter');
        }
        const seqConf = this.getConf('sequenceAdapter');
        if (!seqConf) {
            throw new Error('no sequenceAdapter supplied to CramAdapter config');
        }
        const subadapter = await this.getSubAdapter(seqConf);
        return {
            cram,
            sequenceAdapter: subadapter.dataAdapter,
        };
    }
    async configure() {
        if (!this.configureP) {
            this.configureP = this.configurePre().catch(e => {
                this.configureP = undefined;
                throw e;
            });
        }
        return this.configureP;
    }
    async getHeader(_opts) {
        const { cram } = await this.configure();
        return cram.cram.getHeaderText();
    }
    async seqFetch(seqId, start, end) {
        start -= 1; // convert from 1-based closed to interbase
        const { sequenceAdapter } = await this.configure();
        const refName = this.refIdToOriginalName(seqId) || this.refIdToName(seqId);
        if (!refName) {
            throw new Error('unknown');
        }
        const seqChunks = await firstValueFrom(sequenceAdapter
            .getFeatures({
            refName,
            start,
            end,
            assemblyName: '',
        })
            .pipe(toArray()));
        const sequence = seqChunks
            .sort((a, b) => a.get('start') - b.get('start'))
            .map(chunk => {
            const chunkStart = chunk.get('start');
            const chunkEnd = chunk.get('end');
            const trimStart = Math.max(start - chunkStart, 0);
            const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart);
            const trimLength = trimEnd - trimStart;
            const chunkSeq = chunk.get('seq') || chunk.get('residues');
            return chunkSeq.slice(trimStart, trimStart + trimLength);
        })
            .join('');
        const qlen = end - start;
        if (sequence.length !== qlen) {
            throw new Error(`fetching ${refName}:${toLocale(start - 1)}-${toLocale(end)} returned ${toLocale(sequence.length)} bases, should have returned ${toLocale(qlen)}`);
        }
        return sequence;
    }
    async setupPre(opts) {
        const { statusCallback = () => { } } = opts || {};
        return updateStatus('Downloading index', statusCallback, async () => {
            const conf = await this.configure();
            const { cram } = conf;
            const samHeader = await cram.cram.getSamHeader();
            // use the @SQ lines in the header to figure out the
            // mapping between ref ID numbers and names
            const idToName = [];
            const nameToId = {};
            samHeader
                .filter(l => l.tag === 'SQ')
                .forEach((sqLine, refId) => {
                const SN = sqLine.data.find(item => item.tag === 'SN');
                if (SN) {
                    const refName = SN.value;
                    nameToId[refName] = refId;
                    idToName[refId] = refName;
                }
            });
            const readGroups = samHeader
                .filter(l => l.tag === 'RG')
                .map(rgLine => { var _a; return (_a = rgLine.data.find(item => item.tag === 'ID')) === null || _a === void 0 ? void 0 : _a.value; });
            const data = { idToName, nameToId, readGroups };
            this.samHeader = data;
            return { samHeader: data, ...conf };
        });
    }
    async setup(opts) {
        if (!this.setupP) {
            this.setupP = this.setupPre(opts).catch(e => {
                this.setupP = undefined;
                throw e;
            });
        }
        return this.setupP;
    }
    async getRefNames(opts) {
        const { samHeader } = await this.setup(opts);
        if (!samHeader.idToName) {
            throw new Error('CRAM file has no header lines');
        }
        return samHeader.idToName;
    }
    // use info from the SAM header if possible, but fall back to using
    // the ref seq order from when the browser's refseqs were loaded
    refNameToId(refName) {
        if (this.samHeader.nameToId) {
            return this.samHeader.nameToId[refName];
        }
        if (this.seqIdToRefName) {
            return this.seqIdToRefName.indexOf(refName);
        }
        return undefined;
    }
    // use info from the SAM header if possible, but fall back to using
    // the ref seq order from when the browser's refseqs were loaded
    refIdToName(refId) {
        var _a, _b;
        return ((_a = this.samHeader.idToName) === null || _a === void 0 ? void 0 : _a[refId]) || ((_b = this.seqIdToRefName) === null || _b === void 0 ? void 0 : _b[refId]);
    }
    refIdToOriginalName(refId) {
        return this.seqIdToOriginalRefName[refId];
    }
    getFeatures(region, opts) {
        const { signal, filterBy, statusCallback = () => { } } = opts || {};
        const { refName, start, end, originalRefName } = region;
        return ObservableCreate(async (observer) => {
            const { cram, samHeader } = await this.setup(opts);
            const refId = this.refNameToId(refName);
            if (refId === undefined) {
                console.warn('Unknown refName', refName);
                observer.complete();
                return;
            }
            if (originalRefName) {
                this.seqIdToOriginalRefName[refId] = originalRefName;
            }
            const records = await updateStatus('Downloading alignments', statusCallback, () => cram.getRecordsForRange(refId, start, end));
            checkAbortSignal(signal);
            await updateStatus('Processing alignments', statusCallback, () => {
                var _a;
                const { flagInclude = 0, flagExclude = 0, tagFilter, readName, } = filterBy || {};
                for (const record of records) {
                    const flags = record.flags;
                    if ((flags & flagInclude) !== flagInclude && !(flags & flagExclude)) {
                        continue;
                    }
                    if (tagFilter) {
                        const v = tagFilter.tag === 'RG'
                            ? (_a = samHeader.readGroups) === null || _a === void 0 ? void 0 : _a[record.readGroupId]
                            : record.tags[tagFilter.tag];
                        if (!(tagFilter.value === '*'
                            ? v !== undefined
                            : `${v}` === tagFilter.value)) {
                            continue;
                        }
                    }
                    if (readName && record.readName !== readName) {
                        continue;
                    }
                    observer.next(this.cramRecordToFeature(record));
                }
                observer.complete();
            });
        }, signal);
    }
    freeResources( /* { region } */) { }
    cramRecordToFeature(record) {
        return new CramSlightlyLazyFeature(record, this);
    }
    // we return the configured fetchSizeLimit, and the bytes for the region
    async getMultiRegionFeatureDensityStats(regions, opts) {
        const bytes = await this.bytesForRegions(regions, opts);
        const fetchSizeLimit = this.getConf('fetchSizeLimit');
        return {
            bytes,
            fetchSizeLimit,
        };
    }
    /**
     * get the approximate number of bytes queried from the file for the given
     * query regions
     * @param regions - list of query regions
     */
    async bytesForRegions(regions, _opts) {
        const { cram } = await this.configure();
        const blockResults = await Promise.all(regions.map(region => {
            const { refName, start, end } = region;
            const chrId = this.refNameToId(refName);
            return chrId !== undefined
                ? cram.index.getEntriesForRange(chrId, start, end)
                : [{ sliceBytes: 0 }];
        }));
        return blockResults.flat().reduce((a, b) => a + b.sliceBytes, 0);
    }
}
