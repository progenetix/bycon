/// <reference types="react" />
import { UriLocation } from '@jbrowse/core/util';
import { Instance } from 'mobx-state-tree';
/**
 * #stateModel OAuthInternetAccount
 */
declare const stateModelFactory: (configSchema: import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaType<{
    tokenType: {
        description: string;
        type: string;
        defaultValue: string;
    };
    authEndpoint: {
        description: string;
        type: string;
        defaultValue: string;
    };
    tokenEndpoint: {
        description: string;
        type: string;
        defaultValue: string;
    };
    needsPKCE: {
        description: string;
        type: string;
        defaultValue: boolean;
    };
    clientId: {
        description: string; /**
         * #getter
         */
        type: string;
        defaultValue: string;
    };
    scopes: {
        description: string;
        type: string;
        defaultValue: string;
    };
    state: {
        description: string;
        type: string;
        defaultValue: string;
    };
    responseType: {
        description: string;
        type: string;
        defaultValue: string;
    };
}, import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaOptions<import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaType<{
    name: {
        description: string;
        type: string;
        defaultValue: string;
    };
    description: {
        description: string;
        type: string;
        defaultValue: string;
    };
    authHeader: {
        description: string;
        type: string;
        defaultValue: string;
    };
    tokenType: {
        description: string;
        type: string;
        defaultValue: string;
    };
    domains: {
        description: string;
        type: string;
        defaultValue: never[];
    };
}, import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaOptions<undefined, "internetAccountId">>, undefined>>) => import("mobx-state-tree").IModelType<{
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    type: import("mobx-state-tree").ISimpleType<string>;
    configuration: import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaType<{
        name: {
            description: string;
            type: string;
            defaultValue: string;
        };
        description: {
            description: string;
            type: string;
            defaultValue: string;
        };
        authHeader: {
            description: string;
            type: string;
            defaultValue: string;
        };
        tokenType: {
            description: string;
            type: string;
            defaultValue: string;
        };
        domains: {
            description: string; /**
             * #getter
             */
            type: string;
            defaultValue: never[];
        };
    }, import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaOptions<undefined, "internetAccountId">>;
} & {
    /**
     * #property
     */
    type: import("mobx-state-tree").ISimpleType<"OAuthInternetAccount">;
    /**
     * #property
     */
    configuration: import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaType<{
        tokenType: {
            description: string;
            type: string;
            defaultValue: string;
        };
        authEndpoint: {
            description: string;
            type: string;
            defaultValue: string;
        };
        tokenEndpoint: {
            description: string;
            type: string;
            defaultValue: string;
        };
        needsPKCE: {
            description: string;
            type: string;
            defaultValue: boolean;
        };
        clientId: {
            description: string; /**
             * #getter
             */
            type: string;
            defaultValue: string;
        };
        scopes: {
            description: string;
            type: string;
            defaultValue: string;
        };
        state: {
            description: string;
            type: string;
            defaultValue: string;
        };
        responseType: {
            description: string;
            type: string;
            defaultValue: string;
        };
    }, import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaOptions<import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaType<{
        name: {
            description: string;
            type: string;
            defaultValue: string;
        };
        description: {
            description: string;
            type: string;
            defaultValue: string;
        };
        authHeader: {
            description: string;
            type: string;
            defaultValue: string;
        };
        tokenType: {
            description: string;
            type: string;
            defaultValue: string;
        };
        domains: {
            description: string;
            type: string;
            defaultValue: never[];
        };
    }, import("@jbrowse/core/configuration/configurationSchema").ConfigurationSchemaOptions<undefined, "internetAccountId">>, undefined>>;
}, {
    readonly name: string;
    readonly description: string;
    readonly internetAccountId: string; /**
     * #getter
     */
    readonly authHeader: string;
    readonly tokenType: string; /**
     * #getter
     */
    readonly domains: string[];
    readonly toggleContents: import("react").ReactNode;
    readonly SelectorComponent: import("@jbrowse/core/util").AnyReactComponentType | undefined;
    readonly selectorLabel: string | undefined;
} & {
    handlesLocation(location: UriLocation): boolean;
    readonly tokenKey: string;
} & {
    getTokenFromUser(_resolve: (token: string) => void, _reject: (error: Error) => void): void;
    storeToken(token: string): void;
    removeToken(): void;
    retrieveToken(): string | null;
    validateToken(token: string, _loc: UriLocation): Promise<string>;
} & {
    getToken(location?: UriLocation | undefined): Promise<string>;
} & {
    addAuthHeaderToInit(init: RequestInit | undefined, token: string): {
        headers: Headers;
        body?: BodyInit | null | undefined;
        cache?: RequestCache | undefined;
        credentials?: RequestCredentials | undefined;
        integrity?: string | undefined;
        keepalive?: boolean | undefined;
        method?: string | undefined;
        mode?: RequestMode | undefined;
        priority?: RequestPriority | undefined;
        redirect?: RequestRedirect | undefined;
        referrer?: string | undefined;
        referrerPolicy?: ReferrerPolicy | undefined;
        signal?: AbortSignal | null | undefined;
        window?: null | undefined;
    };
    getPreAuthorizationInformation(location: UriLocation): Promise<{
        internetAccountType: string;
        authInfo: {
            token: string;
            configuration: any;
        };
    }>;
} & {
    getFetcher(loc?: UriLocation | undefined): (input: RequestInfo, init?: RequestInit | undefined) => Promise<Response>;
} & {
    openLocation(location: UriLocation): import("@jbrowse/core/util/io").RemoteFileWithRangeCache;
} & {
    /**
     * #getter
     */
    readonly codeVerifierPKCE: string;
} & {
    /**
     * #getter
     */
    readonly authEndpoint: string;
    /**
     * #getter
     */
    readonly tokenEndpoint: string;
    /**
     * #getter
     */
    readonly needsPKCE: boolean;
    /**
     * #getter
     */
    readonly clientId: string;
    /**
     * #getter
     */
    readonly scopes: string;
    /**
     * #method
     * OAuth state parameter:
     * https://www.rfc-editor.org/rfc/rfc6749#section-4.1.1
     *
     * Can override or extend if dynamic state is needed.
     */
    state(): string | undefined;
    /**
     * #getter
     */
    readonly responseType: "code" | "token";
    /**
     * #getter
     */
    readonly refreshTokenKey: string;
} & {
    /**
     * #action
     */
    storeRefreshToken(refreshToken: string): void;
    /**
     * #action
     */
    removeRefreshToken(): void;
    /**
     * #method
     */
    retrieveRefreshToken(): string | null;
    /**
     * #action
     */
    exchangeAuthorizationForAccessToken(token: string, redirectUri: string): Promise<string>;
    /**
     * #action
     */
    exchangeRefreshForAccessToken(refreshToken: string): Promise<string>;
} & {
    /**
     * #action
     * used to listen to child window for auth code/token
     */
    addMessageChannel(resolve: (token: string) => void, reject: (error: Error) => void): void;
    /**
     * #action
     */
    deleteMessageChannel(): void;
    /**
     * #action
     */
    finishOAuthWindow(event: MessageEvent, resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
    /**
     * #action
     * opens external OAuth flow, popup for web and new browser window for
     * desktop
     */
    useEndpointForAuthorization(resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
    /**
     * #action
     */
    getTokenFromUser(resolve: (token: string) => void, reject: (error: Error) => void): Promise<void>;
    /**
     * #action
     */
    validateToken(token: string, location: UriLocation): Promise<string>;
} & {
    /**
     * #action
     * Get a fetch method that will add any needed authentication headers
     * to the request before sending it. If location is provided, it will
     * be checked to see if it includes a token in it's pre-auth
     * information.
     *
     * @param loc - UriLocation of the resource
     * @returns A function that can be used to fetch
     */
    getFetcher(loc?: UriLocation): (input: RequestInfo, init?: RequestInit) => Promise<Response>;
}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
export default stateModelFactory;
export type OAuthStateModel = ReturnType<typeof stateModelFactory>;
export type OAuthModel = Instance<OAuthStateModel>;
