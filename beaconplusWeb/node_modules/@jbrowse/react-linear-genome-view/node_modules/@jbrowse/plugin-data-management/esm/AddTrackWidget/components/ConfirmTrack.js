import React, { useEffect, useState } from 'react';
import { Checkbox, FormControl, FormControlLabel, Link, TextField, Typography, } from '@mui/material';
import { makeStyles } from 'tss-react/mui';
import { isSupportedIndexingAdapter, getSession, isElectron, } from '@jbrowse/core/util';
import { observer } from 'mobx-react';
import { UNKNOWN } from '@jbrowse/core/util/tracks';
import { AssemblySelector } from '@jbrowse/core/ui';
import TextIndexingConfig from './TextIndexingConfig';
import TrackTypeSelector from './TrackTypeSelector';
import TrackAdapterSelector from './TrackAdapterSelector';
const useStyles = makeStyles()(theme => ({
    spacing: {
        marginBottom: theme.spacing(3),
    },
}));
function StatusMessage({ trackAdapter, trackType, }) {
    const { classes } = useStyles();
    const { type, subadapter } = trackAdapter;
    return type === 'SNPCoverageAdapter' ? (React.createElement(Typography, { className: classes.spacing },
        "Selected ",
        React.createElement("code", null, trackType),
        ". Using adapter ",
        React.createElement("code", null, type),
        " with subadapter ",
        React.createElement("code", null, subadapter === null || subadapter === void 0 ? void 0 : subadapter.type),
        ". Please enter a track name and, if necessary, update the track type.")) : (React.createElement(Typography, { className: classes.spacing },
        "Using adapter ",
        React.createElement("code", null, type),
        " and guessing track type",
        ' ',
        React.createElement("code", null, trackType),
        ". Please enter a track name and, if necessary, update the track type."));
}
function UnknownAdapterPrompt({ model }) {
    const { classes } = useStyles();
    return (React.createElement(React.Fragment, null,
        React.createElement(Typography, { className: classes.spacing },
            "JBrowse was not able to guess the adapter type for this data, but it may be in the list below. If not, you can",
            ' ',
            React.createElement(Link, { href: "https://github.com/GMOD/jbrowse-components/releases", target: "_blank", rel: "noopener noreferrer" }, "check for new releases"),
            ' ',
            "of JBrowse to see if they support this data type or",
            ' ',
            React.createElement(Link, { href: "https://github.com/GMOD/jbrowse-components/issues/new", target: "_blank", rel: "noopener noreferrer" }, "file an issue"),
            ' ',
            "and add a feature request for this data type."),
        React.createElement(TrackAdapterSelector, { model: model })));
}
const ConfirmTrack = observer(function ConfirmTrack({ model, }) {
    const { classes } = useStyles();
    const [check, setCheck] = useState(true);
    const session = getSession(model);
    const { trackName, trackAdapter, trackType, warningMessage, adapterHint } = model;
    useEffect(() => {
        if (adapterHint === '' && trackAdapter) {
            model.setAdapterHint(trackAdapter.type);
        }
    }, [adapterHint, trackAdapter, trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type, model]);
    if (model.unsupported) {
        return (React.createElement(Typography, { className: classes.spacing },
            "This version of JBrowse cannot display data of this type. It is possible, however, that there is a newer version that can display them. You can",
            ' ',
            React.createElement(Link, { href: "https://github.com/GMOD/jbrowse-components/releases", target: "_blank", rel: "noopener noreferrer" }, "check for new releases"),
            ' ',
            "of JBrowse or",
            ' ',
            React.createElement(Link, { href: "https://github.com/GMOD/jbrowse-components/issues/new", target: "_blank", rel: "noopener noreferrer" }, "file an issue"),
            ' ',
            "and add a feature request for this data type."));
    }
    if ((trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type) === UNKNOWN) {
        return React.createElement(UnknownAdapterPrompt, { model: model });
    }
    if (!(trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type)) {
        return React.createElement(Typography, null, "Could not recognize this data type.");
    }
    const supportedForIndexing = isSupportedIndexingAdapter(trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type);
    return (React.createElement("div", null,
        trackAdapter ? (React.createElement(StatusMessage, { trackAdapter: trackAdapter, trackType: trackType })) : null,
        warningMessage ? (React.createElement(Typography, { style: { color: 'orange' } }, warningMessage)) : null,
        React.createElement(TextField, { className: classes.spacing, label: "trackName", helperText: "A name for this track", fullWidth: true, value: trackName, onChange: event => model.setTrackName(event.target.value), inputProps: { 'data-testid': 'trackNameInput' } }),
        React.createElement(TrackAdapterSelector, { model: model }),
        React.createElement(TrackTypeSelector, { model: model }),
        React.createElement(AssemblySelector, { session: session, helperText: "Select assembly to add track to", selected: model.assembly, onChange: asm => model.setAssembly(asm), TextFieldProps: {
                fullWidth: true,
                SelectProps: {
                    // @ts-expect-error
                    SelectDisplayProps: { 'data-testid': 'assemblyNameSelect' },
                },
            } }),
        isElectron && supportedForIndexing && (React.createElement(FormControl, null,
            React.createElement(FormControlLabel, { label: 'Index track for text searching?', control: React.createElement(Checkbox, { checked: check, onChange: e => {
                        setCheck(e.target.checked);
                        model.setTextIndexTrack(e.target.checked);
                    } }) }))),
        isElectron && check && supportedForIndexing ? (React.createElement(TextIndexingConfig, { model: model })) : null));
});
export default ConfirmTrack;
