import React, { useState } from 'react';
import { Alert, Button, Step, StepContent, StepLabel, Stepper, Typography, } from '@mui/material';
import { makeStyles } from 'tss-react/mui';
import { getRoot } from 'mobx-state-tree';
import { getSession, isElectron, isSessionModelWithWidgets, isSessionWithAddTracks, isSupportedIndexingAdapter, } from '@jbrowse/core/util';
import { getConf } from '@jbrowse/core/configuration';
import { observer } from 'mobx-react';
// locals
import ConfirmTrack from './ConfirmTrack';
import TrackSourceSelect from './TrackSourceSelect';
const useStyles = makeStyles()(theme => ({
    root: {
        marginTop: theme.spacing(1),
    },
    stepper: {
        backgroundColor: theme.palette.background.default,
    },
    button: {
        marginRight: theme.spacing(1),
    },
    actionsContainer: {
        marginTop: theme.spacing(10),
        marginBottom: theme.spacing(2),
    },
    alertContainer: {
        padding: `${theme.spacing(2)}px 0px ${theme.spacing(2)}px 0px`,
    },
}));
const steps = ['Enter track data', 'Confirm track type'];
const DefaultAddTrackWorkflow = observer(function ({ model, }) {
    const [activeStep, setActiveStep] = useState(0);
    const { classes } = useStyles();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { jobsManager } = getRoot(model);
    const session = getSession(model);
    const { assembly, trackAdapter, trackData, trackName, trackType, textIndexTrack, textIndexingConf, } = model;
    const [trackErrorMessage, setTrackErrorMessage] = useState();
    function getStepContent(step) {
        switch (step) {
            case 0:
                return React.createElement(TrackSourceSelect, { model: model });
            case 1:
                return React.createElement(ConfirmTrack, { model: model });
            default:
                return React.createElement(Typography, null, "Unknown step");
        }
    }
    async function handleNext() {
        var _a, _b;
        if (activeStep !== steps.length - 1) {
            setActiveStep(activeStep + 1);
            return;
        }
        const trackId = [
            `${trackName.toLowerCase().replaceAll(' ', '_')}-${Date.now()}`,
            `${session.adminMode ? '' : '-sessionTrack'}`,
        ].join('');
        const assemblyInstance = session.assemblyManager.get(assembly);
        if (!isSessionWithAddTracks(session)) {
            setTrackErrorMessage('Unable to add tracks to this model');
            return;
        }
        if (assemblyInstance && trackAdapter && trackAdapter.type !== 'UNKNOWN') {
            session.addTrackConf({
                trackId,
                type: trackType,
                name: trackName,
                assemblyNames: [assembly],
                adapter: {
                    ...trackAdapter,
                    sequenceAdapter: getConf(assemblyInstance, ['sequence', 'adapter']),
                },
            });
            (_b = (_a = model.view).showTrack) === null || _b === void 0 ? void 0 : _b.call(_a, trackId);
            if (isElectron &&
                textIndexTrack &&
                isSupportedIndexingAdapter(trackAdapter.type)) {
                const attr = textIndexingConf || {
                    attributes: ['Name', 'ID'],
                    exclude: ['CDS', 'exon'],
                };
                const indexName = trackName + '-index';
                const newEntry = {
                    indexingParams: {
                        ...attr,
                        assemblies: [assembly],
                        tracks: [trackId],
                        indexType: 'perTrack',
                        name: indexName,
                        timestamp: new Date().toISOString(),
                    },
                    name: indexName,
                    cancelCallback: () => jobsManager.abortJob(),
                };
                jobsManager.queueJob(newEntry);
            }
            model.clearData();
            if (isSessionModelWithWidgets(session)) {
                session.hideWidget(model);
            }
        }
        else {
            setTrackErrorMessage('Failed to add track.\nThe configuration of this file is not currently supported.');
        }
    }
    function isNextDisabled() {
        switch (activeStep) {
            case 0:
                return !trackData;
            case 1:
                return !(trackName && trackType && (trackAdapter === null || trackAdapter === void 0 ? void 0 : trackAdapter.type) && assembly);
            default:
                return true;
        }
    }
    return (React.createElement("div", { className: classes.root },
        React.createElement(Stepper, { className: classes.stepper, activeStep: activeStep, orientation: "vertical" }, steps.map((label, idx) => (React.createElement(Step, { key: label },
            React.createElement(StepLabel, null, label),
            React.createElement(StepContent, null,
                getStepContent(idx),
                React.createElement("div", { className: classes.actionsContainer },
                    React.createElement(Button, { disabled: activeStep === 0, onClick: () => {
                            setTrackErrorMessage(undefined);
                            setActiveStep(activeStep - 1);
                        }, className: classes.button }, "Back"),
                    React.createElement(Button, { disabled: isNextDisabled(), variant: "contained", color: "primary", onClick: handleNext, className: classes.button, "data-testid": "addTrackNextButton" }, activeStep === steps.length - 1 ? 'Add' : 'Next')),
                trackErrorMessage ? (React.createElement("div", { className: classes.alertContainer },
                    React.createElement(Alert, { severity: "error" }, trackErrorMessage))) : null)))))));
});
export default DefaultAddTrackWorkflow;
