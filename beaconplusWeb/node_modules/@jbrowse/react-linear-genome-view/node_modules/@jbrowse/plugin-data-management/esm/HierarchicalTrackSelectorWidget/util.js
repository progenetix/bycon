import { readConfObject, } from '@jbrowse/core/configuration';
import { getTrackName } from '@jbrowse/core/util/tracks';
export function hasAnyOverlap(a1 = [], a2 = []) {
    // shortcut case is that arrays are single entries, and are equal
    // long case is that we use a set
    if (a1[0] === a2[0]) {
        return true;
    }
    else {
        const s1 = new Set(a1);
        return a2.some(a => s1.has(a));
    }
}
export function hasAllOverlap(a1 = [], a2 = []) {
    const s1 = new Set(a1);
    return a2.every(a => s1.has(a));
}
export function matches(query, conf, session) {
    const categories = (readConfObject(conf, 'category') || []);
    const queryLower = query.toLowerCase();
    return (getTrackName(conf, session).toLowerCase().includes(queryLower) ||
        !!categories.filter(c => c.toLowerCase().includes(queryLower)).length);
}
export function findSubCategories(obj, paths, depth = 0) {
    let hasSubs = false;
    for (const elt of obj) {
        if (elt.children.length) {
            const hasSubCategories = findSubCategories(elt.children, paths, depth + 1);
            // avoid pushing the root "Tracks" node by checking depth>0
            if (hasSubCategories && depth > 0) {
                paths.push(elt.id);
            }
        }
        else {
            hasSubs = true;
        }
    }
    return hasSubs;
}
export function findTopLevelCategories(obj, paths) {
    for (const elt of obj) {
        if (elt.children.length) {
            paths.push(elt.id);
        }
    }
}
