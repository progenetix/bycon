import React from 'react';
import { observer } from 'mobx-react';
// locals
import FacetFilter from './FacetFilter';
import { getRowStr } from './util';
const FacetFilters = observer(function ({ rows, columns, model, }) {
    var _a, _b;
    const { faceted } = model;
    const { filters } = faceted;
    const facets = columns.slice(1);
    const uniqs = new Map(facets.map(f => [f.field, new Map()]));
    // this code "stages the facet filters" in order that the user has selected
    // them, which relies on the js behavior that the order of the returned keys is
    // related to the insertion order.
    const filterKeys = faceted.filters.keys();
    const facetKeys = facets.map(f => f.field);
    const ret = new Set();
    for (const entry of filterKeys) {
        // give non-empty filters priority
        if ((_a = filters.get(entry)) === null || _a === void 0 ? void 0 : _a.length) {
            ret.add(entry);
        }
    }
    for (const entry of facetKeys) {
        ret.add(entry);
    }
    let currentRows = rows;
    for (const facet of ret) {
        const elt = uniqs.get(facet);
        for (const row of currentRows) {
            const key = getRowStr(facet, row);
            const val = elt.get(key);
            // we don't allow filtering on empty yet
            if (key) {
                if (val === undefined) {
                    elt.set(key, 1);
                }
                else {
                    elt.set(key, val + 1);
                }
            }
        }
        const filter = ((_b = filters.get(facet)) === null || _b === void 0 ? void 0 : _b.length)
            ? new Set(filters.get(facet))
            : undefined;
        currentRows = currentRows.filter(row => filter !== undefined ? filter.has(getRowStr(facet, row)) : true);
    }
    return (React.createElement("div", null, facets.map(c => (React.createElement(FacetFilter, { key: c.field, vals: [...uniqs.get(c.field)], column: c, model: model })))));
});
export default FacetFilters;
