import { polarToCartesian, assembleLocString } from '@jbrowse/core/util';
import { thetaRangesOverlap } from './viewportVisibleRegion';
export class Slice {
    constructor(view, region, offsetRadians, radianWidth) {
        this.region = region;
        this.offsetRadians = offsetRadians;
        this.radianWidth = radianWidth;
        const { bpPerRadian } = view;
        this.key =
            'regions' in region
                ? JSON.stringify(region.regions)
                : assembleLocString(region);
        this.bpPerRadian = bpPerRadian;
        this.flipped = false;
        this.startRadians = offsetRadians;
        this.endRadians = region.widthBp / this.bpPerRadian + offsetRadians;
        Object.freeze(this);
    }
    bpToXY(bp, radiusPx) {
        let offsetBp;
        if (this.region.elided) {
            offsetBp = this.region.widthBp / 2;
        }
        else if (this.flipped) {
            offsetBp = this.region.end - bp;
        }
        else {
            offsetBp = bp - this.region.start;
        }
        const totalRadians = offsetBp / this.bpPerRadian + this.offsetRadians;
        return polarToCartesian(radiusPx, totalRadians);
    }
    toJSON() {
        return Object.fromEntries(Object.entries(this));
    }
}
function calculateStaticSlices(self) {
    const slices = [];
    let currentRadianOffset = 0;
    const { bpPerRadian, spacingPx, pxPerRadian } = self;
    for (const region of self.elidedRegions) {
        const radianWidth = region.widthBp / bpPerRadian + spacingPx / pxPerRadian;
        slices.push(new Slice(self, region, currentRadianOffset, radianWidth));
        currentRadianOffset += radianWidth;
    }
    return slices;
}
function sliceIsVisible(self, slice) {
    const { theta: [visibleThetaMin, visibleThetaMax], } = self.visibleSection;
    return thetaRangesOverlap(slice.offsetRadians + self.offsetRadians, slice.radianWidth, visibleThetaMin, visibleThetaMax - visibleThetaMin);
}
export { calculateStaticSlices, sliceIsVisible };
