import { assembleLocString, parseLocString, } from '@jbrowse/core/util';
import { onPatch } from 'mobx-state-tree';
import createModel from './createModel';
export default function createViewState(opts) {
    const { assembly, tracks, internetAccounts, configuration, aggregateTextSearchAdapters, plugins, location, highlight, onChange, disableAddTracks = false, makeWorkerInstance, hydrateFn, createRootFn, } = opts;
    const { model, pluginManager } = createModel(plugins || [], makeWorkerInstance, hydrateFn, createRootFn);
    let { defaultSession } = opts;
    if (!defaultSession) {
        defaultSession = {
            name: 'this session',
            view: {
                id: 'linearGenomeView',
                type: 'LinearGenomeView',
            },
        };
    }
    const stateTree = model.create({
        config: {
            configuration,
            assembly,
            tracks,
            internetAccounts,
            aggregateTextSearchAdapters,
        },
        disableAddTracks,
        session: defaultSession,
    }, { pluginManager });
    stateTree.config.internetAccounts.forEach(account => {
        const internetAccountType = pluginManager.getInternetAccountType(account.type);
        if (!internetAccountType) {
            throw new Error(`unknown internet account type ${account.type}`);
        }
        stateTree.addInternetAccount({
            type: account.type,
            configuration: account,
        });
    });
    pluginManager.setRootModel(stateTree);
    pluginManager.configure();
    if (location) {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        ;
        (async () => {
            const { session } = stateTree;
            const { isValidRefName } = session.assemblyManager;
            try {
                await session.view.navToLocString(typeof location === 'string' ? location : assembleLocString(location), assembly.name);
                if (highlight) {
                    highlight.forEach(h => {
                        if (h) {
                            const parsedLocString = parseLocString(h, refName => isValidRefName(refName, assembly.name));
                            const location = {
                                ...parsedLocString,
                                assemblyName: assembly,
                            };
                            if ((location === null || location === void 0 ? void 0 : location.start) !== undefined &&
                                (location === null || location === void 0 ? void 0 : location.end) !== undefined) {
                                session.view.addToHighlights(location);
                            }
                        }
                    });
                }
            }
            catch (e) {
                session.notifyError(`${e}`, e);
            }
        })();
    }
    if (onChange) {
        onPatch(stateTree, onChange);
    }
    return stateTree;
}
