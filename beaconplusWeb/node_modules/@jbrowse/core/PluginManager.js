"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mobx_state_tree_1 = require("mobx-state-tree");
const RendererType_1 = __importDefault(require("./pluggableElementTypes/renderers/RendererType"));
const AdapterType_1 = __importDefault(require("./pluggableElementTypes/AdapterType"));
const TrackType_1 = __importDefault(require("./pluggableElementTypes/TrackType"));
const DisplayType_1 = __importDefault(require("./pluggableElementTypes/DisplayType"));
const ViewType_1 = __importDefault(require("./pluggableElementTypes/ViewType"));
const WidgetType_1 = __importDefault(require("./pluggableElementTypes/WidgetType"));
const ConnectionType_1 = __importDefault(require("./pluggableElementTypes/ConnectionType"));
const RpcMethodType_1 = __importDefault(require("./pluggableElementTypes/RpcMethodType"));
const InternetAccountType_1 = __importDefault(require("./pluggableElementTypes/InternetAccountType"));
const TextSearchAdapterType_1 = __importDefault(require("./pluggableElementTypes/TextSearchAdapterType"));
const AddTrackWorkflowType_1 = __importDefault(require("./pluggableElementTypes/AddTrackWorkflowType"));
const configuration_1 = require("./configuration");
const ReExports_1 = __importDefault(require("./ReExports"));
const CorePlugin_1 = __importDefault(require("./CorePlugin"));
const jexl_1 = __importDefault(require("./util/jexl"));
// helper class that keeps groups of callbacks that are then run in a specified
// order by group
class PhasedScheduler {
    constructor(...phaseOrder) {
        this.phaseCallbacks = new Map();
        this.phaseOrder = [];
        this.phaseOrder = phaseOrder;
    }
    add(phase, callback) {
        if (!this.phaseOrder.includes(phase)) {
            throw new Error(`unknown phase ${phase}`);
        }
        let phaseCallbacks = this.phaseCallbacks.get(phase);
        if (!phaseCallbacks) {
            phaseCallbacks = [];
            this.phaseCallbacks.set(phase, phaseCallbacks);
        }
        phaseCallbacks.push(callback);
    }
    run() {
        this.phaseOrder.forEach(phaseName => {
            var _a;
            (_a = this.phaseCallbacks.get(phaseName)) === null || _a === void 0 ? void 0 : _a.forEach(callback => callback());
        });
    }
}
/** internal class that holds the info for a certain element type */
class TypeRecord {
    constructor(typeName, baseClass) {
        this.typeName = typeName;
        this.baseClass = baseClass;
        this.registeredTypes = {};
    }
    add(name, t) {
        this.registeredTypes[name] = t;
    }
    has(name) {
        return name in this.registeredTypes;
    }
    get(name) {
        if (!this.has(name)) {
            throw new Error(`${this.typeName} '${name}' not found, perhaps its plugin is not loaded or its plugin has not added it.`);
        }
        return this.registeredTypes[name];
    }
    all() {
        return Object.values(this.registeredTypes);
    }
}
class PluginManager {
    constructor(initialPlugins = []) {
        this.plugins = [];
        this.jexl = (0, jexl_1.default)();
        this.pluginMetadata = {};
        this.runtimePluginDefinitions = [];
        this.elementCreationSchedule = new PhasedScheduler('renderer', 'adapter', 'text search adapter', 'display', 'track', 'connection', 'view', 'widget', 'rpc method', 'internet account', 'add track workflow');
        this.rendererTypes = new TypeRecord('RendererType', RendererType_1.default);
        this.adapterTypes = new TypeRecord('AdapterType', AdapterType_1.default);
        this.textSearchAdapterTypes = new TypeRecord('TextSearchAdapterType', TextSearchAdapterType_1.default);
        this.trackTypes = new TypeRecord('TrackType', TrackType_1.default);
        this.displayTypes = new TypeRecord('DisplayType', DisplayType_1.default);
        this.connectionTypes = new TypeRecord('ConnectionType', ConnectionType_1.default);
        this.viewTypes = new TypeRecord('ViewType', ViewType_1.default);
        this.widgetTypes = new TypeRecord('WidgetType', WidgetType_1.default);
        this.rpcMethods = new TypeRecord('RpcMethodType', RpcMethodType_1.default);
        this.addTrackWidgets = new TypeRecord('AddTrackWorkflow', AddTrackWorkflowType_1.default);
        this.internetAccountTypes = new TypeRecord('InternetAccountType', InternetAccountType_1.default);
        this.configured = false;
        this.extensionPoints = new Map();
        this.jbrequireCache = new Map();
        this.lib = ReExports_1.default;
        this.load = (lib) => {
            if (!this.jbrequireCache.has(lib)) {
                this.jbrequireCache.set(lib, lib(this));
            }
            return this.jbrequireCache.get(lib);
        };
        /**
         * Get the re-exported version of the given package name.
         * Throws an error if the package is not re-exported by the plugin manager.
         *
         * @returns the library's default export
         */
        this.jbrequire = (lib) => {
            if (typeof lib === 'string') {
                const pack = this.lib[lib];
                if (!pack) {
                    throw new TypeError(`No jbrequire re-export defined for package '${lib}'. If this package must be shared between plugins, add it to ReExports.js. If it does not need to be shared, just import it normally.`);
                }
                return pack;
            }
            if (typeof lib === 'function') {
                return this.load(lib);
            }
            if (lib.default) {
                return this.jbrequire(lib.default);
            }
            throw new TypeError('lib passed to jbrequire must be either a string or a function');
        };
        // add the core plugin
        this.addPlugin({
            plugin: new CorePlugin_1.default(),
            metadata: {
                isCore: true,
            },
        });
        // add all the initial plugins
        initialPlugins.forEach(plugin => {
            this.addPlugin(plugin);
        });
    }
    pluginConfigurationSchemas() {
        const configurationSchemas = {};
        this.plugins.forEach(plugin => {
            if (plugin.configurationSchema) {
                configurationSchemas[plugin.name] = plugin.configurationSchema;
            }
        });
        return configurationSchemas;
    }
    addPlugin(load) {
        if (this.configured) {
            throw new Error('JBrowse already configured, cannot add plugins');
        }
        // check for availability of 'install' and 'configure' as a proxy for being
        // an 'instanceof Plugin'
        const [plugin, metadata = {}] = 'install' in load && 'configure' in load
            ? [load, {}]
            : [load.plugin, load.metadata];
        if (this.plugins.includes(plugin)) {
            throw new Error('plugin already installed');
        }
        this.pluginMetadata[plugin.name] = metadata;
        if ('definition' in load) {
            this.runtimePluginDefinitions.push(load.definition);
        }
        plugin.install(this);
        this.plugins.push(plugin);
        return this;
    }
    getPlugin(name) {
        return this.plugins.find(p => p.name === name);
    }
    hasPlugin(name) {
        return this.getPlugin(name) !== undefined;
    }
    createPluggableElements() {
        // run the creation callbacks for each element type in order.
        // see elementCreationSchedule above for the creation order
        if (this.elementCreationSchedule) {
            this.elementCreationSchedule.run();
            delete this.elementCreationSchedule;
        }
        return this;
    }
    setRootModel(rootModel) {
        this.rootModel = rootModel;
    }
    configure() {
        if (this.configured) {
            throw new Error('already configured');
        }
        this.plugins.forEach(plugin => plugin.configure(this));
        this.configured = true;
        return this;
    }
    getElementTypeRecord(groupName) {
        switch (groupName) {
            case 'adapter':
                return this.adapterTypes;
            case 'text search adapter':
                return this.textSearchAdapterTypes;
            case 'connection':
                return this.connectionTypes;
            case 'widget':
                return this.widgetTypes;
            case 'renderer':
                return this.rendererTypes;
            case 'display':
                return this.displayTypes;
            case 'track':
                return this.trackTypes;
            case 'view':
                return this.viewTypes;
            case 'rpc method':
                return this.rpcMethods;
            case 'internet account':
                return this.internetAccountTypes;
            case 'add track workflow':
                return this.addTrackWidgets;
            default:
                throw new Error(`invalid element type '${groupName}'`);
        }
    }
    addElementType(groupName, creationCallback) {
        var _a;
        if (typeof creationCallback !== 'function') {
            throw new Error('must provide a callback function that returns the new type object');
        }
        const typeRecord = this.getElementTypeRecord(groupName);
        (_a = this.elementCreationSchedule) === null || _a === void 0 ? void 0 : _a.add(groupName, () => {
            const newElement = creationCallback(this);
            if (!newElement.name) {
                throw new Error(`cannot add a ${groupName} with no name`);
            }
            if (typeRecord.has(newElement.name)) {
                throw new Error(`${groupName} ${newElement.name} already registered, cannot register it again`);
            }
            typeRecord.add(newElement.name, this.evaluateExtensionPoint('Core-extendPluggableElement', newElement));
        });
        return this;
    }
    getElementType(groupName, typeName) {
        return this.getElementTypeRecord(groupName).get(typeName);
    }
    getElementTypesInGroup(groupName) {
        return this.getElementTypeRecord(groupName).all();
    }
    getTrackElements() {
        return this.getElementTypesInGroup('track');
    }
    getConnectionElements() {
        return this.getElementTypesInGroup('connection');
    }
    getAddTrackWorkflowElements() {
        return this.getElementTypesInGroup('add track workflow');
    }
    getRpcElements() {
        return this.getElementTypesInGroup('rpc method');
    }
    getDisplayElements() {
        return this.getElementTypesInGroup('display');
    }
    getAdapterElements() {
        return this.getElementTypesInGroup('adapter');
    }
    /** get a MST type for the union of all specified pluggable MST types */
    pluggableMstType(groupName, fieldName, fallback = mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.null)) {
        const pluggableTypes = this.getElementTypeRecord(groupName)
            .all()
            // @ts-expect-error
            .map(t => t[fieldName])
            .filter(t => (0, mobx_state_tree_1.isType)(t) && (0, mobx_state_tree_1.isModelType)(t));
        // try to smooth over the case when no types are registered, mostly
        // encountered in tests
        if (pluggableTypes.length === 0 && typeof jest === 'undefined') {
            console.warn(`No pluggable types found matching ('${groupName}','${fieldName}')`);
            return fallback;
        }
        return mobx_state_tree_1.types.union(...pluggableTypes);
    }
    /** get a MST type for the union of all specified pluggable config schemas */
    pluggableConfigSchemaType(typeGroup, fieldName = 'configSchema') {
        const pluggableTypes = this.getElementTypeRecord(typeGroup)
            .all()
            // @ts-expect-error
            .map(t => t[fieldName])
            .filter(t => (0, configuration_1.isBareConfigurationSchemaType)(t));
        if (pluggableTypes.length === 0) {
            pluggableTypes.push((0, configuration_1.ConfigurationSchema)('Null', {}));
        }
        return mobx_state_tree_1.types.union(...pluggableTypes);
    }
    getRendererType(typeName) {
        return this.rendererTypes.get(typeName);
    }
    getRendererTypes() {
        return this.rendererTypes.all();
    }
    getAdapterType(typeName) {
        return this.adapterTypes.get(typeName);
    }
    getTextSearchAdapterType(typeName) {
        return this.textSearchAdapterTypes.get(typeName);
    }
    getTrackType(typeName) {
        return this.trackTypes.get(typeName);
    }
    getDisplayType(typeName) {
        return this.displayTypes.get(typeName);
    }
    getViewType(typeName) {
        return this.viewTypes.get(typeName);
    }
    getAddTrackWorkflow(typeName) {
        return this.addTrackWidgets.get(typeName);
    }
    getWidgetType(typeName) {
        return this.widgetTypes.get(typeName);
    }
    getConnectionType(typeName) {
        return this.connectionTypes.get(typeName);
    }
    getRpcMethodType(methodName) {
        return this.rpcMethods.get(methodName);
    }
    getInternetAccountType(name) {
        return this.internetAccountTypes.get(name);
    }
    addRendererType(cb) {
        return this.addElementType('renderer', cb);
    }
    addAdapterType(cb) {
        return this.addElementType('adapter', cb);
    }
    addTextSearchAdapterType(cb) {
        return this.addElementType('text search adapter', cb);
    }
    addTrackType(cb) {
        // Goes through the already-created displays and registers the ones that
        // specify this track type
        const callback = () => {
            const track = cb(this);
            const displays = this.getElementTypesInGroup('display');
            displays.forEach(display => {
                // track may have already added the displayType in its cb
                if (display.trackType === track.name &&
                    !track.displayTypes.includes(display)) {
                    track.addDisplayType(display);
                }
            });
            return track;
        };
        return this.addElementType('track', callback);
    }
    addDisplayType(cb) {
        return this.addElementType('display', cb);
    }
    addViewType(cb) {
        const callback = () => {
            const newView = cb(this);
            const displays = this.getElementTypesInGroup('display');
            displays.forEach(display => {
                // view may have already added the displayType in its callback
                // see ViewType for description of extendedName
                if ((display.viewType === newView.name ||
                    display.viewType === newView.extendedName) &&
                    !newView.displayTypes.includes(display)) {
                    newView.addDisplayType(display);
                }
            });
            return newView;
        };
        return this.addElementType('view', callback);
    }
    addWidgetType(cb) {
        return this.addElementType('widget', cb);
    }
    addConnectionType(cb) {
        return this.addElementType('connection', cb);
    }
    addRpcMethod(cb) {
        return this.addElementType('rpc method', cb);
    }
    addInternetAccountType(cb) {
        return this.addElementType('internet account', cb);
    }
    addAddTrackWorkflowType(cb) {
        return this.addElementType('add track workflow', cb);
    }
    addToExtensionPoint(extensionPointName, callback) {
        let callbacks = this.extensionPoints.get(extensionPointName);
        if (!callbacks) {
            callbacks = [];
            this.extensionPoints.set(extensionPointName, callbacks);
        }
        callbacks.push(callback);
    }
    evaluateExtensionPoint(extensionPointName, extendee, props) {
        const callbacks = this.extensionPoints.get(extensionPointName);
        let accumulator = extendee;
        if (callbacks) {
            for (const callback of callbacks) {
                try {
                    accumulator = callback(accumulator, props);
                }
                catch (error) {
                    console.error(error);
                }
            }
        }
        return accumulator;
    }
    async evaluateAsyncExtensionPoint(extensionPointName, extendee, props) {
        const callbacks = this.extensionPoints.get(extensionPointName);
        let accumulator = extendee;
        if (callbacks) {
            for (const callback of callbacks) {
                try {
                    accumulator = await callback(accumulator, props);
                }
                catch (error) {
                    console.error(error);
                }
            }
        }
        return accumulator;
    }
}
exports.default = PluginManager;
