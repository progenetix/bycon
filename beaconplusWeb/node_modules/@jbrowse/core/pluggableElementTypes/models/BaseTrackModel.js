"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBaseTrackModel = exports.getCompatibleDisplays = void 0;
const mobx_1 = require("mobx");
const mobx_state_tree_1 = require("mobx-state-tree");
// locals
const configuration_1 = require("../../configuration");
const util_1 = require("../../util");
const types_1 = require("../../util/types");
const mst_1 = require("../../util/types/mst");
function getCompatibleDisplays(self) {
    const { pluginManager } = (0, util_1.getEnv)(self);
    const view = (0, util_1.getContainingView)(self);
    const viewType = pluginManager.getViewType(view.type);
    const compatTypes = new Set(viewType.displayTypes.map(d => d.name));
    const displays = self.configuration.displays;
    return displays.filter(d => compatTypes.has(d.type));
}
exports.getCompatibleDisplays = getCompatibleDisplays;
/**
 * #stateModel BaseTrackModel
 * #category track
 *
 * these MST models only exist for tracks that are *shown*. they should contain
 * only UI state for the track, and have a reference to a track configuration.
 * note that multiple displayed tracks could use the same configuration.
 */
function createBaseTrackModel(pm, trackType, baseTrackConfig) {
    return mobx_state_tree_1.types
        .model(trackType, {
        /**
         * #property
         */
        id: mst_1.ElementId,
        /**
         * #property
         */
        type: mobx_state_tree_1.types.literal(trackType),
        /**
         * #property
         */
        configuration: (0, configuration_1.ConfigurationReference)(baseTrackConfig),
        /**
         * #property
         */
        minimized: false,
        /**
         * #property
         */
        displays: mobx_state_tree_1.types.array(pm.pluggableMstType('display', 'stateModel')),
    })
        .views(self => ({
        /**
         * #getter
         * determines which webworker to send the track to, currently based on trackId
         */
        get rpcSessionId() {
            var _a;
            return (_a = self.configuration) === null || _a === void 0 ? void 0 : _a.trackId;
        },
        /**
         * #getter
         */
        get name() {
            return (0, configuration_1.getConf)(self, 'name');
        },
        /**
         * #getter
         */
        get textSearchAdapter() {
            return (0, configuration_1.getConf)(self, 'textSearchAdapter');
        },
        /**
         * #getter
         */
        get adapterType() {
            const adapterConfig = (0, configuration_1.getConf)(self, 'adapter');
            if (!adapterConfig) {
                throw new Error(`no adapter configuration provided for ${self.type}`);
            }
            const adapterType = pm.getAdapterType(adapterConfig.type);
            if (!adapterType) {
                throw new Error(`unknown adapter type ${adapterConfig.type}`);
            }
            return adapterType;
        },
        /**
         * #getter
         */
        get viewMenuActions() {
            return self.displays.flatMap(d => d.viewMenuActions);
        },
        /**
         * #getter
         */
        get canConfigure() {
            const session = (0, util_1.getSession)(self);
            const { sessionTracks, adminMode } = session;
            return ((0, types_1.isSessionModelWithConfigEditing)(session) &&
                (adminMode ||
                    (sessionTracks === null || sessionTracks === void 0 ? void 0 : sessionTracks.find(t => { var _a; return t.trackId === ((_a = self.configuration) === null || _a === void 0 ? void 0 : _a.trackId); }))));
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        setMinimized(flag) {
            self.minimized = flag;
        },
        /**
         * #action
         */
        showDisplay(displayId, initialSnapshot = {}) {
            const schema = pm.pluggableConfigSchemaType('display');
            const conf = (0, mobx_state_tree_1.resolveIdentifier)(schema, (0, mobx_state_tree_1.getRoot)(self), displayId);
            const displayType = pm.getDisplayType(conf.type);
            if (!displayType) {
                throw new Error(`unknown display type ${conf.type}`);
            }
            const display = displayType.stateModel.create({
                ...initialSnapshot,
                type: conf.type,
                configuration: conf,
            });
            self.displays.push(display);
        },
        /**
         * #action
         */
        hideDisplay(displayId) {
            const schema = pm.pluggableConfigSchemaType('display');
            const conf = (0, mobx_state_tree_1.resolveIdentifier)(schema, (0, mobx_state_tree_1.getRoot)(self), displayId);
            const t = self.displays.filter(d => d.configuration === conf);
            (0, mobx_1.transaction)(() => t.forEach(d => self.displays.remove(d)));
            return t.length;
        },
        /**
         * #action
         */
        replaceDisplay(oldId, newId, initialSnapshot = {}) {
            const idx = self.displays.findIndex(d => d.configuration.displayId === oldId);
            if (idx === -1) {
                throw new Error(`could not find display id ${oldId} to replace`);
            }
            const schema = pm.pluggableConfigSchemaType('display');
            const conf = (0, mobx_state_tree_1.resolveIdentifier)(schema, (0, mobx_state_tree_1.getRoot)(self), newId);
            const displayType = pm.getDisplayType(conf.type);
            if (!displayType) {
                throw new Error(`unknown display type ${conf.type}`);
            }
            self.displays.splice(idx, 1, {
                ...initialSnapshot,
                type: conf.type,
                configuration: conf,
            });
        },
    }))
        .views(self => ({
        /**
         * #method
         */
        trackMenuItems() {
            const menuItems = self.displays.flatMap(d => d.trackMenuItems());
            const shownId = self.displays[0].configuration.displayId;
            const compatDisp = getCompatibleDisplays(self);
            return [
                ...menuItems,
                ...(compatDisp.length > 1
                    ? [
                        {
                            type: 'subMenu',
                            label: 'Display types',
                            subMenu: compatDisp.map(d => ({
                                type: 'radio',
                                label: pm.getDisplayType(d.type).displayName,
                                checked: d.displayId === shownId,
                                onClick: () => self.replaceDisplay(shownId, d.displayId),
                            })),
                        },
                    ]
                    : []),
            ];
        },
    }));
}
exports.createBaseTrackModel = createBaseTrackModel;
