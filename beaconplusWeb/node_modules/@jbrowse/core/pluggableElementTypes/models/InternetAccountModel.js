"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternetAccount = void 0;
const mobx_state_tree_1 = require("mobx-state-tree");
const configuration_1 = require("../../configuration");
const io_1 = require("../../util/io");
const mst_1 = require("../../util/types/mst");
const baseInternetAccountConfig_1 = require("./baseInternetAccountConfig");
const inWebWorker = typeof sessionStorage === 'undefined';
/**
 * #stateModel BaseInternetAccountModel
 * #category internetAccount
 */
function x() { } // eslint-disable-line @typescript-eslint/no-unused-vars
exports.InternetAccount = mobx_state_tree_1.types
    .model('InternetAccount', {
    /**
     * #property
     */
    id: mst_1.ElementId,
    /**
     * #property
     */
    type: mobx_state_tree_1.types.string,
    /**
     * #property
     */
    configuration: (0, configuration_1.ConfigurationReference)(baseInternetAccountConfig_1.BaseInternetAccountConfig),
})
    .views(self => ({
    /**
     * #getter
     */
    get name() {
        return (0, configuration_1.getConf)(self, 'name');
    },
    /**
     * #getter
     */
    get description() {
        return (0, configuration_1.getConf)(self, 'description');
    },
    /**
     * #getter
     */
    get internetAccountId() {
        return (0, configuration_1.getConf)(self, 'internetAccountId'); // NOTE: this is the explicitIdentifier of the config schema
    },
    /**
     * #getter
     */
    get authHeader() {
        return (0, configuration_1.getConf)(self, 'authHeader');
    },
    /**
     * #getter
     */
    get tokenType() {
        return (0, configuration_1.getConf)(self, 'tokenType');
    },
    /**
     * #getter
     */
    get domains() {
        return (0, configuration_1.getConf)(self, 'domains');
    },
    /**
     * #getter
     * Can use this to customize what is displayed in fileSelector's toggle box
     */
    get toggleContents() {
        return null;
    },
    /**
     * #getter
     * Can use this to customize what the fileSelector. It takes a prop called
     * `setLocation` that should be used to set a UriLocation
     */
    get SelectorComponent() {
        return undefined;
    },
    /**
     * #getter
     * Can use this to add a label to the UrlChooser. Has no effect if a custom
     * SelectorComponent is supplied
     */
    get selectorLabel() {
        return undefined;
    },
}))
    .views(self => ({
    /**
     * #method
     * Determine whether this internetAccount provides credentials for a URL
     * @param location  - UriLocation of resource
     * @returns true or false
     */
    handlesLocation(location) {
        return self.domains.some(domain => location === null || location === void 0 ? void 0 : location.uri.includes(domain));
    },
    /**
     * #getter
     * The key used to store this internetAccount's token in sessionStorage
     */
    get tokenKey() {
        return `${self.internetAccountId}-token`;
    },
}))
    .actions(self => ({
    /**
     * #action
     * Must be implemented by a model extending or composing this one. Pass the
     * user's token to `resolve`.
     * @param resolve - Pass the token to this function
     * @param reject - If there is an error getting the token, call this function
     */
    getTokenFromUser(_resolve, _reject) {
        throw new Error('getTokenFromUser must be implemented by extending model');
    },
    /**
     * #action
     */
    storeToken(token) {
        sessionStorage.setItem(self.tokenKey, token);
    },
    /**
     * #action
     */
    removeToken() {
        sessionStorage.removeItem(self.tokenKey);
    },
    /**
     * #action
     */
    retrieveToken() {
        return sessionStorage.getItem(self.tokenKey);
    },
    /**
     * #action
     * This can be used by an internetAccount to validate a token works before
     * it is used. This is run when preAuthorizationInformation is requested,
     * so it can be used to check that a token is valid before sending it to a
     * worker thread. It expects the token to be returned so that this action
     * can also be used to generate a new token (e.g. by using a refresh token)
     * if the original one was invalid. Should throw an error if a token is
     * invalid.
     *
     * @param token - Auth token
     * @param loc - UriLocation of the resource
     * @returns - Valid auth token
     */
    async validateToken(token, _loc) {
        return token;
    },
}))
    .actions(self => {
    let tokenPromise = undefined;
    return {
        /**
         * #action
         * Try to get the token from the location pre-auth, from local storage,
         * or from a previously cached promise. If token is not available, uses
         * `getTokenFromUser`.
         *
         * @param location - UriLocation of the resource
         * @returns A promise for the token
         */
        async getToken(location) {
            var _a, _b;
            if (tokenPromise) {
                return tokenPromise;
            }
            let token = (_b = (_a = location === null || location === void 0 ? void 0 : location.internetAccountPreAuthorization) === null || _a === void 0 ? void 0 : _a.authInfo) === null || _b === void 0 ? void 0 : _b.token;
            if (token) {
                tokenPromise = Promise.resolve(token);
                return tokenPromise;
            }
            if (inWebWorker) {
                throw new Error('Did not get internet account pre-authorization info in worker');
            }
            token = self.retrieveToken();
            if (token) {
                tokenPromise = Promise.resolve(token);
                return tokenPromise;
            }
            tokenPromise = new Promise((resolve, reject) => self.getTokenFromUser(token => {
                self.storeToken(token);
                resolve(token);
            }, error => {
                self.removeToken();
                reject(error);
            }));
            return tokenPromise;
        },
    };
})
    .actions(self => ({
    /**
     * #action
     */
    addAuthHeaderToInit(init = {}, token) {
        return {
            ...init,
            headers: new Headers({
                ...init.headers,
                [self.authHeader]: self.tokenType
                    ? `${self.tokenType} ${token}`
                    : token,
            }),
        };
    },
    /**
     * #action
     * Gets the token and returns it along with the information needed to
     * create a new internetAccount.
     *
     * @param location - UriLocation of the resource
     * @returns
     */
    async getPreAuthorizationInformation(location) {
        const authToken = await self.getToken(location);
        let validatedToken;
        try {
            validatedToken = await self.validateToken(authToken, location);
        }
        catch (error) {
            self.removeToken();
            throw error;
        }
        return {
            internetAccountType: self.type,
            authInfo: {
                token: validatedToken,
                configuration: (0, configuration_1.getConf)(self),
            },
        };
    },
}))
    .actions(self => ({
    /**
     * #action
     * Get a fetch method that will add any needed authentication headers to
     * the request before sending it. If location is provided, it will be
     * checked to see if it includes a token in it pre-auth information.
     *
     * @param loc - UriLocation of the resource
     * @returns A function that can be used to fetch
     */
    getFetcher(loc) {
        return async (input, init) => {
            const authToken = await self.getToken(loc);
            const newInit = self.addAuthHeaderToInit(init, authToken);
            return fetch(input, newInit);
        };
    },
}))
    .actions(self => ({
    /**
     * #action
     * Gets a filehandle that uses a fetch that adds auth headers
     * @param location - UriLocation of the resource
     * @returns A filehandle
     */
    openLocation(location) {
        return new io_1.RemoteFileWithRangeCache(location.uri, {
            fetch: self.getFetcher(location),
        });
    },
}));
