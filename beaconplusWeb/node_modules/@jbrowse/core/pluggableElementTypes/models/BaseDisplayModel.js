"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseDisplay = void 0;
const mobx_state_tree_1 = require("mobx-state-tree");
// locals
const configuration_1 = require("../../configuration");
const tracks_1 = require("../../util/tracks");
const util_1 = require("../../util");
const mst_1 = require("../../util/types/mst");
/**
 * #stateModel BaseDisplay
 * #category display
 */
function stateModelFactory() {
    return mobx_state_tree_1.types
        .model('BaseDisplay', {
        /**
         * #property
         */
        id: mst_1.ElementId,
        /**
         * #property
         */
        type: mobx_state_tree_1.types.string,
        /**
         * #property
         */
        rpcDriverName: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
    })
        .volatile(() => ({
        rendererTypeName: '',
        error: undefined,
        message: undefined,
    }))
        .views(self => ({
        /**
         * #getter
         */
        get RenderingComponent() {
            const { pluginManager } = (0, util_1.getEnv)(self);
            const displayType = pluginManager.getDisplayType(self.type);
            return displayType.ReactComponent;
        },
        /**
         * #getter
         */
        get DisplayBlurb() {
            return null;
        },
        /**
         * #getter
         */
        get adapterConfig() {
            return (0, configuration_1.getConf)(this.parentTrack, 'adapter');
        },
        /**
         * #getter
         */
        get parentTrack() {
            let track = (0, mobx_state_tree_1.getParent)(self);
            while (!(track.configuration && (0, configuration_1.getConf)(track, 'trackId'))) {
                if ((0, mobx_state_tree_1.isRoot)(track)) {
                    throw new Error(`No parent track found for ${self.type} ${self.id}`);
                }
                track = (0, mobx_state_tree_1.getParent)(track);
            }
            return track;
        },
        /**
         * #method
         * the react props that are passed to the Renderer when data
         * is rendered in this display
         */
        renderProps() {
            return {
                ...(0, tracks_1.getParentRenderProps)(self),
                notReady: (0, util_1.getContainingView)(self).minimized,
                rpcDriverName: self.rpcDriverName,
                displayModel: self,
            };
        },
        /**
         * #getter
         * the pluggable element type object for this display's
         * renderer
         */
        get rendererType() {
            const { pluginManager } = (0, util_1.getEnv)(self);
            const RendererType = pluginManager.getRendererType(self.rendererTypeName);
            if (!RendererType) {
                throw new Error(`renderer "${self.rendererTypeName}" not found`);
            }
            if (!RendererType.ReactComponent) {
                throw new Error(`renderer ${self.rendererTypeName} has no ReactComponent, it may not be completely implemented yet`);
            }
            return RendererType;
        },
        /**
         * #getter
         * if a display-level message should be displayed instead,
         * make this return a react component
         */
        get DisplayMessageComponent() {
            return undefined;
        },
        /**
         * #method
         */
        trackMenuItems() {
            return [];
        },
        /**
         * #getter
         */
        get viewMenuActions() {
            return [];
        },
        /**
         * #method
         * @param region -
         * @returns falsy if the region is fine to try rendering. Otherwise,
         *  return a react node + string of text.
         *  string of text describes why it cannot be rendered
         *  react node allows user to force load at current setting
         */
        regionCannotBeRendered( /* region */) {
            return null;
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        setMessage(arg) {
            self.message = arg;
        },
        /**
         * #action
         */
        setError(error) {
            self.error = error;
        },
        /**
         * #action
         */
        setRpcDriverName(rpcDriverName) {
            self.rpcDriverName = rpcDriverName;
        },
        /**
         * #action
         * base display reload does nothing, see specialized displays for details
         */
        reload() { },
    }));
}
exports.BaseDisplay = stateModelFactory();
