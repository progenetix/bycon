"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseViewModelWithDisplayedRegions = void 0;
const mobx_state_tree_1 = require("mobx-state-tree");
const mst_1 = require("../../util/types/mst");
const mst_2 = require("../../util/types/mst");
/**
 * #stateModel BaseViewModel
 * #category view
 */
function x() { } // eslint-disable-line @typescript-eslint/no-unused-vars
const BaseViewModel = mobx_state_tree_1.types
    .model('BaseView', {
    /**
     * #property
     */
    id: mst_1.ElementId,
    /**
     * #property
     * displayName is displayed in the header of the view, or assembly names
     * being used if none is specified
     */
    displayName: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
    /**
     * #property
     */
    minimized: false,
})
    .volatile(() => ({
    width: 800,
}))
    .views(() => ({
    /**
     * #getter
     */
    menuItems() {
        return [];
    },
}))
    .actions(self => ({
    /**
     * #action
     */
    setDisplayName(name) {
        self.displayName = name;
    },
    /**
     * #action
     * width is an important attribute of the view model, when it becomes set, it
     * often indicates when the app can start drawing to it. certain views like
     * lgv are strict about this because if it tries to draw before it knows the
     * width it should draw to, it may start fetching data for regions it doesn't
     * need to
     *
     * setWidth is updated by a ResizeObserver generally, the views often need
     * to know how wide they are to properly draw genomic regions
     */
    setWidth(newWidth) {
        self.width = newWidth;
    },
    /**
     * #action
     */
    setMinimized(flag) {
        self.minimized = flag;
    },
}));
exports.default = BaseViewModel;
exports.BaseViewModelWithDisplayedRegions = BaseViewModel.props({
    displayedRegions: mobx_state_tree_1.types.array(mst_2.Region),
});
