import React from 'react';
import { Instance } from 'mobx-state-tree';
import { RemoteFileWithRangeCache } from '../../util/io';
import { UriLocation, AnyReactComponentType } from '../../util/types';
export declare const InternetAccount: import("mobx-state-tree").IModelType<{
    /**
     * #property
     */
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    /**
     * #property
     */
    type: import("mobx-state-tree").ISimpleType<string>;
    /**
     * #property
     */
    configuration: import("../../configuration/configurationSchema").ConfigurationSchemaType<{
        name: {
            description: string;
            type: string;
            defaultValue: string;
        };
        description: {
            description: string;
            type: string;
            defaultValue: string;
        };
        authHeader: {
            description: string;
            type: string;
            defaultValue: string;
        };
        tokenType: {
            description: string;
            type: string;
            defaultValue: string;
        };
        domains: {
            description: string;
            type: string;
            defaultValue: never[];
        };
    }, import("../../configuration/configurationSchema").ConfigurationSchemaOptions<undefined, "internetAccountId">>;
}, {
    /**
     * #getter
     */
    readonly name: string;
    /**
     * #getter
     */
    readonly description: string;
    /**
     * #getter
     */
    readonly internetAccountId: string;
    /**
     * #getter
     */
    readonly authHeader: string;
    /**
     * #getter
     */
    readonly tokenType: string;
    /**
     * #getter
     */
    readonly domains: string[];
    /**
     * #getter
     * Can use this to customize what is displayed in fileSelector's toggle box
     */
    readonly toggleContents: React.ReactNode;
    /**
     * #getter
     * Can use this to customize what the fileSelector. It takes a prop called
     * `setLocation` that should be used to set a UriLocation
     */
    readonly SelectorComponent: AnyReactComponentType | undefined;
    /**
     * #getter
     * Can use this to add a label to the UrlChooser. Has no effect if a custom
     * SelectorComponent is supplied
     */
    readonly selectorLabel: string | undefined;
} & {
    /**
     * #method
     * Determine whether this internetAccount provides credentials for a URL
     * @param location  - UriLocation of resource
     * @returns true or false
     */
    handlesLocation(location: UriLocation): boolean;
    /**
     * #getter
     * The key used to store this internetAccount's token in sessionStorage
     */
    readonly tokenKey: string;
} & {
    /**
     * #action
     * Must be implemented by a model extending or composing this one. Pass the
     * user's token to `resolve`.
     * @param resolve - Pass the token to this function
     * @param reject - If there is an error getting the token, call this function
     */
    getTokenFromUser(_resolve: (token: string) => void, _reject: (error: Error) => void): void;
    /**
     * #action
     */
    storeToken(token: string): void;
    /**
     * #action
     */
    removeToken(): void;
    /**
     * #action
     */
    retrieveToken(): string | null;
    /**
     * #action
     * This can be used by an internetAccount to validate a token works before
     * it is used. This is run when preAuthorizationInformation is requested,
     * so it can be used to check that a token is valid before sending it to a
     * worker thread. It expects the token to be returned so that this action
     * can also be used to generate a new token (e.g. by using a refresh token)
     * if the original one was invalid. Should throw an error if a token is
     * invalid.
     *
     * @param token - Auth token
     * @param loc - UriLocation of the resource
     * @returns - Valid auth token
     */
    validateToken(token: string, _loc: UriLocation): Promise<string>;
} & {
    /**
     * #action
     * Try to get the token from the location pre-auth, from local storage,
     * or from a previously cached promise. If token is not available, uses
     * `getTokenFromUser`.
     *
     * @param location - UriLocation of the resource
     * @returns A promise for the token
     */
    getToken(location?: UriLocation): Promise<string>;
} & {
    /**
     * #action
     */
    addAuthHeaderToInit(init: RequestInit | undefined, token: string): {
        headers: Headers;
        body?: BodyInit | null | undefined;
        cache?: RequestCache | undefined;
        credentials?: RequestCredentials | undefined;
        integrity?: string | undefined;
        keepalive?: boolean | undefined;
        method?: string | undefined;
        mode?: RequestMode | undefined;
        priority?: RequestPriority | undefined;
        redirect?: RequestRedirect | undefined;
        referrer?: string | undefined;
        referrerPolicy?: ReferrerPolicy | undefined;
        signal?: AbortSignal | null | undefined;
        window?: null | undefined;
    };
    /**
     * #action
     * Gets the token and returns it along with the information needed to
     * create a new internetAccount.
     *
     * @param location - UriLocation of the resource
     * @returns
     */
    getPreAuthorizationInformation(location: UriLocation): Promise<{
        internetAccountType: string;
        authInfo: {
            token: string;
            configuration: any;
        };
    }>;
} & {
    /**
     * #action
     * Get a fetch method that will add any needed authentication headers to
     * the request before sending it. If location is provided, it will be
     * checked to see if it includes a token in it pre-auth information.
     *
     * @param loc - UriLocation of the resource
     * @returns A function that can be used to fetch
     */
    getFetcher(loc?: UriLocation): (input: RequestInfo, init?: RequestInit) => Promise<Response>;
} & {
    /**
     * #action
     * Gets a filehandle that uses a fetch that adds auth headers
     * @param location - UriLocation of the resource
     * @returns A filehandle
     */
    openLocation(location: UriLocation): RemoteFileWithRangeCache;
}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
export type BaseInternetAccountStateModel = typeof InternetAccount;
export type BaseInternetAccountModel = Instance<BaseInternetAccountStateModel>;
