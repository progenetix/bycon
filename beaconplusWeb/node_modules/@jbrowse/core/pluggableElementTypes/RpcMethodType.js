"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const map_obj_1 = __importDefault(require("../util/map-obj"));
const PluggableElementBase_1 = __importDefault(require("./PluggableElementBase"));
const tracks_1 = require("../util/tracks");
const types_1 = require("../util/types");
const remoteAbortSignals_1 = require("../rpc/remoteAbortSignals");
class RpcMethodType extends PluggableElementBase_1.default {
    constructor(pluginManager) {
        super({});
        this.pluginManager = pluginManager;
    }
    async serializeArguments(args, rpcDriverClassName) {
        const blobMap = (0, tracks_1.getBlobMap)();
        await this.augmentLocationObjects(args, rpcDriverClassName);
        return { ...args, blobMap };
    }
    async serializeNewAuthArguments(loc, rpcDriverClassName) {
        const rootModel = this.pluginManager.rootModel;
        // args dont need auth or already have auth
        if (!(0, types_1.isAppRootModel)(rootModel) || loc.internetAccountPreAuthorization) {
            return loc;
        }
        const account = rootModel.findAppropriateInternetAccount(loc);
        // mutating loc object is not allowed in MainThreadRpcDriver, and is only
        // needed for web worker RPC
        if (account && rpcDriverClassName !== 'MainThreadRpcDriver') {
            loc.internetAccountPreAuthorization =
                await account.getPreAuthorizationInformation(loc);
        }
        return loc;
    }
    async deserializeArguments(serializedArgs, _rpcDriverClassName) {
        if (serializedArgs.blobMap) {
            (0, tracks_1.setBlobMap)(serializedArgs.blobMap);
        }
        const { signal } = serializedArgs;
        return {
            ...serializedArgs,
            signal: (0, remoteAbortSignals_1.isRemoteAbortSignal)(signal)
                ? (0, remoteAbortSignals_1.deserializeAbortSignal)(signal)
                : undefined,
        };
    }
    async serializeReturn(originalReturn, _args, _rpcDriverClassName) {
        return originalReturn;
    }
    async deserializeReturn(serializedReturn, _args, _rpcDriverClassName) {
        var _a;
        let r;
        try {
            r = await serializedReturn;
        }
        catch (error) {
            if ((0, types_1.isAuthNeededException)(error)) {
                const retryAccount = // @ts-expect-error
                 (_a = this.pluginManager.rootModel) === null || _a === void 0 ? void 0 : _a.createEphemeralInternetAccount(`HTTPBasicInternetAccount-${new URL(error.url).origin}`, {}, error.url);
                throw new types_1.RetryError('Retrying with created internet account', retryAccount.internetAccountId);
            }
            throw error;
        }
        return r;
    }
    async augmentLocationObjects(thing, rpcDriverClassName) {
        const uris = [];
        // using map-obj avoids cycles, seen in circular view svg export
        (0, map_obj_1.default)(thing, val => {
            if ((0, types_1.isUriLocation)(val)) {
                uris.push(val);
            }
        });
        for (const uri of uris) {
            await this.serializeNewAuthArguments(uri, rpcDriverClassName);
        }
        return thing;
    }
}
exports.default = RpcMethodType;
