import { Feature, SimpleFeatureSerialized } from '../../util/simpleFeature';
import { AugmentedRegion as Region } from '../../util/types';
import ServerSideRendererType, { RenderArgs as ServerSideRenderArgs, RenderArgsSerialized as ServerSideRenderArgsSerialized, RenderArgsDeserialized as ServerSideRenderArgsDeserialized, RenderResults as ServerSideRenderResults, ResultsDeserialized as ServerSideResultsDeserialized, ResultsSerialized as ServerSideResultsSerialized } from './ServerSideRendererType';
import { AnyConfigurationModel } from '../../configuration';
export interface RenderArgs extends ServerSideRenderArgs {
    displayModel: {
        id: string;
        selectedFeatureId?: string;
    };
    regions: Region[];
    blockKey: string;
}
export interface RenderArgsSerialized extends ServerSideRenderArgsSerialized {
    displayModel: {
        id: string;
        selectedFeatureId?: string;
    };
    regions: Region[];
    blockKey: string;
}
export interface RenderArgsDeserialized extends ServerSideRenderArgsDeserialized {
    displayModel: {
        id: string;
        selectedFeatureId?: string;
    };
    regions: Region[];
    blockKey: string;
    adapterConfig: AnyConfigurationModel;
}
export interface RenderResults extends ServerSideRenderResults {
    features: Map<string, Feature>;
}
export interface ResultsSerialized extends ServerSideResultsSerialized {
    features: SimpleFeatureSerialized[];
}
export interface ResultsDeserialized extends ServerSideResultsDeserialized {
    features: Map<string, Feature>;
    blockKey: string;
}
export default class FeatureRendererType extends ServerSideRendererType {
    /**
     * replaces the `displayModel` param (which on the client is a MST model)
     * with a stub that only contains the `selectedFeature`, since this is the only
     * part of the track model that most renderers read. also serializes the config
     * and regions to JSON from MST objects.
     *
     * @param args - the arguments passed to render
     */
    serializeArgsInClient(args: RenderArgs): ServerSideRenderArgsSerialized;
    /**
     * Adds feature deserialization to base server-side result deserialization
     *
     * @param results - the results of the render
     * @param args - the arguments passed to render
     */
    deserializeResultsInClient(result: ResultsSerialized, args: RenderArgs): ResultsDeserialized;
    /**
     * Adds feature serialization to base server-side result serialization
     *
     * @param result - object containing the results of calling the `render`
     * method
     * @param args - deserialized render args
     */
    serializeResultsInWorker(result: RenderResults, args: RenderArgsDeserialized): ResultsSerialized;
    /**
     * will expand if soft clipping or feature glyphs are shown
     *
     * @param region - rendering region
     * @param _renderArgs - render args, unused, may be used in deriving classes
     */
    getExpandedRegion(region: Region, _renderArgs: RenderArgsDeserialized): Region;
    /**
     * use the dataAdapter to fetch the features to be rendered
     *
     * @param renderArgs -
     * @returns Map of features as `{ id => feature, ... }`
     */
    getFeatures(renderArgs: RenderArgsDeserialized): Promise<Map<string, Feature>>;
    /**
     * @param renderArgs -
     * @param feature -
     * @returns true if this feature passes all configured filters
     */
    featurePassesFilters(renderArgs: RenderArgsDeserialized, feature: Feature): boolean;
    /**
     * gets features and renders
     *
     * @param props - render args
     */
    render(props: RenderArgsDeserialized & {
        features?: Map<string, Feature>;
    }): Promise<RenderResults>;
}
