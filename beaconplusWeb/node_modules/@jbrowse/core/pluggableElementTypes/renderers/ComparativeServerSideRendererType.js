"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-explicit-any */
const operators_1 = require("rxjs/operators");
const ServerSideRendererType_1 = __importDefault(require("./ServerSideRendererType"));
const dataAdapterCache_1 = require("../../data_adapters/dataAdapterCache");
const util_1 = require("../../util");
const rxjs_1 = require("rxjs");
function isSvgExport(e) {
    return 'canvasRecordedData' in e;
}
class ComparativeServerSideRenderer extends ServerSideRendererType_1.default {
    /**
     * directly modifies the render arguments to prepare
     * them to be serialized and sent to the worker.
     *
     * the base class replaces the `displayModel` param
     * (which on the client is a MST model) with a stub
     * that only contains the `selectedFeature`, since
     * this is the only part of the track model that most
     * renderers read.
     *
     * @param args - the arguments passed to render
     * @returns the same object
     */
    async renameRegionsIfNeeded(args) {
        return args;
    }
    serializeArgsInClient(args) {
        const deserializedArgs = {
            ...args,
            displayModel: {},
        };
        return super.serializeArgsInClient(deserializedArgs);
    }
    // deserialize some of the results that came back from the worker
    deserializeResultsInClient(result, args) {
        const deserialized = super.deserializeResultsInClient(result, args);
        return { ...deserialized, blockKey: args.blockKey };
    }
    /**
     * Render method called on the client. Serializes args, then
     * calls `render` with the RPC manager.
     */
    async renderInClient(rpcManager, args) {
        const results = (await rpcManager.call(args.sessionId, 'ComparativeRender', args));
        if (isSvgExport(results)) {
            results.html = await (0, util_1.getSerializedSvg)(results);
            delete results.reactElement;
        }
        return results;
    }
    /**
     * @param renderArgs -
     * @param feature -
     * @returns true if this feature passes all configured filters
     */
    featurePassesFilters(renderArgs, feature) {
        return renderArgs.filters
            ? renderArgs.filters.passes(feature, renderArgs)
            : true;
    }
    async getFeatures(renderArgs) {
        const pm = this.pluginManager;
        const { sessionId, adapterConfig } = renderArgs;
        const { dataAdapter } = await (0, dataAdapterCache_1.getAdapter)(pm, sessionId, adapterConfig);
        const regions = renderArgs.regions;
        if (!regions || regions.length === 0) {
            console.warn('no regions supplied to comparative renderer');
            return [];
        }
        const requestRegions = regions.map(r => {
            // make sure the requested region's start and end are integers, if
            // there is a region specification.
            const requestRegion = { ...r };
            if (requestRegion.start) {
                requestRegion.start = Math.floor(requestRegion.start);
            }
            if (requestRegion.end) {
                requestRegion.end = Math.floor(requestRegion.end);
            }
            return requestRegion;
        });
        // note that getFeaturesInMultipleRegions does not do glyph expansion
        const res = await (0, rxjs_1.firstValueFrom)(dataAdapter
            .getFeaturesInMultipleRegions(requestRegions, renderArgs)
            .pipe((0, operators_1.filter)(f => this.featurePassesFilters(renderArgs, f)), (0, operators_1.toArray)()));
        // dedupe needed xref https://github.com/GMOD/jbrowse-components/pull/3404/
        return (0, util_1.dedupe)(res, f => f.id());
    }
}
exports.default = ComparativeServerSideRenderer;
