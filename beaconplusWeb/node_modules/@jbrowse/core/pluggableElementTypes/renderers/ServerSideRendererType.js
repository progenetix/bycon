"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const styles_1 = require("@mui/material/styles");
const server_1 = require("react-dom/server");
const mobx_state_tree_1 = require("mobx-state-tree");
// locals
const util_1 = require("../../util");
const serializableFilterChain_1 = __importDefault(require("./util/serializableFilterChain"));
const ui_1 = require("../../ui");
const RendererType_1 = __importDefault(require("./RendererType"));
const ServerSideRenderedContent_1 = __importDefault(require("./ServerSideRenderedContent"));
function isSvgExport(e) {
    return 'canvasRecordedData' in e;
}
class ServerSideRenderer extends RendererType_1.default {
    /**
     * directly modifies the render arguments to prepare them to be serialized and
     * sent to the worker.
     *
     * @param args - the arguments passed to render
     * @returns the same object
     */
    serializeArgsInClient(args) {
        var _a;
        return {
            ...args,
            config: (0, mobx_state_tree_1.isStateTreeNode)(args.config)
                ? (0, mobx_state_tree_1.getSnapshot)(args.config)
                : args.config,
            filters: (_a = args.filters) === null || _a === void 0 ? void 0 : _a.toJSON().filters,
        };
    }
    /**
     * Deserialize the render results from the worker in the client. Includes
     * hydrating of the React HTML string, and not hydrating the result if SVG is
     * being rendered
     *
     * @param results - the results of the render
     * @param args - the arguments passed to render
     */
    deserializeResultsInClient(res, args) {
        // if we are rendering svg, we skip hydration
        if (args.exportSVG) {
            // only return the res if the renderer explicitly has
            // this.supportsSVG support to avoid garbage being rendered in SVG
            // document
            return {
                ...res,
                html: this.supportsSVG
                    ? res.html
                    : '<text y="12" fill="black">SVG export not supported for this track</text>',
            };
        }
        // get res using ServerSideRenderedContent
        return {
            ...res,
            reactElement: (react_1.default.createElement(ServerSideRenderedContent_1.default, { ...args, ...res, RenderingComponent: this.ReactComponent })),
        };
    }
    /**
     * modifies the passed arguments object to inflate arguments as necessary.
     * called in the worker process.
     *
     * @param args - the converted arguments to modify
     */
    deserializeArgsInWorker(args) {
        const deserialized = { ...args };
        deserialized.config = this.configSchema.create(args.config || {}, {
            pluginManager: this.pluginManager,
        });
        deserialized.filters = new serializableFilterChain_1.default({
            filters: args.filters,
        });
        return deserialized;
    }
    /**
     * Serialize results of the render to send them to the client. Includes
     * rendering React to an HTML string.
     *
     * @param results - object containing the results of calling the `render`
     * method
     * @param args - deserialized render args
     */
    serializeResultsInWorker(results, args) {
        const html = (0, server_1.renderToString)(react_1.default.createElement(styles_1.ThemeProvider, { theme: (0, ui_1.createJBrowseTheme)(args.theme) }, results.reactElement));
        delete results.reactElement;
        return { ...results, html };
    }
    /**
     * Render method called on the client. Serializes args, then calls
     * "CoreRender" with the RPC manager.
     *
     * @param rpcManager - RPC manager
     * @param args - render args
     */
    async renderInClient(rpcManager, args) {
        const results = (await rpcManager.call(args.sessionId, 'CoreRender', args));
        if (isSvgExport(results)) {
            results.html = await (0, util_1.getSerializedSvg)(results);
            delete results.reactElement;
        }
        return results;
    }
    /**
     * Render method called on the worker. `render` is called here in server-side
     * rendering
     *
     * @param args - serialized render args
     */
    async renderInWorker(args) {
        const { signal, statusCallback = () => { } } = args;
        const deserializedArgs = this.deserializeArgsInWorker(args);
        const results = await (0, util_1.updateStatus)('Rendering plot', statusCallback, () => this.render(deserializedArgs));
        (0, util_1.checkAbortSignal)(signal);
        // serialize the results for passing back to the main thread.
        // these will be transmitted to the main process, and will come out
        // as the result of renderRegionWithWorker.
        return (0, util_1.updateStatus)('Serializing results', statusCallback, () => this.serializeResultsInWorker(results, deserializedArgs));
    }
    async freeResourcesInClient(rpcManager, args) {
        const serializedArgs = this.serializeArgsInClient(args);
        const freed = this.freeResources();
        const freedRpc = (await rpcManager.call(args.sessionId, 'CoreFreeResources', serializedArgs));
        return freed + freedRpc;
    }
}
exports.default = ServerSideRenderer;
