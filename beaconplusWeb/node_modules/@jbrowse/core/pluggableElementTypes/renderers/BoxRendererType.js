"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LayoutSession = void 0;
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
// layouts
const GranularRectLayout_1 = __importDefault(require("../../util/layouts/GranularRectLayout"));
const MultiLayout_1 = __importDefault(require("../../util/layouts/MultiLayout"));
const PrecomputedLayout_1 = __importDefault(require("../../util/layouts/PrecomputedLayout"));
// other
const FeatureRendererType_1 = __importDefault(require("./FeatureRendererType"));
const util_1 = require("../../util");
const configuration_1 = require("../../configuration");
class LayoutSession {
    constructor(args) {
        this.config = args.config;
        this.bpPerPx = args.bpPerPx;
        this.filters = args.filters;
        this.update(args);
    }
    update(props) {
        Object.assign(this, props);
    }
    makeLayout() {
        return new MultiLayout_1.default(GranularRectLayout_1.default, {
            maxHeight: (0, configuration_1.readConfObject)(this.config, 'maxHeight'),
            displayMode: (0, configuration_1.readConfObject)(this.config, 'displayMode'),
            pitchX: this.bpPerPx,
            pitchY: (0, configuration_1.readConfObject)(this.config, 'noSpacing') ? 1 : 3,
        });
    }
    /**
     * @param layout -
     * @returns true if the given layout is a valid one to use for this session
     */
    cachedLayoutIsValid(cachedLayout) {
        return (cachedLayout &&
            cachedLayout.layout.subLayoutConstructorArgs.pitchX === this.bpPerPx &&
            (0, fast_deep_equal_1.default)((0, configuration_1.readConfObject)(this.config), cachedLayout.config) &&
            (0, fast_deep_equal_1.default)(this.filters, cachedLayout.filters));
    }
    get layout() {
        if (!this.cachedLayout || !this.cachedLayoutIsValid(this.cachedLayout)) {
            this.cachedLayout = {
                layout: this.makeLayout(),
                config: (0, configuration_1.readConfObject)(this.config),
                filters: this.filters,
            };
        }
        return this.cachedLayout.layout;
    }
}
exports.LayoutSession = LayoutSession;
class BoxRendererType extends FeatureRendererType_1.default {
    constructor() {
        super(...arguments);
        this.sessions = {};
    }
    getWorkerSession(props) {
        const key = (0, util_1.getLayoutId)(props);
        if (!this.sessions[key]) {
            this.sessions[key] = this.createSession(props);
        }
        const session = this.sessions[key];
        session.update(props);
        return session;
    }
    // expands region for glyphs to use
    getExpandedRegion(region, renderArgs) {
        if (!region) {
            return region;
        }
        const { bpPerPx, config } = renderArgs;
        const maxFeatureGlyphExpansion = config === undefined
            ? 0
            : (0, configuration_1.readConfObject)(config, 'maxFeatureGlyphExpansion');
        if (!maxFeatureGlyphExpansion) {
            return region;
        }
        const bpExpansion = Math.round(maxFeatureGlyphExpansion * bpPerPx);
        return {
            ...region,
            start: Math.floor(Math.max(region.start - bpExpansion, 0)),
            end: Math.ceil(region.end + bpExpansion),
        };
    }
    createSession(props) {
        return new LayoutSession(props);
    }
    async freeResourcesInClient(rpcManager, args) {
        const { regions } = args;
        const key = (0, util_1.getLayoutId)(args);
        let freed = 0;
        const session = this.sessions[key];
        if (!regions && session) {
            delete this.sessions[key];
            freed = 1;
        }
        if (session && regions) {
            session.layout.discardRange(regions[0].refName, regions[0].start, regions[0].end);
        }
        return freed + (await super.freeResourcesInClient(rpcManager, args));
    }
    deserializeLayoutInClient(json) {
        return new PrecomputedLayout_1.default(json);
    }
    deserializeResultsInClient(result, args) {
        const layout = this.deserializeLayoutInClient(result.layout);
        return super.deserializeResultsInClient({ ...result, layout }, args);
    }
    createLayoutInWorker(args) {
        const { regions } = args;
        const session = this.getWorkerSession(args);
        return session.layout.getSublayout(regions[0].refName);
    }
    serializeResultsInWorker(results, args) {
        const serialized = super.serializeResultsInWorker(results, args);
        const [region] = args.regions;
        serialized.layout = results.layout.serializeRegion(this.getExpandedRegion(region, args));
        if (serialized.layout.rectangles) {
            serialized.features = serialized.features.filter(f => {
                return Boolean(serialized.layout.rectangles[f.uniqueId]);
            });
        }
        serialized.maxHeightReached = serialized.layout.maxHeightReached;
        return serialized;
    }
    /**
     * gets layout and renders
     *
     * @param props - render args
     */
    async render(props) {
        const layout = props.layout ||
            this.createLayoutInWorker(props);
        const result = await super.render({ ...props, layout });
        return { ...result, layout };
    }
}
exports.default = BoxRendererType;
