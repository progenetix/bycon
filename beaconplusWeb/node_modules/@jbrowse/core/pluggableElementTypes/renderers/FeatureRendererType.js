"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const operators_1 = require("rxjs/operators");
const clone_1 = __importDefault(require("clone"));
const rxjs_1 = require("rxjs");
// locals
const util_1 = require("../../util");
const simpleFeature_1 = __importDefault(require("../../util/simpleFeature"));
const dataAdapterCache_1 = require("../../data_adapters/dataAdapterCache");
const ServerSideRendererType_1 = __importDefault(require("./ServerSideRendererType"));
const BaseAdapter_1 = require("../../data_adapters/BaseAdapter");
class FeatureRendererType extends ServerSideRendererType_1.default {
    /**
     * replaces the `displayModel` param (which on the client is a MST model)
     * with a stub that only contains the `selectedFeature`, since this is the only
     * part of the track model that most renderers read. also serializes the config
     * and regions to JSON from MST objects.
     *
     * @param args - the arguments passed to render
     */
    serializeArgsInClient(args) {
        const { displayModel, regions } = args;
        const serializedArgs = {
            ...args,
            displayModel: displayModel && {
                id: displayModel.id,
                selectedFeatureId: displayModel.selectedFeatureId,
            },
            regions: (0, clone_1.default)(regions),
        };
        return super.serializeArgsInClient(serializedArgs);
    }
    /**
     * Adds feature deserialization to base server-side result deserialization
     *
     * @param results - the results of the render
     * @param args - the arguments passed to render
     */
    deserializeResultsInClient(result, args) {
        const deserializedFeatures = new Map(result.features.map(f => simpleFeature_1.default.fromJSON(f)).map(f => [f.id(), f]));
        const deserialized = super.deserializeResultsInClient({
            ...result,
            features: deserializedFeatures,
        }, args);
        return {
            ...deserialized,
            blockKey: args.blockKey,
            features: deserializedFeatures,
        };
    }
    /**
     * Adds feature serialization to base server-side result serialization
     *
     * @param result - object containing the results of calling the `render`
     * method
     * @param args - deserialized render args
     */
    serializeResultsInWorker(result, args) {
        const serialized = super.serializeResultsInWorker(result, args);
        const { features } = result;
        return {
            ...serialized,
            features: (0, util_1.iterMap)(features.values(), f => f.toJSON(), features.size),
        };
    }
    /**
     * will expand if soft clipping or feature glyphs are shown
     *
     * @param region - rendering region
     * @param _renderArgs - render args, unused, may be used in deriving classes
     */
    getExpandedRegion(region, _renderArgs) {
        return region;
    }
    /**
     * use the dataAdapter to fetch the features to be rendered
     *
     * @param renderArgs -
     * @returns Map of features as `{ id => feature, ... }`
     */
    async getFeatures(renderArgs) {
        const pm = this.pluginManager;
        const { signal, regions, sessionId, adapterConfig } = renderArgs;
        const { dataAdapter } = await (0, dataAdapterCache_1.getAdapter)(pm, sessionId, adapterConfig);
        if (!(0, BaseAdapter_1.isFeatureAdapter)(dataAdapter)) {
            throw new Error('Adapter does not support retrieving features');
        }
        const features = new Map();
        if (!regions || regions.length === 0) {
            return features;
        }
        // make sure the requested region's start and end are integers, if
        // there is a region specification.
        const requestRegions = regions.map((r) => {
            const requestRegion = { ...r };
            if (requestRegion.start) {
                requestRegion.start = Math.floor(requestRegion.start);
            }
            if (requestRegion.end) {
                requestRegion.end = Math.ceil(requestRegion.end);
            }
            return requestRegion;
        });
        const region = requestRegions[0];
        const featureObservable = requestRegions.length === 1
            ? dataAdapter.getFeatures(this.getExpandedRegion(region, renderArgs), renderArgs)
            : dataAdapter.getFeaturesInMultipleRegions(requestRegions, renderArgs);
        const feats = await (0, rxjs_1.firstValueFrom)(featureObservable.pipe((0, operators_1.toArray)()));
        (0, util_1.checkAbortSignal)(signal);
        return new Map(feats
            .filter(feat => this.featurePassesFilters(renderArgs, feat))
            .map(feat => [feat.id(), feat]));
    }
    /**
     * @param renderArgs -
     * @param feature -
     * @returns true if this feature passes all configured filters
     */
    featurePassesFilters(renderArgs, feature) {
        return renderArgs.filters
            ? renderArgs.filters.passes(feature, renderArgs)
            : true;
    }
    /**
     * gets features and renders
     *
     * @param props - render args
     */
    async render(props) {
        const features = props.features || (await this.getFeatures(props));
        const result = await super.render({ ...props, features });
        return { ...result, features };
    }
}
exports.default = FeatureRendererType;
