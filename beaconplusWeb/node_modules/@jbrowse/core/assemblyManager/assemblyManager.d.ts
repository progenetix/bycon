import { IAnyType } from 'mobx-state-tree';
import { Assembly } from './assembly';
import PluginManager from '../PluginManager';
import RpcManager from '../rpc/RpcManager';
type AdapterConf = Record<string, unknown>;
/**
 * #stateModel AssemblyManager
 */
declare function assemblyManagerFactory(conf: IAnyType, pm: PluginManager): import("mobx-state-tree").IModelType<{
    /**
     * #property
     * this is automatically managed by an autorun which looks in the parent
     * session.assemblies, session.sessionAssemblies, and
     * session.temporaryAssemblies
     */
    assemblies: import("mobx-state-tree").IArrayType<import("mobx-state-tree").IModelType<{
        configuration: import("mobx-state-tree").IMaybe<import("mobx-state-tree").IReferenceType<IAnyType>>;
    }, {
        error: unknown;
        loaded: boolean;
        loadingP: Promise<void> | undefined;
        volatileRegions: import("./assembly").BasicRegion[] | undefined;
        refNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        lowerCaseRefNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        cytobands: import("../util").Feature[] | undefined;
    } & {
        getConf(arg: string): any;
    } & {
        readonly initialized: boolean;
        readonly name: string;
        readonly regions: import("./assembly").BasicRegion[] | undefined;
        /**
         * #action
         * private: you would generally want to add to manipulate
         * jbrowse.assemblies, session.sessionAssemblies, or
         * session.temporaryAssemblies instead of using this directly
         *
         * this can take an active instance of an assembly, in which case it is
         * referred to, or it can take an identifier e.g. assembly name, which is
         * used as a reference. snapshots cannot be used
         */
        readonly aliases: string[];
        readonly displayName: string | undefined;
        hasName(name: string): boolean;
        readonly allAliases: string[];
        readonly allRefNames: string[] | undefined;
        readonly lowerCaseRefNames: string[] | undefined;
        readonly allRefNamesWithLowerCase: string[] | undefined;
        readonly rpcManager: RpcManager;
        readonly refNameColors: string[];
    } & {
        readonly refNames: string[] | undefined;
    } & {
        getCanonicalRefName(refName: string): string | undefined;
        getRefNameColor(refName: string): string | undefined;
        isValidRefName(refName: string): boolean;
    } & {
        setLoaded({ adapterRegionsWithAssembly, refNameAliases, lowerCaseRefNameAliases, cytobands, }: import("./assembly").Loading): void;
        setError(e: unknown): void;
        setRegions(regions: import("../util").Region[]): void;
        setRefNameAliases(aliases: {
            [x: string]: string | undefined;
        }, lcAliases: {
            [x: string]: string | undefined;
        }): void;
        setCytobands(cytobands: import("../util").Feature[]): void;
        setLoadingP(p?: Promise<void> | undefined): void;
        load(): Promise<void>;
        loadPre(): Promise<void>;
    } & {
        getAdapterMapEntry(adapterConf: {
            [x: string]: unknown;
        }, options: import("../data_adapters/BaseAdapter").BaseOptions): Promise<import("./assembly").RefNameMap>;
        getRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
        getReverseRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
}, {
    readonly assemblyNameMap: Record<string, ({
        configuration: any;
    } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
        error: unknown;
        loaded: boolean;
        loadingP: Promise<void> | undefined;
        volatileRegions: import("./assembly").BasicRegion[] | undefined;
        refNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        lowerCaseRefNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        cytobands: import("../util").Feature[] | undefined;
    } & {
        getConf(arg: string): any;
    } & {
        readonly initialized: boolean;
        readonly name: string;
        readonly regions: import("./assembly").BasicRegion[] | undefined;
        /**
         * #action
         * private: you would generally want to add to manipulate
         * jbrowse.assemblies, session.sessionAssemblies, or
         * session.temporaryAssemblies instead of using this directly
         *
         * this can take an active instance of an assembly, in which case it is
         * referred to, or it can take an identifier e.g. assembly name, which is
         * used as a reference. snapshots cannot be used
         */
        readonly aliases: string[];
        readonly displayName: string | undefined;
        hasName(name: string): boolean;
        readonly allAliases: string[];
        readonly allRefNames: string[] | undefined;
        readonly lowerCaseRefNames: string[] | undefined;
        readonly allRefNamesWithLowerCase: string[] | undefined;
        readonly rpcManager: RpcManager;
        readonly refNameColors: string[];
    } & {
        readonly refNames: string[] | undefined;
    } & {
        getCanonicalRefName(refName: string): string | undefined;
        getRefNameColor(refName: string): string | undefined;
        isValidRefName(refName: string): boolean;
    } & {
        setLoaded({ adapterRegionsWithAssembly, refNameAliases, lowerCaseRefNameAliases, cytobands, }: import("./assembly").Loading): void;
        setError(e: unknown): void;
        setRegions(regions: import("../util").Region[]): void;
        setRefNameAliases(aliases: {
            [x: string]: string | undefined;
        }, lcAliases: {
            [x: string]: string | undefined;
        }): void;
        setCytobands(cytobands: import("../util").Feature[]): void;
        setLoadingP(p?: Promise<void> | undefined): void;
        load(): Promise<void>;
        loadPre(): Promise<void>;
    } & {
        getAdapterMapEntry(adapterConf: {
            [x: string]: unknown;
        }, options: import("../data_adapters/BaseAdapter").BaseOptions): Promise<import("./assembly").RefNameMap>;
        getRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
        getReverseRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
    } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
        configuration: import("mobx-state-tree").IMaybe<import("mobx-state-tree").IReferenceType<IAnyType>>;
    }, {
        error: unknown;
        loaded: boolean;
        loadingP: Promise<void> | undefined;
        volatileRegions: import("./assembly").BasicRegion[] | undefined;
        refNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        lowerCaseRefNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        cytobands: import("../util").Feature[] | undefined;
    } & {
        getConf(arg: string): any;
    } & {
        readonly initialized: boolean;
        readonly name: string;
        readonly regions: import("./assembly").BasicRegion[] | undefined;
        /**
         * #action
         * private: you would generally want to add to manipulate
         * jbrowse.assemblies, session.sessionAssemblies, or
         * session.temporaryAssemblies instead of using this directly
         *
         * this can take an active instance of an assembly, in which case it is
         * referred to, or it can take an identifier e.g. assembly name, which is
         * used as a reference. snapshots cannot be used
         */
        readonly aliases: string[];
        readonly displayName: string | undefined;
        hasName(name: string): boolean;
        readonly allAliases: string[];
        readonly allRefNames: string[] | undefined;
        readonly lowerCaseRefNames: string[] | undefined;
        readonly allRefNamesWithLowerCase: string[] | undefined;
        readonly rpcManager: RpcManager;
        readonly refNameColors: string[];
    } & {
        readonly refNames: string[] | undefined;
    } & {
        getCanonicalRefName(refName: string): string | undefined;
        getRefNameColor(refName: string): string | undefined;
        isValidRefName(refName: string): boolean;
    } & {
        setLoaded({ adapterRegionsWithAssembly, refNameAliases, lowerCaseRefNameAliases, cytobands, }: import("./assembly").Loading): void;
        setError(e: unknown): void;
        setRegions(regions: import("../util").Region[]): void;
        setRefNameAliases(aliases: {
            [x: string]: string | undefined;
        }, lcAliases: {
            [x: string]: string | undefined;
        }): void;
        setCytobands(cytobands: import("../util").Feature[]): void;
        setLoadingP(p?: Promise<void> | undefined): void;
        load(): Promise<void>;
        loadPre(): Promise<void>;
    } & {
        getAdapterMapEntry(adapterConf: {
            [x: string]: unknown;
        }, options: import("../data_adapters/BaseAdapter").BaseOptions): Promise<import("./assembly").RefNameMap>;
        getRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
        getReverseRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>) | undefined>;
} & {
    /**
     * #method
     */
    get(asmName: string): ({
        configuration: any;
    } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
        error: unknown;
        loaded: boolean;
        loadingP: Promise<void> | undefined;
        volatileRegions: import("./assembly").BasicRegion[] | undefined;
        refNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        lowerCaseRefNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        cytobands: import("../util").Feature[] | undefined;
    } & {
        getConf(arg: string): any;
    } & {
        readonly initialized: boolean;
        readonly name: string;
        readonly regions: import("./assembly").BasicRegion[] | undefined;
        /**
         * #action
         * private: you would generally want to add to manipulate
         * jbrowse.assemblies, session.sessionAssemblies, or
         * session.temporaryAssemblies instead of using this directly
         *
         * this can take an active instance of an assembly, in which case it is
         * referred to, or it can take an identifier e.g. assembly name, which is
         * used as a reference. snapshots cannot be used
         */
        readonly aliases: string[];
        readonly displayName: string | undefined;
        hasName(name: string): boolean;
        readonly allAliases: string[];
        readonly allRefNames: string[] | undefined;
        readonly lowerCaseRefNames: string[] | undefined;
        readonly allRefNamesWithLowerCase: string[] | undefined;
        readonly rpcManager: RpcManager;
        readonly refNameColors: string[];
    } & {
        readonly refNames: string[] | undefined;
    } & {
        getCanonicalRefName(refName: string): string | undefined;
        getRefNameColor(refName: string): string | undefined;
        isValidRefName(refName: string): boolean;
    } & {
        setLoaded({ adapterRegionsWithAssembly, refNameAliases, lowerCaseRefNameAliases, cytobands, }: import("./assembly").Loading): void;
        setError(e: unknown): void;
        setRegions(regions: import("../util").Region[]): void;
        setRefNameAliases(aliases: {
            [x: string]: string | undefined;
        }, lcAliases: {
            [x: string]: string | undefined;
        }): void;
        setCytobands(cytobands: import("../util").Feature[]): void;
        setLoadingP(p?: Promise<void> | undefined): void;
        load(): Promise<void>;
        loadPre(): Promise<void>;
    } & {
        getAdapterMapEntry(adapterConf: {
            [x: string]: unknown;
        }, options: import("../data_adapters/BaseAdapter").BaseOptions): Promise<import("./assembly").RefNameMap>;
        getRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
        getReverseRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
    } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
        configuration: import("mobx-state-tree").IMaybe<import("mobx-state-tree").IReferenceType<IAnyType>>;
    }, {
        error: unknown;
        loaded: boolean;
        loadingP: Promise<void> | undefined;
        volatileRegions: import("./assembly").BasicRegion[] | undefined;
        refNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        lowerCaseRefNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        cytobands: import("../util").Feature[] | undefined;
    } & {
        getConf(arg: string): any;
    } & {
        readonly initialized: boolean;
        readonly name: string;
        readonly regions: import("./assembly").BasicRegion[] | undefined;
        /**
         * #action
         * private: you would generally want to add to manipulate
         * jbrowse.assemblies, session.sessionAssemblies, or
         * session.temporaryAssemblies instead of using this directly
         *
         * this can take an active instance of an assembly, in which case it is
         * referred to, or it can take an identifier e.g. assembly name, which is
         * used as a reference. snapshots cannot be used
         */
        readonly aliases: string[];
        readonly displayName: string | undefined;
        hasName(name: string): boolean;
        readonly allAliases: string[];
        readonly allRefNames: string[] | undefined;
        readonly lowerCaseRefNames: string[] | undefined;
        readonly allRefNamesWithLowerCase: string[] | undefined;
        readonly rpcManager: RpcManager;
        readonly refNameColors: string[];
    } & {
        readonly refNames: string[] | undefined;
    } & {
        getCanonicalRefName(refName: string): string | undefined;
        getRefNameColor(refName: string): string | undefined;
        isValidRefName(refName: string): boolean;
    } & {
        setLoaded({ adapterRegionsWithAssembly, refNameAliases, lowerCaseRefNameAliases, cytobands, }: import("./assembly").Loading): void;
        setError(e: unknown): void;
        setRegions(regions: import("../util").Region[]): void;
        setRefNameAliases(aliases: {
            [x: string]: string | undefined;
        }, lcAliases: {
            [x: string]: string | undefined;
        }): void;
        setCytobands(cytobands: import("../util").Feature[]): void;
        setLoadingP(p?: Promise<void> | undefined): void;
        load(): Promise<void>;
        loadPre(): Promise<void>;
    } & {
        getAdapterMapEntry(adapterConf: {
            [x: string]: unknown;
        }, options: import("../data_adapters/BaseAdapter").BaseOptions): Promise<import("./assembly").RefNameMap>;
        getRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
        getReverseRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>) | undefined;
    /**
     * #getter
     */
    readonly assemblyNamesList: any[];
    /**
     * #getter
     * looks at jbrowse.assemblies, session.sessionAssemblies, and
     * session.temporaryAssemblies to load from
     */
    readonly assemblyList: ({
        [x: string]: any;
    } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
        setSubschema(slotName: string, data: unknown): any;
    } & import("mobx-state-tree").IStateTreeNode<import("../configuration").AnyConfigurationSchemaType>)[];
    readonly rpcManager: RpcManager;
} & {
    /**
     * #method
     * use this method instead of assemblyManager.get(assemblyName)
     * to get an assembly with regions loaded
     */
    waitForAssembly(assemblyName: string): Promise<({
        configuration: any;
    } & import("mobx-state-tree/dist/internal").NonEmptyObject & {
        error: unknown;
        loaded: boolean;
        loadingP: Promise<void> | undefined;
        volatileRegions: import("./assembly").BasicRegion[] | undefined;
        refNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        lowerCaseRefNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        cytobands: import("../util").Feature[] | undefined;
    } & {
        getConf(arg: string): any;
    } & {
        readonly initialized: boolean;
        readonly name: string;
        readonly regions: import("./assembly").BasicRegion[] | undefined;
        /**
         * #action
         * private: you would generally want to add to manipulate
         * jbrowse.assemblies, session.sessionAssemblies, or
         * session.temporaryAssemblies instead of using this directly
         *
         * this can take an active instance of an assembly, in which case it is
         * referred to, or it can take an identifier e.g. assembly name, which is
         * used as a reference. snapshots cannot be used
         */
        readonly aliases: string[];
        readonly displayName: string | undefined;
        hasName(name: string): boolean;
        readonly allAliases: string[];
        readonly allRefNames: string[] | undefined;
        readonly lowerCaseRefNames: string[] | undefined;
        readonly allRefNamesWithLowerCase: string[] | undefined;
        readonly rpcManager: RpcManager;
        readonly refNameColors: string[];
    } & {
        readonly refNames: string[] | undefined;
    } & {
        getCanonicalRefName(refName: string): string | undefined;
        getRefNameColor(refName: string): string | undefined;
        isValidRefName(refName: string): boolean;
    } & {
        setLoaded({ adapterRegionsWithAssembly, refNameAliases, lowerCaseRefNameAliases, cytobands, }: import("./assembly").Loading): void;
        setError(e: unknown): void;
        setRegions(regions: import("../util").Region[]): void;
        setRefNameAliases(aliases: {
            [x: string]: string | undefined;
        }, lcAliases: {
            [x: string]: string | undefined;
        }): void;
        setCytobands(cytobands: import("../util").Feature[]): void;
        setLoadingP(p?: Promise<void> | undefined): void;
        load(): Promise<void>;
        loadPre(): Promise<void>;
    } & {
        getAdapterMapEntry(adapterConf: {
            [x: string]: unknown;
        }, options: import("../data_adapters/BaseAdapter").BaseOptions): Promise<import("./assembly").RefNameMap>;
        getRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
        getReverseRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
    } & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IModelType<{
        configuration: import("mobx-state-tree").IMaybe<import("mobx-state-tree").IReferenceType<IAnyType>>;
    }, {
        error: unknown;
        loaded: boolean;
        loadingP: Promise<void> | undefined;
        volatileRegions: import("./assembly").BasicRegion[] | undefined;
        refNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        lowerCaseRefNameAliases: {
            [x: string]: string | undefined;
        } | undefined;
        cytobands: import("../util").Feature[] | undefined;
    } & {
        getConf(arg: string): any;
    } & {
        readonly initialized: boolean;
        readonly name: string;
        readonly regions: import("./assembly").BasicRegion[] | undefined;
        /**
         * #action
         * private: you would generally want to add to manipulate
         * jbrowse.assemblies, session.sessionAssemblies, or
         * session.temporaryAssemblies instead of using this directly
         *
         * this can take an active instance of an assembly, in which case it is
         * referred to, or it can take an identifier e.g. assembly name, which is
         * used as a reference. snapshots cannot be used
         */
        readonly aliases: string[];
        readonly displayName: string | undefined;
        hasName(name: string): boolean;
        readonly allAliases: string[];
        readonly allRefNames: string[] | undefined;
        readonly lowerCaseRefNames: string[] | undefined;
        readonly allRefNamesWithLowerCase: string[] | undefined;
        readonly rpcManager: RpcManager;
        readonly refNameColors: string[];
    } & {
        readonly refNames: string[] | undefined;
    } & {
        getCanonicalRefName(refName: string): string | undefined;
        getRefNameColor(refName: string): string | undefined;
        isValidRefName(refName: string): boolean;
    } & {
        setLoaded({ adapterRegionsWithAssembly, refNameAliases, lowerCaseRefNameAliases, cytobands, }: import("./assembly").Loading): void;
        setError(e: unknown): void;
        setRegions(regions: import("../util").Region[]): void;
        setRefNameAliases(aliases: {
            [x: string]: string | undefined;
        }, lcAliases: {
            [x: string]: string | undefined;
        }): void;
        setCytobands(cytobands: import("../util").Feature[]): void;
        setLoadingP(p?: Promise<void> | undefined): void;
        load(): Promise<void>;
        loadPre(): Promise<void>;
    } & {
        getAdapterMapEntry(adapterConf: {
            [x: string]: unknown;
        }, options: import("../data_adapters/BaseAdapter").BaseOptions): Promise<import("./assembly").RefNameMap>;
        getRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
        getReverseRefNameMapForAdapter(adapterConf: {
            [x: string]: unknown;
        }, opts: import("../data_adapters/BaseAdapter").BaseOptions): Promise<{
            [x: string]: string | undefined;
        }>;
    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>) | undefined>;
    /**
     * #method
     */
    getRefNameMapForAdapter(adapterConf: AdapterConf, assemblyName: string | undefined, opts: {
        signal?: AbortSignal;
        sessionId: string;
    }): Promise<{
        [x: string]: string | undefined;
    } | undefined>;
    /**
     * #method
     */
    getReverseRefNameMapForAdapter(adapterConf: AdapterConf, assemblyName: string | undefined, opts: {
        signal?: AbortSignal;
        sessionId: string;
    }): Promise<{
        [x: string]: string | undefined;
    } | undefined>;
    /**
     * #method
     */
    isValidRefName(refName: string, assemblyName: string): boolean;
} & {
    afterAttach(): void;
    /**
     * #action
     * private: you would generally want to add to manipulate
     * jbrowse.assemblies, session.sessionAssemblies, or
     * session.temporaryAssemblies instead of using this directly
     */
    removeAssembly(asm: Assembly): void;
    /**
     * #action
     * private: you would generally want to add to manipulate
     * jbrowse.assemblies, session.sessionAssemblies, or
     * session.temporaryAssemblies instead of using this directly
     *
     * this can take an active instance of an assembly, in which case it is
     * referred to, or it can take an identifier e.g. assembly name, which is
     * used as a reference. snapshots cannot be used
     */
    addAssembly(configuration: any): void;
    /**
     * #action
     * private: you would generally want to add to manipulate
     * jbrowse.assemblies, session.sessionAssemblies, or
     * session.temporaryAssemblies instead of using this directly
     */
    replaceAssembly(idx: number, configuration: any): void;
}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
export default assemblyManagerFactory;
