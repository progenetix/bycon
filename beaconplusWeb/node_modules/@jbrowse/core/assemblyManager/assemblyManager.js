"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mobx_state_tree_1 = require("mobx-state-tree");
const util_1 = require("../util");
const mobx_1 = require("mobx");
const configuration_1 = require("../configuration");
const assembly_1 = __importDefault(require("./assembly"));
/**
 * #stateModel AssemblyManager
 */
function assemblyManagerFactory(conf, pm) {
    return mobx_state_tree_1.types
        .model({
        /**
         * #property
         * this is automatically managed by an autorun which looks in the parent
         * session.assemblies, session.sessionAssemblies, and
         * session.temporaryAssemblies
         */
        assemblies: mobx_state_tree_1.types.array((0, assembly_1.default)(conf, pm)),
    })
        .views(self => ({
        get assemblyNameMap() {
            const obj = {};
            for (const assembly of self.assemblies) {
                for (const name of assembly.allAliases) {
                    obj[name] = assembly;
                }
            }
            return obj;
        },
    }))
        .views(self => ({
        /**
         * #method
         */
        get(asmName) {
            return self.assemblyNameMap[asmName];
        },
        /**
         * #getter
         */
        get assemblyNamesList() {
            return this.assemblyList.map(asm => asm.name);
        },
        /**
         * #getter
         * looks at jbrowse.assemblies, session.sessionAssemblies, and
         * session.temporaryAssemblies to load from
         */
        get assemblyList() {
            // name is the explicit identifier and can be accessed without getConf,
            // hence the union with {name:string}
            const { jbrowse: { assemblies }, session: { sessionAssemblies = [], temporaryAssemblies = [] } = {},
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
             } = (0, mobx_state_tree_1.getParent)(self);
            return [
                ...assemblies,
                ...sessionAssemblies,
                ...temporaryAssemblies,
            ];
        },
        get rpcManager() {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return (0, mobx_state_tree_1.getParent)(self).rpcManager;
        },
    }))
        .views(self => ({
        /**
         * #method
         * use this method instead of assemblyManager.get(assemblyName)
         * to get an assembly with regions loaded
         */
        async waitForAssembly(assemblyName) {
            if (!assemblyName) {
                throw new Error('no assembly name supplied to waitForAssembly');
            }
            let assembly = self.get(assemblyName);
            if (!assembly) {
                try {
                    await (0, util_1.when)(() => Boolean(self.get(assemblyName)), { timeout: 1000 });
                    assembly = self.get(assemblyName);
                }
                catch (e) {
                    // ignore
                }
            }
            if (!assembly) {
                return undefined;
            }
            await assembly.load();
            await (0, util_1.when)(() => !!((assembly === null || assembly === void 0 ? void 0 : assembly.regions) && assembly.refNameAliases) ||
                !!(assembly === null || assembly === void 0 ? void 0 : assembly.error));
            if (assembly.error) {
                throw assembly.error;
            }
            return assembly;
        },
        /**
         * #method
         */
        async getRefNameMapForAdapter(adapterConf, assemblyName, opts) {
            if (assemblyName) {
                const asm = await this.waitForAssembly(assemblyName);
                return asm === null || asm === void 0 ? void 0 : asm.getRefNameMapForAdapter(adapterConf, opts);
            }
            return {};
        },
        /**
         * #method
         */
        async getReverseRefNameMapForAdapter(adapterConf, assemblyName, opts) {
            if (assemblyName) {
                const asm = await this.waitForAssembly(assemblyName);
                return asm === null || asm === void 0 ? void 0 : asm.getReverseRefNameMapForAdapter(adapterConf, opts);
            }
            return {};
        },
        /**
         * #method
         */
        isValidRefName(refName, assemblyName) {
            const assembly = self.get(assemblyName);
            if (assembly) {
                return assembly.isValidRefName(refName);
            }
            throw new Error(`Failed to look up refName ${refName} on ${assemblyName} because assembly does not exist`);
        },
    }))
        .actions(self => ({
        afterAttach() {
            (0, mobx_state_tree_1.addDisposer)(self, (0, mobx_1.reaction)(() => self.assemblyList, assemblyConfs => {
                self.assemblies.forEach(asm => {
                    if (!asm.configuration) {
                        this.removeAssembly(asm);
                    }
                });
                assemblyConfs.forEach(conf => {
                    if (!self.assemblies.some(a => a.name === (0, configuration_1.readConfObject)(conf, 'name'))) {
                        this.addAssembly(conf);
                    }
                });
            }, { fireImmediately: true, name: 'assemblyManagerAfterAttach' }));
        },
        /**
         * #action
         * private: you would generally want to add to manipulate
         * jbrowse.assemblies, session.sessionAssemblies, or
         * session.temporaryAssemblies instead of using this directly
         */
        removeAssembly(asm) {
            self.assemblies.remove(asm);
        },
        /**
         * #action
         * private: you would generally want to add to manipulate
         * jbrowse.assemblies, session.sessionAssemblies, or
         * session.temporaryAssemblies instead of using this directly
         *
         * this can take an active instance of an assembly, in which case it is
         * referred to, or it can take an identifier e.g. assembly name, which is
         * used as a reference. snapshots cannot be used
         */
        addAssembly(configuration) {
            self.assemblies.push({ configuration });
        },
        /**
         * #action
         * private: you would generally want to add to manipulate
         * jbrowse.assemblies, session.sessionAssemblies, or
         * session.temporaryAssemblies instead of using this directly
         */
        replaceAssembly(idx, configuration) {
            self.assemblies[idx] = (0, mobx_state_tree_1.cast)({ configuration });
        },
    }));
}
exports.default = assemblyManagerFactory;
