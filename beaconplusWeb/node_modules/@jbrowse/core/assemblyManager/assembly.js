"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mobx_state_tree_1 = require("mobx-state-tree");
const abortable_promise_cache_1 = __importDefault(require("abortable-promise-cache"));
// locals
const configuration_1 = require("../configuration");
const util_1 = require("../util");
const QuickLRU_1 = __importDefault(require("../util/QuickLRU"));
const dataAdapterCache_1 = require("../data_adapters/dataAdapterCache");
const refNameRegex = new RegExp('[0-9A-Za-z!#$%&+./:;?@^_|~-][0-9A-Za-z!#$%&*+./:;=?@^_|~-]*');
// Based on the UCSC Genome Browser chromosome color palette:
// https://github.com/ucscGenomeBrowser/kent/blob/a50ed53aff81d6fb3e34e6913ce18578292bc24e/src/hg/inc/chromColors.h
// Some colors darkened to have at least a 3:1 contrast ratio on a white
// background
const refNameColors = [
    'rgb(153, 102, 0)',
    'rgb(102, 102, 0)',
    'rgb(153, 153, 30)',
    'rgb(204, 0, 0)',
    'rgb(255, 0, 0)',
    'rgb(255, 0, 204)',
    'rgb(165, 132, 132)', // originally 'rgb(255, 204, 204)'
    'rgb(204, 122, 0)', // originally rgb(255, 153, 0)'
    'rgb(178, 142, 0)', // originally 'rgb(255, 204, 0)'
    'rgb(153, 153, 0)', // originally 'rgb(255, 255, 0)'
    'rgb(122, 153, 0)', // originally 'rgb(204, 255, 0)'
    'rgb(0, 165, 0)', // originally 'rgb(0, 255, 0)'
    'rgb(53, 128, 0)',
    'rgb(0, 0, 204)',
    'rgb(96, 145, 242)', // originally 'rgb(102, 153, 255)'
    'rgb(107, 142, 178)', // originally 'rgb(153, 204, 255)'
    'rgb(0, 165, 165)', // originally 'rgb(0, 255, 255)'
    'rgb(122, 153, 153)', // originally 'rgb(204, 255, 255)'
    'rgb(153, 0, 204)',
    'rgb(204, 51, 255)',
    'rgb(173, 130, 216)', // originally 'rgb(204, 153, 255)'
    'rgb(102, 102, 102)',
    'rgb(145, 145, 145)', // originally 'rgb(153, 153, 153)'
    'rgb(142, 142, 142)', // originally 'rgb(204, 204, 204)'
    'rgb(142, 142, 107)', // originally 'rgb(204, 204, 153)'
    'rgb(96, 163, 48)', // originally 'rgb(121, 204, 61)'
];
async function loadRefNameMap(assembly, adapterConfig, options, signal) {
    const { sessionId } = options;
    await (0, util_1.when)(() => !!(assembly.regions && assembly.refNameAliases), {
        signal,
        name: 'when assembly ready',
    });
    const refNames = (await assembly.rpcManager.call(sessionId || 'assemblyRpc', 'CoreGetRefNames', {
        adapterConfig,
        signal,
        ...options,
    }, { timeout: 1000000 }));
    const { refNameAliases } = assembly;
    if (!refNameAliases) {
        throw new Error(`error loading assembly ${assembly.name}'s refNameAliases`);
    }
    const refNameMap = Object.fromEntries(refNames.map(name => {
        checkRefName(name);
        return [assembly.getCanonicalRefName(name), name];
    }));
    // make the reversed map too
    const reversed = Object.fromEntries(Object.entries(refNameMap).map(([canonicalName, adapterName]) => [
        adapterName,
        canonicalName,
    ]));
    return {
        forwardMap: refNameMap,
        reverseMap: reversed,
    };
}
// Valid refName pattern from https://samtools.github.io/hts-specs/SAMv1.pdf
function checkRefName(refName) {
    if (!refNameRegex.test(refName)) {
        throw new Error(`Encountered invalid refName: "${refName}"`);
    }
}
/**
 * #stateModel Assembly
 */
function assemblyFactory(assemblyConfigType, pm) {
    const adapterLoads = new abortable_promise_cache_1.default({
        cache: new QuickLRU_1.default({ maxSize: 1000 }),
        // @ts-expect-error
        async fill(args, signal, statusCallback) {
            const { adapterConf, self, options } = args;
            return loadRefNameMap(self, adapterConf, { ...options, statusCallback }, signal);
        },
    });
    return mobx_state_tree_1.types
        .model({
        /**
         * #property
         */
        configuration: mobx_state_tree_1.types.safeReference(assemblyConfigType),
    })
        .volatile(() => ({
        error: undefined,
        loaded: false,
        loadingP: undefined,
        volatileRegions: undefined,
        refNameAliases: undefined,
        lowerCaseRefNameAliases: undefined,
        cytobands: undefined,
    }))
        .views(self => ({
        getConf(arg) {
            return self.configuration ? (0, configuration_1.getConf)(self, arg) : undefined;
        },
    }))
        .views(self => ({
        /**
         * #getter
         */
        get initialized() {
            // @ts-expect-error
            self.load();
            return !!self.refNameAliases;
        },
        /**
         * #getter
         */
        get name() {
            return self.getConf('name') || '';
        },
        /**
         * #getter
         */
        get regions() {
            // @ts-expect-error
            self.load();
            return self.volatileRegions;
        },
        /**
         * #getter
         */
        get aliases() {
            return self.getConf('aliases') || [];
        },
        /**
         * #getter
         */
        get displayName() {
            return self.getConf('displayName');
        },
        /**
         * #getter
         */
        hasName(name) {
            return this.allAliases.includes(name);
        },
        /**
         * #getter
         */
        get allAliases() {
            return [this.name, ...this.aliases];
        },
        /**
         * #getter
         * note: lowerCaseRefNameAliases not included here: this allows the list
         * of refnames to be just the "normal casing", but things like
         * getCanonicalRefName can resolve a lower-case name if needed
         */
        get allRefNames() {
            return !self.refNameAliases
                ? undefined
                : Object.keys(self.refNameAliases);
        },
        /**
         * #getter
         */
        get lowerCaseRefNames() {
            return !self.lowerCaseRefNameAliases
                ? undefined
                : Object.keys(self.lowerCaseRefNameAliases || {});
        },
        /**
         * #getter
         */
        get allRefNamesWithLowerCase() {
            return this.allRefNames && this.lowerCaseRefNames
                ? [...new Set([...this.allRefNames, ...this.lowerCaseRefNames])]
                : undefined;
        },
        /**
         * #getter
         */
        get rpcManager() {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return (0, mobx_state_tree_1.getParent)(self, 2).rpcManager;
        },
        /**
         * #getter
         */
        get refNameColors() {
            const colors = self.getConf('refNameColors') || [];
            return colors.length === 0 ? refNameColors : colors;
        },
    }))
        .views(self => ({
        /**
         * #getter
         */
        get refNames() {
            var _a;
            return (_a = self.regions) === null || _a === void 0 ? void 0 : _a.map(region => region.refName);
        },
    }))
        .views(self => ({
        /**
         * #method
         */
        getCanonicalRefName(refName) {
            if (!self.refNameAliases || !self.lowerCaseRefNameAliases) {
                throw new Error('aliases not loaded, we expect them to be loaded before getCanonicalRefName can be called');
            }
            return (self.refNameAliases[refName] || self.lowerCaseRefNameAliases[refName]);
        },
        /**
         * #method
         */
        getRefNameColor(refName) {
            if (!self.refNames) {
                return undefined;
            }
            const idx = self.refNames.indexOf(refName);
            if (idx === -1) {
                return undefined;
            }
            return self.refNameColors[idx % self.refNameColors.length];
        },
        /**
         * #method
         */
        isValidRefName(refName) {
            if (!self.refNameAliases) {
                throw new Error('isValidRefName cannot be called yet, the assembly has not finished loading');
            }
            return !!this.getCanonicalRefName(refName);
        },
    }))
        .actions(self => ({
        /**
         * #action
         */
        setLoaded({ adapterRegionsWithAssembly, refNameAliases, lowerCaseRefNameAliases, cytobands, }) {
            self.loaded = true;
            this.setRegions(adapterRegionsWithAssembly);
            this.setRefNameAliases(refNameAliases, lowerCaseRefNameAliases);
            this.setCytobands(cytobands);
        },
        /**
         * #action
         */
        setError(e) {
            console.error(e);
            self.error = e;
        },
        /**
         * #action
         */
        setRegions(regions) {
            self.volatileRegions = regions;
        },
        /**
         * #action
         */
        setRefNameAliases(aliases, lcAliases) {
            self.refNameAliases = aliases;
            self.lowerCaseRefNameAliases = lcAliases;
        },
        /**
         * #action
         */
        setCytobands(cytobands) {
            self.cytobands = cytobands;
        },
        /**
         * #action
         */
        setLoadingP(p) {
            self.loadingP = p;
        },
        /**
         * #action
         */
        load() {
            if (!self.loadingP) {
                self.loadingP = this.loadPre().catch(e => {
                    this.setLoadingP(undefined);
                    this.setError(e);
                });
            }
            return self.loadingP;
        },
        /**
         * #action
         */
        async loadPre() {
            var _a, _b;
            const conf = self.configuration;
            const refNameAliasesAdapterConf = (_a = conf === null || conf === void 0 ? void 0 : conf.refNameAliases) === null || _a === void 0 ? void 0 : _a.adapter;
            const cytobandAdapterConf = (_b = conf === null || conf === void 0 ? void 0 : conf.cytobands) === null || _b === void 0 ? void 0 : _b.adapter;
            const sequenceAdapterConf = conf === null || conf === void 0 ? void 0 : conf.sequence.adapter;
            const assemblyName = self.name;
            const regions = await getAssemblyRegions(sequenceAdapterConf, pm);
            const adapterRegionsWithAssembly = regions.map(r => {
                checkRefName(r.refName);
                return { ...r, assemblyName };
            });
            const refNameAliases = {};
            const ret = await getRefNameAliases(refNameAliasesAdapterConf, pm);
            const cytobands = await getCytobands(cytobandAdapterConf, pm);
            ret.forEach(({ refName, aliases }) => {
                aliases.forEach(a => {
                    checkRefName(a);
                    refNameAliases[a] = refName;
                });
            });
            // add identity to the refNameAliases list
            adapterRegionsWithAssembly.forEach(region => {
                refNameAliases[region.refName] = region.refName;
            });
            const lowerCaseRefNameAliases = Object.fromEntries(Object.entries(refNameAliases).map(([key, val]) => [
                key.toLowerCase(),
                val,
            ]));
            this.setLoaded({
                adapterRegionsWithAssembly,
                refNameAliases,
                lowerCaseRefNameAliases,
                cytobands,
            });
        },
    }))
        .views(self => ({
        /**
         * #method
         */
        getAdapterMapEntry(adapterConf, options) {
            const { signal, statusCallback, ...rest } = options;
            if (!options.sessionId) {
                throw new Error('sessionId is required');
            }
            return adapterLoads.get((0, dataAdapterCache_1.adapterConfigCacheKey)(adapterConf), {
                adapterConf,
                self: self,
                options: rest,
            }, 
            // signal intentionally not passed here, fixes issues like #2221.
            // alternative fix #2540 was proposed but non-working currently
            undefined, statusCallback);
        },
        /**
         * #method
         * get Map of `canonical-name -> adapter-specific-name`
         */
        async getRefNameMapForAdapter(adapterConf, opts) {
            if (!(opts === null || opts === void 0 ? void 0 : opts.sessionId)) {
                throw new Error('sessionId is required');
            }
            const map = await this.getAdapterMapEntry(adapterConf, opts);
            return map.forwardMap;
        },
        /**
         * #method
         * get Map of `adapter-specific-name -> canonical-name`
         */
        async getReverseRefNameMapForAdapter(adapterConf, opts) {
            const map = await this.getAdapterMapEntry(adapterConf, opts);
            return map.reverseMap;
        },
    }));
}
exports.default = assemblyFactory;
async function getRefNameAliases(config, pm, signal) {
    const type = pm.getAdapterType(config.type);
    const CLASS = await type.getAdapterClass();
    const adapter = new CLASS(config, undefined, pm);
    return adapter.getRefNameAliases({ signal });
}
async function getCytobands(config, pm) {
    const type = pm.getAdapterType(config.type);
    const CLASS = await type.getAdapterClass();
    const adapter = new CLASS(config, undefined, pm);
    // @ts-expect-error
    return adapter.getData();
}
async function getAssemblyRegions(config, pm, signal) {
    const type = pm.getAdapterType(config.type);
    const CLASS = await type.getAdapterClass();
    const adapter = new CLASS(config, undefined, pm);
    return adapter.getRegions({ signal });
}
