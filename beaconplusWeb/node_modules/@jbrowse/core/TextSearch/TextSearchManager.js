"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const QuickLRU_1 = __importDefault(require("../util/QuickLRU"));
const configuration_1 = require("../configuration");
class TextSearchManager {
    constructor(pluginManager) {
        this.pluginManager = pluginManager;
        this.adapterCache = new QuickLRU_1.default({
            maxSize: 15,
        });
    }
    loadTextSearchAdapters(searchScope) {
        const pm = this.pluginManager;
        return this.relevantAdapters(searchScope).map(conf => {
            const adapterId = (0, configuration_1.readConfObject)(conf, 'textSearchAdapterId');
            const r = this.adapterCache.get(adapterId);
            if (r) {
                return r;
            }
            else {
                const { AdapterClass } = pm.getTextSearchAdapterType(conf.type);
                const a = new AdapterClass(conf, undefined, pm);
                this.adapterCache.set(adapterId, a);
                return a;
            }
        });
    }
    relevantAdapters(searchScope) {
        var _a, _b;
        const pm = this.pluginManager;
        const { aggregateTextSearchAdapters } = (_a = pm.rootModel) === null || _a === void 0 ? void 0 : _a.jbrowse;
        const { tracks } = (_b = pm.rootModel) === null || _b === void 0 ? void 0 : _b.session;
        const { assemblyName } = searchScope;
        return [
            ...this.getAdaptersWithAssembly(assemblyName, aggregateTextSearchAdapters),
            ...this.getTrackAdaptersWithAssembly(assemblyName, tracks),
        ];
    }
    getAdaptersWithAssembly(assemblyName, confs) {
        return confs.filter(c => { var _a; return (_a = (0, configuration_1.readConfObject)(c, 'assemblyNames')) === null || _a === void 0 ? void 0 : _a.includes(assemblyName); });
    }
    getTrackAdaptersWithAssembly(assemblyName, confs) {
        return confs
            .filter(conf => {
            var _a;
            return (_a = (0, configuration_1.readConfObject)(conf, [
                'textSearching',
                'textSearchAdapter',
                'assemblyNames',
            ])) === null || _a === void 0 ? void 0 : _a.includes(assemblyName);
        })
            .map(conf => conf.textSearching.textSearchAdapter);
    }
    /**
     * Returns list of relevant results given a search query and options
     * @param args - search options/arguments include: search query
     * limit of results to return, searchType...prefix | full | exact", etc.
     */
    async search(args, searchScope, rankFn) {
        const adapters = this.loadTextSearchAdapters(searchScope);
        const results = await Promise.all(adapters.map(a => a.searchIndex(args)));
        return this.sortResults(results.flat(), rankFn);
    }
    /**
     * Returns array of revelevant and sorted results
     * @param results - array of results from all text search adapters
     * @param rankFn - function that updates results scores
     * based on more relevance
     */
    sortResults(results, rankFn) {
        return rankFn(results.sort((a, b) => -b.getLabel().localeCompare(a.getLabel()))).sort((r1, r2) => r1.getScore() - r2.getScore());
    }
}
exports.default = TextSearchManager;
