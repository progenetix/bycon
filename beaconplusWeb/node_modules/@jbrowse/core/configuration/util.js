"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isConfigurationSlotType = exports.isConfigurationModel = exports.isConfigurationSchemaType = exports.isBareConfigurationSchemaType = exports.getTypeNamesFromExplicitlyTypedUnion = exports.getConf = exports.readConfObject = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const mobx_state_tree_1 = require("mobx-state-tree");
const mst_reflection_1 = require("../util/mst-reflection");
/**
 * given a configuration model (an instance of a ConfigurationSchema),
 * read the configuration variable at the given path
 *
 * @param model - instance of ConfigurationSchema
 * @param slotPaths - array of paths to read
 * @param args - extra arguments e.g. for a feature callback,
 *  will be sent to each of the slotNames
 */
function readConfObject(confObject, slotPath, args = {}) {
    if (!confObject) {
        throw new TypeError('must provide conf object to read');
    }
    if (!slotPath) {
        return JSON.parse(JSON.stringify((0, mobx_state_tree_1.getSnapshot)(confObject)));
    }
    if (typeof slotPath === 'string') {
        let slot = confObject[slotPath];
        // check for the subconf being a map if we don't find it immediately
        if (!slot &&
            (0, mobx_state_tree_1.isStateTreeNode)(confObject) &&
            (0, mobx_state_tree_1.isMapType)((0, mobx_state_tree_1.getType)(confObject))) {
            slot = confObject.get(slotPath);
        }
        if (!slot) {
            return undefined;
            // if we want to be very strict about config slots, we could uncomment the below
            // instead of returning undefined
            //
            // const modelType = getType(model)
            // const schemaType = model.configuration && getType(model.configuration)
            // throw new Error(
            //   `no slot "${slotName}" found in ${modelType.name} configuration (${
            //     schemaType.name
            //   })`,
            // )
        }
        if (slot.expr) {
            const appliedFunc = slot.expr.evalSync(args);
            if ((0, mobx_state_tree_1.isStateTreeNode)(appliedFunc)) {
                return JSON.parse(JSON.stringify((0, mobx_state_tree_1.getSnapshot)(appliedFunc)));
            }
            return appliedFunc;
        }
        if ((0, mobx_state_tree_1.isStateTreeNode)(slot)) {
            return JSON.parse(JSON.stringify((0, mobx_state_tree_1.getSnapshot)(slot)));
        }
        return slot;
    }
    if (Array.isArray(slotPath)) {
        const slotName = slotPath[0];
        if (slotPath.length > 1) {
            const newPath = slotPath.slice(1);
            let subConf = confObject[slotName];
            // check for the subconf being a map if we don't find it immediately
            if (!subConf &&
                (0, mobx_state_tree_1.isStateTreeNode)(confObject) &&
                (0, mobx_state_tree_1.isMapType)((0, mobx_state_tree_1.getType)(confObject))) {
                subConf = confObject.get(slotName);
            }
            return subConf ? readConfObject(subConf, newPath, args) : undefined;
        }
        return readConfObject(confObject, slotName, args);
    }
    throw new TypeError('slotPath must be a string or array');
}
exports.readConfObject = readConfObject;
/**
 * helper method for readConfObject, reads the config from a mst model
 *
 * @param model - object containing a 'configuration' member
 * @param slotPaths - array of paths to read
 * @param args - extra arguments e.g. for a feature callback,
 *   will be sent to each of the slotNames
 */
function getConf(model, slotPath, args) {
    if (!model) {
        throw new TypeError('must provide a model object');
    }
    const { configuration } = model;
    if (isConfigurationModel(configuration)) {
        return readConfObject(configuration, slotPath, args);
    }
    throw new TypeError('cannot getConf on this model, it has no configuration');
}
exports.getConf = getConf;
/**
 * given a union of explicitly typed configuration schema types,
 * extract an array of the type names contained in the union
 *
 * @param unionType -
 * @returns Array of type names contained in the union
 */
function getTypeNamesFromExplicitlyTypedUnion(maybeUnionType) {
    if ((0, mobx_state_tree_1.isType)(maybeUnionType)) {
        maybeUnionType = (0, mst_reflection_1.resolveLateType)(maybeUnionType);
        // @ts-expect-error
        if ((0, mobx_state_tree_1.isUnionType)(maybeUnionType)) {
            const typeNames = [];
            (0, mst_reflection_1.getUnionSubTypes)(maybeUnionType).forEach(type => {
                type = (0, mst_reflection_1.resolveLateType)(type);
                let typeName = getTypeNamesFromExplicitlyTypedUnion(type);
                if (!typeName.length) {
                    const def = (0, mst_reflection_1.getDefaultValue)(type);
                    typeName = [def.type];
                }
                if (!typeName[0]) {
                    // debugger
                    throw new Error(`invalid config schema type ${type}`);
                }
                typeNames.push(...typeName);
            });
            return typeNames;
        }
    }
    return [];
}
exports.getTypeNamesFromExplicitlyTypedUnion = getTypeNamesFromExplicitlyTypedUnion;
function isBareConfigurationSchemaType(thing) {
    if ((0, mobx_state_tree_1.isType)(thing)) {
        if ((0, mobx_state_tree_1.isModelType)(thing) &&
            ('isJBrowseConfigurationSchema' in thing ||
                thing.name.includes('ConfigurationSchema'))) {
            return true;
        }
        // if it's a late type, assume its a config schema
        if ((0, mobx_state_tree_1.isLateType)(thing)) {
            return true;
        }
    }
    return false;
}
exports.isBareConfigurationSchemaType = isBareConfigurationSchemaType;
function isConfigurationSchemaType(thing) {
    if (!(0, mobx_state_tree_1.isType)(thing)) {
        return false;
    }
    // written as a series of if-statements instead of a big logical OR
    // because this construction gives much better debugging backtraces.
    // also, note that the order of these statements matters, because
    // for example some union types are also optional types
    if (isBareConfigurationSchemaType(thing)) {
        return true;
    }
    if ((0, mobx_state_tree_1.isUnionType)(thing)) {
        return (0, mst_reflection_1.getUnionSubTypes)(thing).every(t => isConfigurationSchemaType(t) || t.name === 'undefined');
    }
    if ((0, mobx_state_tree_1.isOptionalType)(thing) && isConfigurationSchemaType((0, mst_reflection_1.getSubType)(thing))) {
        return true;
    }
    if ((0, mobx_state_tree_1.isArrayType)(thing) && isConfigurationSchemaType((0, mst_reflection_1.getSubType)(thing))) {
        return true;
    }
    if ((0, mobx_state_tree_1.isMapType)(thing) && isConfigurationSchemaType((0, mst_reflection_1.getSubType)(thing))) {
        return true;
    }
    return false;
}
exports.isConfigurationSchemaType = isConfigurationSchemaType;
function isConfigurationModel(thing) {
    return (0, mobx_state_tree_1.isStateTreeNode)(thing) && isConfigurationSchemaType((0, mobx_state_tree_1.getType)(thing));
}
exports.isConfigurationModel = isConfigurationModel;
function isConfigurationSlotType(thing) {
    return (typeof thing === 'object' &&
        thing !== null &&
        'isJBrowseConfigurationSlot' in thing);
}
exports.isConfigurationSlotType = isConfigurationSlotType;
