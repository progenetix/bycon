"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFeatureSequence = void 0;
const react_1 = require("react");
const util_1 = require("../../util");
const configuration_1 = require("../../configuration");
const BPLIMIT = 500000;
function useFeatureSequence(model, feature, upDownBp, forceLoad) {
    const [sequence, setSequence] = (0, react_1.useState)();
    const [error, setError] = (0, react_1.useState)();
    (0, react_1.useEffect)(() => {
        var _a;
        if (!model) {
            return;
        }
        const { assemblyManager, rpcManager } = (0, util_1.getSession)(model);
        const [assemblyName] = ((_a = model.view) === null || _a === void 0 ? void 0 : _a.assemblyNames) || [];
        async function fetchSeq(start, end, refName) {
            const assembly = await assemblyManager.waitForAssembly(assemblyName);
            if (!assembly) {
                throw new Error('assembly not found');
            }
            const sessionId = 'getSequence';
            const feats = await rpcManager.call(sessionId, 'CoreGetFeatures', {
                adapterConfig: (0, configuration_1.getConf)(assembly, ['sequence', 'adapter']),
                sessionId,
                regions: [
                    {
                        start,
                        end,
                        refName: assembly.getCanonicalRefName(refName),
                        assemblyName,
                    },
                ],
            });
            const [feat] = feats;
            return (feat === null || feat === void 0 ? void 0 : feat.get('seq')) || '';
        }
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        ;
        (async () => {
            try {
                setError(undefined);
                const { start, end, refName } = feature;
                if (!forceLoad && end - start > BPLIMIT) {
                    setSequence({
                        error: `Genomic sequence larger than ${BPLIMIT}bp, use "force load" button to display`,
                    });
                }
                else {
                    const b = start - upDownBp;
                    const e = end + upDownBp;
                    const seq = await fetchSeq(start, end, refName);
                    const up = await fetchSeq(Math.max(0, b), start, refName);
                    const down = await fetchSeq(end, e, refName);
                    setSequence({ seq, upstream: up, downstream: down });
                }
            }
            catch (e) {
                console.error(e);
                setError(e);
            }
        })();
    }, [feature, model, upDownBp, forceLoad]);
    return { sequence, error };
}
exports.useFeatureSequence = useFeatureSequence;
