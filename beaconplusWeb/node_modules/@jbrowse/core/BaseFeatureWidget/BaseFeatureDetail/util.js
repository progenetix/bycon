"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.accessNested = exports.generateMaxWidth = exports.generateTitle = exports.isEmpty = void 0;
const is_object_1 = __importDefault(require("is-object"));
const util_1 = require("../../util");
const util_2 = require("../util");
function isEmpty(obj) {
    return Object.keys(obj).length === 0;
}
exports.isEmpty = isEmpty;
function generateTitle(name, id, type) {
    return [(0, util_2.ellipses)(`${name}` || `${id}`), `${type}`]
        .filter(f => !!f)
        .join(' - ');
}
exports.generateTitle = generateTitle;
function generateMaxWidth(array, prefix) {
    return (Math.ceil((0, util_1.max)(array.map(key => (0, util_1.measureText)([...prefix, key[0]].join('.'), 12)))) + 10);
}
exports.generateMaxWidth = generateMaxWidth;
// pick using a path from an object, similar to _.get from lodash with special
// logic for Descriptions from e.g. VCF headers
//
// @param arr  example ['a','b'], obj = {a:{b:'hello}}
// @returns hello (with special addition to grab description also)
function accessNested(arr, obj = {}) {
    let obj2 = obj;
    arr.forEach(elt => {
        if ((0, is_object_1.default)(obj2)) {
            obj2 = obj2[elt];
        }
    });
    return typeof obj2 === 'string'
        ? obj2
        : (0, is_object_1.default)(obj2) && typeof (obj2 === null || obj2 === void 0 ? void 0 : obj2.Description) === 'string'
            ? obj2.Description
            : undefined;
}
exports.accessNested = accessNested;
