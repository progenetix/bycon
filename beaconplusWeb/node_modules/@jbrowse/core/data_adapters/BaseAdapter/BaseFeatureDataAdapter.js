"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseFeatureDataAdapter = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
// locals
const BaseAdapter_1 = require("./BaseAdapter");
const rxjs_2 = require("../../util/rxjs");
const util_1 = require("../../util");
const stats_1 = require("../../util/stats");
/**
 * Base class for feature adapters to extend. Defines some methods that
 * subclasses must implement.
 */
class BaseFeatureDataAdapter extends BaseAdapter_1.BaseAdapter {
    /**
     * Return "header info" that is fetched from the data file, or other info
     * that would not simply be in the config of the file. The return value can
     * be `{tag:string, data: any}[]` e.g. list of tags with their values which
     * is how VCF,BAM,CRAM return values for getInfo or it can be a nested JSON
     * object
     */
    async getHeader(_opts) {
        return null;
    }
    /**
     * Return info that is primarily used for interpreting the data that is there,
     * primarily in reference to being used for augmenting feature details panels
     */
    async getMetadata(_opts) {
        return null;
    }
    /**
     * Checks if the store has data for the given assembly and reference
     * sequence, and then gets the features in the region if it does.
     */
    getFeaturesInRegion(region, opts = {}) {
        return (0, rxjs_2.ObservableCreate)(async (observer) => {
            const hasData = await this.hasDataForRefName(region.refName, opts);
            (0, util_1.checkAbortSignal)(opts.signal);
            if (!hasData) {
                observer.complete();
            }
            else {
                this.getFeatures(region, opts).subscribe(observer);
            }
        });
    }
    /**
     * Checks if the store has data for the given assembly and reference
     * sequence, and then gets the features in the region if it does.
     *
     * Currently this just calls getFeatureInRegion for each region. Adapters that
     * are frequently called on multiple regions simultaneously may want to
     * implement a more efficient custom version of this method.
     *
     * Currently this just calls getFeatureInRegion for each region. Adapters that
     * are frequently called on multiple regions simultaneously may want to
     * implement a more efficient custom version of this method.
     *
     * @param regions - Regions
     * @param opts - Feature adapter options
     * @returns Observable of Feature objects in the regions
     */
    getFeaturesInMultipleRegions(regions, opts = {}) {
        return (0, rxjs_1.merge)(...regions.map(region => this.getFeaturesInRegion(region, opts)));
    }
    /**
     * Check if the store has data for the given reference name.
     * @param refName - Name of the reference sequence
     * @returns Whether data source has data for the given reference name
     */
    async hasDataForRefName(refName, opts = {}) {
        const refNames = await this.getRefNames(opts);
        return refNames.includes(refName);
    }
    /**
     * Calculates the minimum score, maximum score, and other statistics from
     * features over a region, primarily used for quantitative tracks
     */
    async getRegionQuantitativeStats(region, opts) {
        const feats = this.getFeatures(region, opts);
        return (0, stats_1.scoresToStats)(region, feats);
    }
    /**
     * Calculates the minimum score, maximum score, and other statistics from
     * features over multiple regions, primarily used for quantitative tracks
     */
    async getMultiRegionQuantitativeStats(regions = [], opts) {
        if (!regions.length) {
            return (0, stats_1.blankStats)();
        }
        const feats = await Promise.all(regions.map(region => this.getRegionQuantitativeStats(region, opts)));
        const scoreMax = (0, util_1.max)(feats.map(a => a.scoreMax));
        const scoreMin = (0, util_1.min)(feats.map(a => a.scoreMin));
        const scoreSum = (0, util_1.sum)(feats.map(a => a.scoreSum));
        const scoreSumSquares = (0, util_1.sum)(feats.map(a => a.scoreSumSquares));
        const featureCount = (0, util_1.sum)(feats.map(a => a.featureCount));
        const basesCovered = (0, util_1.sum)(feats.map(a => a.basesCovered));
        return (0, stats_1.rectifyStats)({
            scoreMin,
            scoreMax,
            featureCount,
            basesCovered,
            scoreSumSquares,
            scoreSum,
        });
    }
    /**
     * Calculates the "feature density" of a region. The primary purpose of this
     * API is to alert the user if they are going to be downloading too much
     * information, and give them a hint to zoom in to see more. The default
     * implementation samples from the regions, downloads feature data with
     * getFeatures, and returns an object with the form \{featureDensity:number\}
     *
     * Derived classes can override this to return alternative calculations for
     * featureDensity, or they can also return an object containing a byte size
     * calculation with the format \{bytes:number, fetchSizeLimit:number\} where
     * fetchSizeLimit is the adapter-defined limit for what it thinks is 'too much
     * data' (e.g. CRAM and
     * BAM may vary on what they think too much data is)
     */
    getRegionFeatureDensityStats(region, opts) {
        let lastTime = +Date.now();
        const statsFromInterval = async (length, expansionTime) => {
            const { start, end } = region;
            const sampleCenter = start * 0.75 + end * 0.25;
            const features = await (0, rxjs_1.firstValueFrom)(this.getFeatures({
                ...region,
                start: Math.max(0, Math.round(sampleCenter - length / 2)),
                end: Math.min(Math.round(sampleCenter + length / 2), end),
            }, opts).pipe((0, operators_1.toArray)()));
            return maybeRecordStats(length, { featureDensity: features.length / length }, features.length, expansionTime);
        };
        const maybeRecordStats = async (interval, stats, statsSampleFeatures, expansionTime) => {
            const refLen = region.end - region.start;
            if (statsSampleFeatures >= 70 || interval * 2 > refLen) {
                return stats;
            }
            else if (expansionTime <= 5000) {
                const currTime = +Date.now();
                expansionTime += currTime - lastTime;
                lastTime = currTime;
                return statsFromInterval(interval * 2, expansionTime);
            }
            else {
                console.warn("Stats estimation reached timeout, or didn't get enough features");
                return { featureDensity: Number.POSITIVE_INFINITY };
            }
        };
        return statsFromInterval(1000, 0);
    }
    /**
     * Calculates the "feature density" of a set of regions. The primary purpose
     * of this API is to alert the user if they are going to be downloading too
     * much information, and give them a hint to zoom in to see more. The default
     * implementation samples from the regions, downloads feature data with
     * getFeatures, and returns an object with the form \{featureDensity:number\}
     *
     * Derived classes can override this to return alternative calculations for
     * featureDensity, or they can also return an object containing a byte size
     * calculation with the format \{bytes:number, fetchSizeLimit:number\} where
     * fetchSizeLimit is the adapter-defined limit for what it thinks is 'too much
     * data' (e.g. CRAM and
     * BAM may vary on what they think too much data is)
     */
    async getMultiRegionFeatureDensityStats(regions, opts) {
        if (!regions.length) {
            throw new Error('No regions supplied');
        }
        return this.getRegionFeatureDensityStats(regions[0], opts);
    }
}
exports.BaseFeatureDataAdapter = BaseFeatureDataAdapter;
