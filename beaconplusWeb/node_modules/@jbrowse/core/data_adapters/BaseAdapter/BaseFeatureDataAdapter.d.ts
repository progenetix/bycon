import { Observable } from 'rxjs';
import { BaseAdapter } from './BaseAdapter';
import { BaseOptions } from './BaseOptions';
import { FeatureDensityStats } from './types';
import { Feature } from '../../util/simpleFeature';
import { AugmentedRegion as Region } from '../../util/types';
/**
 * Base class for feature adapters to extend. Defines some methods that
 * subclasses must implement.
 */
export declare abstract class BaseFeatureDataAdapter extends BaseAdapter {
    /**
     * Get all reference sequence names used in the data source
     * Example:
     * public async getRefNames(opts?: BaseOptions): Promise\<string[]\> \}
     *   await this.setup()
     *   const \{ refNames \} = this.metadata
     *   return refNames
     * \}
     *
     *
     * NOTE: If an adapter is unable to determine the reference sequence names,
     * the array will be empty
     * @param opts - Feature adapter options
     */
    abstract getRefNames(opts?: BaseOptions): Promise<string[]>;
    /**
     * Get features from the data source that overlap a region
     * Example:
     * public getFeatures(
     *   region: Region,
     *   opts: BaseOptions,
     * ): Observable<Feature> \{
     *   return ObservableCreate(observer =\> \{
     *     const records = getRecords(assembly, refName, start, end)
     *     records.forEach(record =\> \{
     *       observer.next(this.recordToFeature(record))
     *     \})
     *     observer.complete()
     *   \})
     * \}
     * @param region - Region
     * @param opts - Feature adapter options
     * @returns Observable of Feature objects in the region
     */
    abstract getFeatures(region: Region, opts?: BaseOptions): Observable<Feature>;
    /**
     * Return "header info" that is fetched from the data file, or other info
     * that would not simply be in the config of the file. The return value can
     * be `{tag:string, data: any}[]` e.g. list of tags with their values which
     * is how VCF,BAM,CRAM return values for getInfo or it can be a nested JSON
     * object
     */
    getHeader(_opts?: BaseOptions): Promise<unknown>;
    /**
     * Return info that is primarily used for interpreting the data that is there,
     * primarily in reference to being used for augmenting feature details panels
     */
    getMetadata(_opts?: BaseOptions): Promise<unknown>;
    /**
     * Checks if the store has data for the given assembly and reference
     * sequence, and then gets the features in the region if it does.
     */
    getFeaturesInRegion(region: Region, opts?: BaseOptions): Observable<Feature>;
    /**
     * Checks if the store has data for the given assembly and reference
     * sequence, and then gets the features in the region if it does.
     *
     * Currently this just calls getFeatureInRegion for each region. Adapters that
     * are frequently called on multiple regions simultaneously may want to
     * implement a more efficient custom version of this method.
     *
     * Currently this just calls getFeatureInRegion for each region. Adapters that
     * are frequently called on multiple regions simultaneously may want to
     * implement a more efficient custom version of this method.
     *
     * @param regions - Regions
     * @param opts - Feature adapter options
     * @returns Observable of Feature objects in the regions
     */
    getFeaturesInMultipleRegions(regions: Region[], opts?: BaseOptions): Observable<Feature>;
    /**
     * Check if the store has data for the given reference name.
     * @param refName - Name of the reference sequence
     * @returns Whether data source has data for the given reference name
     */
    hasDataForRefName(refName: string, opts?: BaseOptions): Promise<boolean>;
    /**
     * Calculates the minimum score, maximum score, and other statistics from
     * features over a region, primarily used for quantitative tracks
     */
    getRegionQuantitativeStats(region: Region, opts?: BaseOptions): Promise<import("../../util/stats").QuantitativeStats>;
    /**
     * Calculates the minimum score, maximum score, and other statistics from
     * features over multiple regions, primarily used for quantitative tracks
     */
    getMultiRegionQuantitativeStats(regions?: Region[], opts?: BaseOptions): Promise<import("../../util/stats").QuantitativeStats>;
    /**
     * Calculates the "feature density" of a region. The primary purpose of this
     * API is to alert the user if they are going to be downloading too much
     * information, and give them a hint to zoom in to see more. The default
     * implementation samples from the regions, downloads feature data with
     * getFeatures, and returns an object with the form \{featureDensity:number\}
     *
     * Derived classes can override this to return alternative calculations for
     * featureDensity, or they can also return an object containing a byte size
     * calculation with the format \{bytes:number, fetchSizeLimit:number\} where
     * fetchSizeLimit is the adapter-defined limit for what it thinks is 'too much
     * data' (e.g. CRAM and
     * BAM may vary on what they think too much data is)
     */
    getRegionFeatureDensityStats(region: Region, opts?: BaseOptions): Promise<FeatureDensityStats>;
    /**
     * Calculates the "feature density" of a set of regions. The primary purpose
     * of this API is to alert the user if they are going to be downloading too
     * much information, and give them a hint to zoom in to see more. The default
     * implementation samples from the regions, downloads feature data with
     * getFeatures, and returns an object with the form \{featureDensity:number\}
     *
     * Derived classes can override this to return alternative calculations for
     * featureDensity, or they can also return an object containing a byte size
     * calculation with the format \{bytes:number, fetchSizeLimit:number\} where
     * fetchSizeLimit is the adapter-defined limit for what it thinks is 'too much
     * data' (e.g. CRAM and
     * BAM may vary on what they think too much data is)
     */
    getMultiRegionFeatureDensityStats(regions: Region[], opts?: BaseOptions): Promise<FeatureDensityStats>;
}
