"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const material_1 = require("@mui/material");
const source_map_js_1 = require("source-map-js");
const copy_to_clipboard_1 = __importDefault(require("copy-to-clipboard"));
// locals
const Dialog_1 = __importDefault(require("./Dialog"));
const LoadingEllipses_1 = __importDefault(require("./LoadingEllipses"));
function Link2({ href, children, }) {
    return (react_1.default.createElement(material_1.Link, { target: "_blank", href: href }, children));
}
async function myfetch(uri) {
    const res = await fetch(uri);
    if (!res.ok) {
        throw new Error(`HTTP ${res.status} fetching ${uri}: ${await res.text()}`);
    }
    return res;
}
async function myfetchjson(uri) {
    const res = await myfetch(uri);
    return res.json();
}
async function myfetchtext(uri) {
    const res = await myfetch(uri);
    return res.text();
}
// produce a source-map resolved stack trace
// reference code https://stackoverflow.com/a/77158517/2129219
const sourceMaps = {};
async function getSourceMapFromUri(uri) {
    var _a;
    if (sourceMaps[uri] != undefined) {
        return sourceMaps[uri];
    }
    const uriQuery = new URL(uri).search;
    const currentScriptContent = await myfetchtext(uri);
    let mapUri = ((_a = new RegExp(/\/\/# sourceMappingURL=(.*)/).exec(currentScriptContent)) === null || _a === void 0 ? void 0 : _a[1]) ||
        '';
    mapUri = new URL(mapUri, uri).href + uriQuery;
    const data = await myfetchjson(mapUri);
    const map = new source_map_js_1.SourceMapConsumer(data);
    sourceMaps[uri] = map;
    return map;
}
async function mapStackTrace(stack) {
    const stackLines = stack.split('\n');
    const mappedStack = [];
    for (const line of stackLines) {
        const match = new RegExp(/(.*)(https?:\/\/.*):(\d+):(\d+)/).exec(line);
        if (match === null) {
            mappedStack.push(line);
            continue;
        }
        const uri = match[2];
        const consumer = await getSourceMapFromUri(uri);
        const originalPosition = consumer.originalPositionFor({
            line: parseInt(match[3]),
            column: parseInt(match[4]),
        });
        if (originalPosition.source === null ||
            originalPosition.line === null ||
            originalPosition.column === null) {
            mappedStack.push(line);
            continue;
        }
        mappedStack.push(`${originalPosition.source}:${originalPosition.line}:${originalPosition.column + 1}`);
    }
    return mappedStack.join('\n');
}
const MAX_ERR_LEN = 10000;
// Chrome has the error message in the stacktrace, firefox doesn't
function stripMessage(trace, error) {
    if (trace.startsWith('Error:')) {
        // remove the error message, which can be very long due to mobx-state-tree
        // stuff, to get just the stack trace
        const err = `${error}`;
        return trace.slice(err.length);
    }
    else {
        return trace;
    }
}
function Contents({ text, extra }) {
    const err = encodeURIComponent([
        'I got this error from JBrowse, here is the stack trace:\n',
        '```',
        text,
        '```',
        extra ? `supporting data: ${JSON.stringify(extra, null, 2)}` : '',
    ].join('\n') + '\n');
    const err2 = [
        text,
        extra ? `supporting data: ${JSON.stringify(extra, null, 2)}` : '',
    ].join('\n');
    const email = 'jbrowse2@berkeley.edu';
    const githubLink = `https://github.com/GMOD/jbrowse-components/issues/new?labels=bug&title=JBrowse+issue&body=${err}`;
    const emailLink = `mailto:${email}?subject=JBrowse%202%20error&body=${err}`;
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(material_1.Typography, null,
            "Post a new issue at ",
            react_1.default.createElement(Link2, { href: githubLink }, "GitHub"),
            " or send an email to ",
            react_1.default.createElement(Link2, { href: emailLink }, email),
            ' '),
        react_1.default.createElement("pre", { style: {
                background: 'lightgrey',
                border: '1px solid black',
                overflow: 'auto',
                margin: 20,
                maxHeight: 300,
            } }, err2)));
}
function ErrorMessageStackTraceDialog({ error, onClose, extra, }) {
    const [mappedStackTrace, setMappedStackTrace] = (0, react_1.useState)();
    const [secondaryError, setSecondaryError] = (0, react_1.useState)();
    const [clicked, setClicked] = (0, react_1.useState)(false);
    const stackTracePreProcessed = `${typeof error === 'object' && error !== null && 'stack' in error ? error.stack : ''}`;
    const errorText = error ? `${error}` : '';
    const stackTrace = stripMessage(stackTracePreProcessed, errorText);
    (0, react_1.useEffect)(() => {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        ;
        (async () => {
            try {
                const res = await mapStackTrace(stackTrace);
                setMappedStackTrace(res);
            }
            catch (e) {
                console.error(e);
                setMappedStackTrace(stackTrace);
                setSecondaryError(e);
            }
        })();
    }, [stackTrace]);
    const errorBoxText = [
        secondaryError
            ? 'Error loading source map, showing raw stack trace below:'
            : '',
        errorText.length > MAX_ERR_LEN
            ? `${errorText.slice(0, MAX_ERR_LEN)}...`
            : errorText,
        mappedStackTrace || 'No stack trace available',
        // @ts-expect-error add version info at bottom if we are in jbrowse-web
        window.JBrowseSession ? `JBrowse ${window.JBrowseSession.version}` : '',
    ]
        .filter(f => !!f)
        .join('\n');
    return (react_1.default.createElement(Dialog_1.default, { open: true, onClose: onClose, title: "Stack trace", maxWidth: "xl" },
        react_1.default.createElement(material_1.DialogContent, null, mappedStackTrace === undefined ? (react_1.default.createElement(LoadingEllipses_1.default, { variant: "h6" })) : (react_1.default.createElement(Contents, { text: errorBoxText, extra: extra }))),
        react_1.default.createElement(material_1.DialogActions, null,
            react_1.default.createElement(material_1.Button, { variant: "contained", color: "secondary", onClick: () => {
                    (0, copy_to_clipboard_1.default)(errorBoxText);
                    setClicked(true);
                    setTimeout(() => setClicked(false), 1000);
                } }, clicked ? 'Copied!' : 'Copy stack trace to clipboard'),
            react_1.default.createElement(material_1.Button, { variant: "contained", color: "primary", onClick: onClose }, "Close"))));
}
exports.default = ErrorMessageStackTraceDialog;
