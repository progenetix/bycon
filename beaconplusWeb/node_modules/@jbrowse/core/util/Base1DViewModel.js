"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mobx_state_tree_1 = require("mobx-state-tree");
const index_1 = require("./index");
const mst_1 = require("./types/mst");
const calculateDynamicBlocks_1 = __importDefault(require("./calculateDynamicBlocks"));
const calculateStaticBlocks_1 = __importDefault(require("./calculateStaticBlocks"));
const Base1DUtils_1 = require("./Base1DUtils");
/**
 * #stateModel Base1DView
 * used in non-lgv view representations of a 1d view e.g. the two axes of the
 * dotplot use this
 */
function x() { } // eslint-disable-line @typescript-eslint/no-unused-vars
const Base1DView = mobx_state_tree_1.types
    .model('Base1DView', {
    /**
     * #property
     */
    id: mst_1.ElementId,
    /**
     * #property
     */
    displayedRegions: mobx_state_tree_1.types.array(mst_1.Region),
    /**
     * #property
     */
    bpPerPx: 0,
    /**
     * #property
     */
    offsetPx: 0,
    /**
     * #property
     */
    interRegionPaddingWidth: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 0),
    /**
     * #property
     */
    minimumBlockWidth: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 0),
})
    .volatile(() => ({
    features: undefined,
    volatileWidth: 0,
}))
    .actions(self => ({
    /**
     * #action
     */
    setDisplayedRegions(regions) {
        self.displayedRegions = (0, mobx_state_tree_1.cast)(regions);
    },
    /**
     * #action
     */
    setBpPerPx(val) {
        self.bpPerPx = val;
    },
    /**
     * #action
     */
    setVolatileWidth(width) {
        self.volatileWidth = width;
    },
}))
    .views(self => ({
    /**
     * #getter
     */
    get width() {
        return self.volatileWidth;
    },
    /**
     * #getter
     */
    get assemblyNames() {
        return [
            ...new Set(self.displayedRegions.map(region => region.assemblyName)),
        ];
    },
    /**
     * #getter
     */
    get displayedRegionsTotalPx() {
        return this.totalBp / self.bpPerPx;
    },
    /**
     * #getter
     */
    get maxOffset() {
        // objectively determined to keep the linear genome on the main screen
        const leftPadding = 10;
        return this.displayedRegionsTotalPx - leftPadding;
    },
    /**
     * #getter
     */
    get minOffset() {
        // objectively determined to keep the linear genome on the main screen
        const rightPadding = 30;
        return -this.width + rightPadding;
    },
    /**
     * #getter
     */
    get totalBp() {
        return self.displayedRegions
            .map(a => a.end - a.start)
            .reduce((a, b) => a + b, 0);
    },
}))
    .views(self => ({
    /**
     * #getter
     */
    get dynamicBlocks() {
        return (0, calculateDynamicBlocks_1.default)(self);
    },
    /**
     * #getter
     */
    get staticBlocks() {
        return (0, calculateStaticBlocks_1.default)(self);
    },
    /**
     * #getter
     */
    get currBp() {
        return this.dynamicBlocks
            .map(a => a.end - a.start)
            .reduce((a, b) => a + b, 0);
    },
}))
    .views(self => ({
    /**
     * #method
     */
    pxToBp(px) {
        return (0, Base1DUtils_1.pxToBp)(self, px);
    },
    /**
     * #method
     */
    bpToPx({ refName, coord, regionNumber, }) {
        var _a;
        return (_a = (0, Base1DUtils_1.bpToPx)({ refName, coord, regionNumber, self })) === null || _a === void 0 ? void 0 : _a.offsetPx;
    },
}))
    .actions(self => ({
    /**
     * #action
     */
    setFeatures(features) {
        self.features = features;
    },
    /**
     * #action
     * this makes a zoomed out view that shows all displayedRegions that makes
     * the overview bar square with the scale bar
     */
    showAllRegions() {
        self.bpPerPx = self.totalBp / self.width;
        self.offsetPx = 0;
    },
    /**
     * #action
     */
    zoomOut() {
        this.zoomTo(self.bpPerPx * 2);
    },
    /**
     * #action
     */
    zoomIn() {
        this.zoomTo(self.bpPerPx / 2);
    },
    /**
     * #action
     */
    zoomTo(bpPerPx, offset = self.width / 2) {
        const newBpPerPx = (0, index_1.clamp)(bpPerPx, 'minBpPerPx' in self ? self.minBpPerPx : 0, 'maxBpPerPx' in self ? self.maxBpPerPx : Infinity);
        const oldBpPerPx = self.bpPerPx;
        if (Math.abs(oldBpPerPx - newBpPerPx) < 0.000001) {
            return oldBpPerPx;
        }
        self.bpPerPx = newBpPerPx;
        // tweak the offset so that the center of the view remains at the same
        // coordinate
        self.offsetPx = (0, index_1.clamp)(Math.round(((self.offsetPx + offset) * oldBpPerPx) / newBpPerPx - offset), self.minOffset, self.maxOffset);
        return self.bpPerPx;
    },
    /**
     * #action
     */
    scrollTo(offsetPx) {
        const newOffsetPx = (0, index_1.clamp)(offsetPx, self.minOffset, self.maxOffset);
        self.offsetPx = newOffsetPx;
        return newOffsetPx;
    },
    /**
     * #action
     */
    centerAt(coord, refName, regionNumber) {
        if (!refName) {
            return;
        }
        const centerPx = self.bpToPx({
            refName,
            coord,
            regionNumber,
        });
        if (centerPx) {
            this.scrollTo(Math.round(centerPx - self.width / 2));
        }
    },
    /**
     * #action
     * note: the scroll is clamped to keep the view on the main screen
     */
    scroll(distance) {
        const oldOffsetPx = self.offsetPx;
        const newOffsetPx = (0, index_1.clamp)(self.offsetPx + distance, self.minOffset, self.maxOffset);
        self.offsetPx = newOffsetPx;
        return newOffsetPx - oldOffsetPx;
    },
}))
    .actions(self => ({
    /**
     * #action
     * offset is the base-pair-offset in the displayed region, index is the index of the
     * displayed region in the linear genome view
     *
     * @param start - object as `{start, end, offset, index}`
     * @param end - object as `{start, end, offset, index}`
     */
    moveTo(start, end) {
        (0, Base1DUtils_1.moveTo)(self, start, end);
    },
}));
exports.default = Base1DView;
