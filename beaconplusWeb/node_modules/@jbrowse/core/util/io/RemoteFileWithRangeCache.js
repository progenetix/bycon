"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteFileWithRangeCache = exports.clearCache = void 0;
const http_range_fetcher_1 = require("http-range-fetcher");
const buffer_1 = require("buffer");
const generic_filehandle_1 = require("generic-filehandle");
const fetchers = {};
function binaryRangeFetch(url, start, end, options = {}) {
    const fetcher = fetchers[url];
    if (!fetcher) {
        throw new Error(`fetch not registered for ${url}`);
    }
    return fetcher(url, start, end, options);
}
const globalRangeCache = new http_range_fetcher_1.HttpRangeFetcher({
    fetch: binaryRangeFetch,
    size: 500 * 1024 ** 2, // 500MiB
    chunkSize: 128 * 1024, // 128KiB
    maxFetchSize: 100 * 1024 ** 2, // 100MiB
    minimumTTL: 24 * 60 * 60 * 1000, // 1 day
});
function clearCache() {
    globalRangeCache.reset();
}
exports.clearCache = clearCache;
class RemoteFileWithRangeCache extends generic_filehandle_1.RemoteFile {
    async fetch(url, init) {
        var _a;
        const str = String(url);
        if (!fetchers[str]) {
            fetchers[str] = this.fetchBinaryRange.bind(this);
        }
        // if it is a range request, route it through the range cache
        const range = (_a = new Headers(init === null || init === void 0 ? void 0 : init.headers)) === null || _a === void 0 ? void 0 : _a.get('range');
        if (range) {
            const rangeParse = /bytes=(\d+)-(\d+)/.exec(range);
            if (rangeParse) {
                const [, start, end] = rangeParse;
                const s = Number.parseInt(start, 10);
                const e = Number.parseInt(end, 10);
                const len = e - s;
                const { buffer, headers } = (await globalRangeCache.getRange(url, s, len + 1, { signal: init === null || init === void 0 ? void 0 : init.signal }));
                return new Response(buffer, { status: 206, headers });
            }
        }
        return super.fetch(url, init);
    }
    async fetchBinaryRange(url, start, end, options = {}) {
        const requestDate = new Date();
        const res = await super.fetch(url, {
            ...options,
            headers: {
                ...options.headers,
                range: `bytes=${start}-${end}`,
            },
        });
        const responseDate = new Date();
        if (!res.ok) {
            const errorMessage = `HTTP ${res.status} fetching ${url} bytes ${start}-${end}`;
            const hint = ' (should be 206 for range requests)';
            throw new Error(`${errorMessage}${res.status === 200 ? hint : ''}`);
        }
        // translate the Headers object into a regular key -> value object.
        // will miss duplicate headers of course
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const headers = {};
        for (const [k, v] of res.headers.entries()) {
            headers[k] = v;
        }
        // return the response headers, and the data buffer
        const arrayBuffer = await res.arrayBuffer();
        return {
            headers,
            requestDate,
            responseDate,
            buffer: buffer_1.Buffer.from(arrayBuffer),
        };
    }
}
exports.RemoteFileWithRangeCache = RemoteFileWithRangeCache;
