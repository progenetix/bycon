"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteFileWithRangeCache = exports.getFetcher = exports.openLocation = exports.resolveUriLocation = void 0;
const generic_filehandle_1 = require("generic-filehandle");
const detect_node_1 = __importDefault(require("detect-node"));
// locals
const RemoteFileWithRangeCache_1 = require("./RemoteFileWithRangeCache");
const types_1 = require("../types");
const tracks_1 = require("../tracks");
const __1 = require("../");
function isLocalPathLocation(location) {
    return 'localPath' in location;
}
function isBlobLocation(location) {
    return 'blobId' in location;
}
/** if a UriLocation has a baseUri, resolves its uri with respect to that base */
function resolveUriLocation(location) {
    return location.baseUri
        ? { ...location, uri: new URL(location.uri, location.baseUri).href }
        : location;
}
exports.resolveUriLocation = resolveUriLocation;
function openLocation(location, pluginManager) {
    if (!location) {
        throw new Error('must provide a location to openLocation');
    }
    if (isLocalPathLocation(location)) {
        if (!location.localPath) {
            throw new Error('No local path provided');
        }
        if (detect_node_1.default || __1.isElectron) {
            return new generic_filehandle_1.LocalFile(location.localPath);
        }
        else {
            throw new Error("can't use local files in the browser");
        }
    }
    if (isBlobLocation(location)) {
        // special case where blob is not directly stored on the model, use a getter
        const blob = (0, tracks_1.getBlob)(location.blobId);
        if (!blob) {
            throw new Error(`file ("${location.name}") was opened locally from a previous session. To restore it, go to track settings and reopen the file`);
        }
        return new generic_filehandle_1.BlobFile(blob);
    }
    if ((0, types_1.isUriLocation)(location)) {
        // Check for empty string
        if (!location.uri) {
            throw new Error('No URI provided');
        }
        // Resolve any relative URLs to absolute URLs
        const absoluteLocation = resolveUriLocation(location);
        // If there is a plugin manager, we can try internet accounts
        if (pluginManager) {
            const internetAccount = getInternetAccount(location, pluginManager);
            // If an internetAccount was found, use it to open the location
            if (internetAccount) {
                return internetAccount.openLocation(absoluteLocation);
            }
        }
        // Otherwise fall back on usual open
        return new RemoteFileWithRangeCache_1.RemoteFileWithRangeCache(absoluteLocation.uri, {
            fetch: checkAuthNeededFetch,
        });
    }
    throw new Error('invalid fileLocation');
}
exports.openLocation = openLocation;
function getFetcher(location, pluginManager) {
    if (!(0, types_1.isUriLocation)(location)) {
        throw new Error(`Not a valid UriLocation: ${JSON.stringify(location)}`);
    }
    if (pluginManager) {
        const internetAccount = getInternetAccount(location, pluginManager);
        if (internetAccount) {
            return internetAccount.getFetcher(location);
        }
    }
    return checkAuthNeededFetch;
}
exports.getFetcher = getFetcher;
function getInternetAccount(location, pluginManager) {
    const { rootModel } = pluginManager;
    // If there is an appRootModel, use it to find the internetAccount
    if (rootModel && (0, types_1.isRootModelWithInternetAccounts)(rootModel)) {
        return rootModel.findAppropriateInternetAccount(location);
    }
    // If there is no appRootModel, but there is pre-auth, create a temporary
    // internetAccount. This is typical in a worker.
    if (location.internetAccountPreAuthorization) {
        if (!location.internetAccountPreAuthorization.authInfo.token) {
            throw new Error('Failed to obtain token from internet account. Try reloading the page');
        }
        const internetAccountType = pluginManager.getInternetAccountType(location.internetAccountPreAuthorization.internetAccountType);
        return internetAccountType.stateModel.create({
            type: location.internetAccountPreAuthorization.internetAccountType,
            configuration: location.internetAccountPreAuthorization.authInfo.configuration,
        });
    }
    return undefined;
}
// This fetch throws a special error if the response is "401" and includes a
// "WWW-Authenticate: Basic" header. This is so downstream code can retry if
// needed with HTTP Basic authentication included
async function checkAuthNeededFetch(url, opts) {
    var _a;
    const response = await fetch(url, opts);
    if (response.status === 401 &&
        ((_a = response.headers.get('WWW-Authenticate')) === null || _a === void 0 ? void 0 : _a.includes('Basic'))) {
        throw new types_1.AuthNeededError('Accessing HTTPBasic resource without authentication', url.toString());
    }
    return response;
}
var RemoteFileWithRangeCache_2 = require("./RemoteFileWithRangeCache");
Object.defineProperty(exports, "RemoteFileWithRangeCache", { enumerable: true, get: function () { return RemoteFileWithRangeCache_2.RemoteFileWithRangeCache; } });
