import React from 'react';
import { Instance, SnapshotIn, IAnyStateTreeNode, IStateTreeNode, IType } from 'mobx-state-tree';
import { AnyConfigurationModel } from '../../configuration';
import assemblyManager from '../../assemblyManager';
import TextSearchManager from '../../TextSearch/TextSearchManager';
import { MenuItem } from '../../ui';
import { NoAssemblyRegion as MUNoAssemblyRegion, Region as MUIRegion, LocalPathLocation as MULocalPathLocation, UriLocation as MUUriLocation, BlobLocation as MUBlobLocation } from './mst';
import RpcManager from '../../rpc/RpcManager';
import { Feature } from '../simpleFeature';
import { BaseInternetAccountModel } from '../../pluggableElementTypes/models';
import { ThemeOptions } from '@mui/material';
export * from './util';
/** abstract type for a model that contains multiple views */
export interface AbstractViewContainer extends IStateTreeNode<IType<any, unknown, any>> {
    views: AbstractViewModel[];
    removeView(view: AbstractViewModel): void;
    addView(typeName: string, initialState?: Record<string, unknown>): AbstractViewModel;
}
export declare function isViewContainer(thing: unknown): thing is AbstractViewContainer;
export type NotificationLevel = 'error' | 'info' | 'warning' | 'success';
export interface SnackAction {
    name: React.ReactElement;
    onClick: () => void;
}
export type AssemblyManager = Instance<ReturnType<typeof assemblyManager>>;
export interface BasePlugin {
    version?: string;
    name: string;
    url?: string;
}
export interface JBrowsePlugin {
    name: string;
    authors: string[];
    description: string;
    location: string;
    url?: string;
    umdUrl?: string;
    esmUrl?: string;
    cjsUrl?: string;
    license: string;
    image?: string;
}
export type DialogComponentType = React.LazyExoticComponent<React.FC<any>> | React.FC<any>;
/** minimum interface that all session state models must implement */
export interface AbstractSessionModel extends AbstractViewContainer {
    jbrowse: IAnyStateTreeNode;
    drawerPosition?: string;
    configuration: AnyConfigurationModel;
    rpcManager: RpcManager;
    assemblyNames: string[];
    assemblies: AnyConfigurationModel[];
    selection?: unknown;
    focusedViewId?: string;
    themeName?: string;
    hovered: unknown;
    setHovered: (arg: unknown) => void;
    setFocusedViewId?: (id: string) => void;
    allThemes?: () => Record<string, ThemeOptions | undefined>;
    setSelection: (feature: Feature) => void;
    setSession?: (arg: {
        name: string;
        [key: string]: unknown;
    }) => void;
    clearSelection: () => void;
    duplicateCurrentSession?: () => void;
    notify: (message: string, level?: NotificationLevel, action?: SnackAction) => void;
    notifyError: (message: string, error?: unknown, extra?: unknown) => void;
    assemblyManager: AssemblyManager;
    version: string;
    getTrackActionMenuItems?: Function;
    addAssembly?: Function;
    removeAssembly?: Function;
    textSearchManager?: TextSearchManager;
    connections: AnyConfigurationModel[];
    deleteConnection?: Function;
    temporaryAssemblies?: unknown[];
    addTemporaryAssembly?: (arg: Record<string, unknown>) => void;
    removeTemporaryAssembly?: (arg: string) => void;
    sessionConnections?: AnyConfigurationModel[];
    sessionTracks?: AnyConfigurationModel[];
    connectionInstances?: {
        name: string;
        tracks: AnyConfigurationModel[];
        configuration: AnyConfigurationModel;
    }[];
    makeConnection?: Function;
    breakConnection?: Function;
    prepareToBreakConnection?: (arg: AnyConfigurationModel) => any;
    adminMode?: boolean;
    showWidget?: Function;
    addWidget?: Function;
    DialogComponent?: DialogComponentType;
    DialogProps: any;
    queueDialog<T extends DialogComponentType>(callback: (doneCallback: () => void) => [T, React.ComponentProps<T>]): void;
    name: string;
    id?: string;
    tracks: AnyConfigurationModel[];
}
export declare function isSessionModel(thing: unknown): thing is AbstractSessionModel;
/** abstract interface for a session allows editing configurations */
export interface SessionWithConfigEditing extends AbstractSessionModel {
    editConfiguration(configuration: AnyConfigurationModel): void;
}
export declare function isSessionModelWithConfigEditing(thing: unknown): thing is SessionWithConfigEditing;
/** abstract interface for a session allows adding tracks */
export interface SessionWithConfigEditing extends AbstractSessionModel {
    addTrackConf(configuration: AnyConfigurationModel | SnapshotIn<AnyConfigurationModel>): void;
}
export declare function isSessionWithAddTracks(thing: unknown): thing is SessionWithConfigEditing;
/** abstract interface for a session allows adding tracks */
export interface SessionWithShareURL extends AbstractSessionModel {
    shareURL: string;
}
export declare function isSessionWithShareURL(thing: unknown): thing is SessionWithShareURL;
export interface Widget {
    type: string;
    id: string;
}
/** abstract interface for a session that manages widgets */
export interface SessionWithWidgets extends AbstractSessionModel {
    minimized: boolean;
    visibleWidget?: Widget;
    widgets: Map<string | number, Widget>;
    hideAllWidgets: () => void;
    activeWidgets: Map<string | number, Widget>;
    addWidget(typeName: string, id: string, initialState?: Record<string, unknown>, configuration?: {
        type: string;
    }): Widget;
    showWidget(widget: unknown): void;
    hideWidget(widget: unknown): void;
}
export interface SessionWithDrawerWidgets extends SessionWithWidgets {
    drawerWidth: number;
    resizeDrawer(arg: number): number;
    minimizeWidgetDrawer(): void;
    showWidgetDrawer: () => void;
    drawerPosition: string;
    setDrawerPosition(arg: string): void;
}
export declare function isSessionModelWithWidgets(thing: unknown): thing is SessionWithWidgets;
interface SessionWithConnections {
    makeConnection: (arg: AnyConfigurationModel) => void;
}
export declare function isSessionModelWithConnections(thing: unknown): thing is SessionWithConnections;
interface SessionWithConnectionEditing {
    addConnectionConf: (arg: AnyConfigurationModel) => void;
}
export declare function isSessionModelWithConnectionEditing(thing: unknown): thing is SessionWithConnectionEditing;
export interface SessionWithSessionPlugins extends AbstractSessionModel {
    sessionPlugins: JBrowsePlugin[];
    addSessionPlugin: Function;
    removeSessionPlugin: Function;
}
export declare function isSessionWithSessionPlugins(thing: unknown): thing is SessionWithSessionPlugins;
/** abstract interface for a session that manages a global selection */
export interface SelectionContainer extends AbstractSessionModel {
    selection?: unknown;
    setSelection(thing: unknown): void;
}
export declare function isSelectionContainer(thing: unknown): thing is SelectionContainer;
/** abstract interface for a session allows applying focus to views and widgets */
export interface SessionWithFocusedViewAndDrawerWidgets extends SessionWithDrawerWidgets {
    focusedViewId: string | undefined;
    setFocusedViewId(id: string): void;
}
/** minimum interface that all view state models must implement */
export interface AbstractViewModel {
    id: string;
    type: string;
    width: number;
    minimized: boolean;
    setWidth(width: number): void;
    setMinimized(flag: boolean): void;
    displayName: string | undefined;
    setDisplayName: (arg: string) => void;
    menuItems: () => MenuItem[];
}
export declare function isViewModel(thing: unknown): thing is AbstractViewModel;
export interface AbstractTrackModel {
    displays: AbstractDisplayModel[];
    configuration: AnyConfigurationModel;
}
export declare function isTrackModel(thing: unknown): thing is AbstractTrackModel;
export interface AbstractDisplayModel {
    id: string;
    parentTrack: AbstractTrackModel;
    renderDelay: number;
    rendererType: any;
    cannotBeRenderedReason?: string;
}
export declare function isDisplayModel(thing: unknown): thing is AbstractDisplayModel;
export interface TrackViewModel extends AbstractViewModel {
    showTrack(trackId: string): void;
    hideTrack(trackId: string): void;
}
export declare function isTrackViewModel(thing: unknown): thing is TrackViewModel;
/** minimum interface for the root MST model of a JBrowse app */
export interface AbstractRootModel {
    jbrowse: IAnyStateTreeNode;
    session?: AbstractSessionModel;
    setDefaultSession?(): void;
    adminMode?: boolean;
    error?: unknown;
}
/** root model with more included for the heavier JBrowse web and desktop app */
export interface AppRootModel extends AbstractRootModel {
    internetAccounts: BaseInternetAccountModel[];
    findAppropriateInternetAccount(location: UriLocation): BaseInternetAccountModel | undefined;
}
export declare function isAppRootModel(thing: unknown): thing is AppRootModel;
export interface RootModelWithInternetAccounts extends AbstractRootModel {
    internetAccounts: BaseInternetAccountModel[];
    findAppropriateInternetAccount(location: UriLocation): BaseInternetAccountModel | undefined;
}
export declare function isRootModelWithInternetAccounts(thing: unknown): thing is RootModelWithInternetAccounts;
/** a root model that manages global menus */
export interface AbstractMenuManager {
    appendMenu(menuName: string): void;
    insertMenu(menuName: string, position: number): number;
    insertInMenu(menuName: string, menuItem: MenuItem, position: number): number;
    appendToMenu(menuName: string, menuItem: MenuItem): number;
    appendToSubMenu(menuPath: string[], menuItem: MenuItem): number;
    insertInSubMenu(menuPath: string[], menuItem: MenuItem, position: number): number;
}
export declare function isAbstractMenuManager(thing: unknown): thing is AbstractMenuManager;
export interface NoAssemblyRegion extends SnapshotIn<typeof MUNoAssemblyRegion> {
}
/** a description of a specific genomic region. assemblyName, refName, start, end, and reversed */
export interface Region extends SnapshotIn<typeof MUIRegion> {
}
export interface AugmentedRegion extends Region {
    originalRefName?: string;
}
export interface LocalPathLocation extends SnapshotIn<typeof MULocalPathLocation> {
}
export interface UriLocation extends SnapshotIn<typeof MUUriLocation> {
}
export declare function isUriLocation(location: unknown): location is UriLocation;
export declare function isLocalPathLocation(location: unknown): location is LocalPathLocation;
export declare function isBlobLocation(location: unknown): location is BlobLocation;
export declare class AuthNeededError extends Error {
    message: string;
    url: string;
    constructor(message: string, url: string);
}
export declare class RetryError extends Error {
    message: string;
    internetAccountId: string;
    constructor(message: string, internetAccountId: string);
}
export declare function isAuthNeededException(exception: unknown): exception is AuthNeededError;
export declare function isRetryException(exception: Error): boolean;
export interface BlobLocation extends SnapshotIn<typeof MUBlobLocation> {
}
export type FileLocation = LocalPathLocation | UriLocation | BlobLocation;
export interface PreUriLocation {
    uri: string;
}
export interface PreLocalPathLocation {
    localPath: string;
}
export interface PreBlobLocation {
    blob: File;
}
export type PreFileLocation = PreUriLocation | PreLocalPathLocation | PreBlobLocation;
export { type default as TextSearchManager } from '../../TextSearch/TextSearchManager';
