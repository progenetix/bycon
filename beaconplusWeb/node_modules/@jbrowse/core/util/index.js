"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBpDisplayStr = exports.isSupportedIndexingAdapter = exports.bytesForRegions = exports.objectHash = exports.hashCode = exports.updateStatus = exports.generateCodonTable = exports.defaultCodonTable = exports.defaultStops = exports.defaultStarts = exports.getFrame = exports.measureText = exports.rIC = exports.complement = exports.reverse = exports.revcom = exports.isElectron = exports.stringify = exports.shorten = exports.minmax = exports.renameRegionsIfNeeded = exports.renameRegionIfNeeded = exports.makeAbortableReaction = exports.findLast = exports.findLastIndex = exports.iterMap = exports.bpSpanPx = exports.featureSpanPx = exports.cartesianToPolar = exports.polarToCartesian = exports.degToRad = exports.radToDeg = exports.bpToPx = exports.clamp = exports.compareLocStrings = exports.compareLocs = exports.parseLocString = exports.parseLocStringOneBased = exports.assembleLocStringFast = exports.assembleLocString = exports.getContainingDisplay = exports.getContainingTrack = exports.getContainingView = exports.getSession = exports.findParentThatIs = exports.springAnimate = exports.findParentThat = exports.useDebouncedCallback = exports.useWidthSetter = exports.useDebounce = void 0;
exports.blobToDataURL = exports.isFeature = exports.SimpleFeature = exports.renderToStaticMarkup = exports.getFillProps = exports.getStrokeProps = exports.stripAlpha = exports.gatherOverlaps = exports.mergeIntervals = exports.notEmpty = exports.groupBy = exports.avg = exports.sum = exports.min = exports.max = exports.localStorageSetItem = exports.localStorageGetItem = exports.getEnv = exports.measureGridWidth = exports.linkify = exports.coarseStripHTML = exports.getStr = exports.getUriLink = exports.useLocalStorage = exports.getLayoutId = exports.getViewParams = exports.getTickDisplayStr = exports.toLocale = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const react_1 = require("react");
const is_object_1 = __importDefault(require("is-object"));
const mobx_state_tree_1 = require("mobx-state-tree");
const mobx_1 = require("mobx");
const types_1 = require("./types");
const aborting_1 = require("./aborting");
const types_2 = require("./types");
// has to be the full path and not the relative path to get the jest mock
const useMeasure_1 = __importDefault(require("@jbrowse/core/util/useMeasure"));
const colord_1 = require("./colord");
// eslint-disable-next-line react/no-deprecated
const react_dom_1 = require("react-dom");
__exportStar(require("./types"), exports);
__exportStar(require("./aborting"), exports);
__exportStar(require("./when"), exports);
__exportStar(require("./range"), exports);
__exportStar(require("./dedupe"), exports);
__exportStar(require("./offscreenCanvasPonyfill"), exports);
__exportStar(require("./offscreenCanvasUtils"), exports);
function useDebounce(value, delay) {
    const [debouncedValue, setDebouncedValue] = (0, react_1.useState)(value);
    (0, react_1.useEffect)(() => {
        const handle = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);
        return () => {
            clearTimeout(handle);
        };
    }, [value, delay]);
    return debouncedValue;
}
exports.useDebounce = useDebounce;
// used in ViewContainer files to get the width
function useWidthSetter(view, padding) {
    const [ref, { width }] = (0, useMeasure_1.default)();
    (0, react_1.useEffect)(() => {
        if (width && (0, mobx_state_tree_1.isAlive)(view)) {
            // sets after a requestAnimationFrame
            // https://stackoverflow.com/a/58701523/2129219
            // avoids ResizeObserver loop error being shown during development
            requestAnimationFrame(() => view.setWidth(width - Number.parseInt(padding, 10) * 2));
        }
    }, [padding, view, width]);
    return ref;
}
exports.useWidthSetter = useWidthSetter;
// https://stackoverflow.com/questions/56283920/
function useDebouncedCallback(callback, wait = 400) {
    // track args & timeout handle between calls
    const argsRef = (0, react_1.useRef)();
    const timeout = (0, react_1.useRef)();
    function cleanup() {
        if (timeout.current) {
            clearTimeout(timeout.current);
        }
    }
    // make sure our timeout gets cleared if our consuming component gets
    // unmounted
    (0, react_1.useEffect)(() => cleanup, []);
    return function debouncedCallback(...args) {
        // capture latest args
        argsRef.current = args;
        // clear debounce timer
        cleanup();
        // start waiting again
        timeout.current = setTimeout(() => {
            if (argsRef.current) {
                callback(...argsRef.current);
            }
        }, wait);
    };
}
exports.useDebouncedCallback = useDebouncedCallback;
/**
 * find the first node in the hierarchy that matches the given predicate
 */
function findParentThat(node, predicate) {
    if (!(0, mobx_state_tree_1.hasParent)(node)) {
        throw new Error('node does not have parent');
    }
    let currentNode = (0, mobx_state_tree_1.getParent)(node);
    while (currentNode && (0, mobx_state_tree_1.isAlive)(currentNode)) {
        if (predicate(currentNode)) {
            return currentNode;
        }
        if ((0, mobx_state_tree_1.hasParent)(currentNode)) {
            currentNode = (0, mobx_state_tree_1.getParent)(currentNode);
        }
        else {
            break;
        }
    }
    throw new Error('no matching node found');
}
exports.findParentThat = findParentThat;
// based on https://github.com/react-spring/react-spring/blob/cd5548a987383b8023efd620f3726a981f9e18ea/src/animated/FrameLoop.ts
function springAnimate(fromValue, toValue, setValue, onFinish = () => { }, precision = 0, tension = 400, friction = 20, clamp = true) {
    const mass = 1;
    if (!precision) {
        precision = Math.abs(toValue - fromValue) / 1000;
    }
    let animationFrameId;
    function update(animation) {
        const time = Date.now();
        let position = animation.lastPosition;
        let lastTime = animation.lastTime || time;
        let velocity = animation.lastVelocity || 0;
        // If we lost a lot of frames just jump to the end.
        if (time > lastTime + 64) {
            lastTime = time;
        }
        // http://gafferongames.com/game-physics/fix-your-timestep/
        const numSteps = Math.floor(time - lastTime);
        for (let i = 0; i < numSteps; ++i) {
            const force = -tension * (position - toValue);
            const damping = -friction * velocity;
            const acceleration = (force + damping) / mass;
            velocity += (acceleration * 1) / 1000;
            position += (velocity * 1) / 1000;
        }
        const isVelocity = Math.abs(velocity) <= precision;
        const isDisplacement = tension !== 0 ? Math.abs(toValue - position) <= precision : true;
        const isOvershooting = clamp && tension !== 0
            ? fromValue < toValue
                ? position > toValue
                : position < toValue
            : false;
        const endOfAnimation = isOvershooting || (isVelocity && isDisplacement);
        if (endOfAnimation) {
            setValue(toValue);
            onFinish();
        }
        else {
            setValue(position);
            animationFrameId = requestAnimationFrame(() => update({
                lastPosition: position,
                lastTime: time,
                lastVelocity: velocity,
            }));
        }
    }
    return [
        () => update({ lastPosition: fromValue }),
        () => cancelAnimationFrame(animationFrameId),
    ];
}
exports.springAnimate = springAnimate;
/**
 * find the first node in the hierarchy that matches the given 'is' typescript
 * type guard predicate
 */
function findParentThatIs(node, predicate) {
    return findParentThat(node, predicate);
}
exports.findParentThatIs = findParentThatIs;
/**
 * get the current JBrowse session model, starting at any node in the state
 * tree
 */
function getSession(node) {
    try {
        return findParentThatIs(node, types_1.isSessionModel);
    }
    catch (e) {
        throw new Error('no session model found!');
    }
}
exports.getSession = getSession;
/**
 * get the state model of the view in the state tree that contains the given
 * node
 */
function getContainingView(node) {
    try {
        return findParentThatIs(node, types_1.isViewModel);
    }
    catch (e) {
        throw new Error('no containing view found');
    }
}
exports.getContainingView = getContainingView;
/**
 * get the state model of the view in the state tree that contains the given
 * node
 */
function getContainingTrack(node) {
    try {
        return findParentThatIs(node, types_1.isTrackModel);
    }
    catch (e) {
        throw new Error('no containing track found');
    }
}
exports.getContainingTrack = getContainingTrack;
/**
 * get the state model of the display in the state tree that contains the given
 * node
 */
function getContainingDisplay(node) {
    try {
        return findParentThatIs(node, types_1.isDisplayModel);
    }
    catch (e) {
        throw new Error('no containing display found');
    }
}
exports.getContainingDisplay = getContainingDisplay;
/**
 * Assemble a 1-based "locString" from an interbase genomic location
 * @param region - Region
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0, end: 100 })
 * // ↳ 'chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ assemblyName: 'hg19', refName: 'chr1', start: 0, end: 100 })
 * // ↳ '{hg19}chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1' })
 * // ↳ 'chr1'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0 })
 * // ↳ 'chr1:1..'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', end: 100 })
 * // ↳ 'chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0, end: 1 })
 * // ↳ 'chr1:1'
 * ```
 */
function assembleLocString(region) {
    return assembleLocStringFast(region, toLocale);
}
exports.assembleLocString = assembleLocString;
// same as assembleLocString above, but does not perform toLocaleString which
// can slow down the speed of block calculations which use assembleLocString
// for block.key
function assembleLocStringFast(region, cb = (n) => n) {
    const { assemblyName, refName, start, end, reversed } = region;
    const assemblyNameString = assemblyName ? `{${assemblyName}}` : '';
    let startString;
    if (start !== undefined) {
        startString = `:${cb(start + 1)}`;
    }
    else if (end !== undefined) {
        startString = ':1';
    }
    else {
        startString = '';
    }
    let endString;
    if (end !== undefined) {
        endString = start !== undefined && start + 1 === end ? '' : `..${cb(end)}`;
    }
    else {
        endString = start !== undefined ? '..' : '';
    }
    let rev = '';
    if (reversed) {
        rev = '[rev]';
    }
    return `${assemblyNameString}${refName}${startString}${endString}${rev}`;
}
exports.assembleLocStringFast = assembleLocStringFast;
function parseLocStringOneBased(locString, isValidRefName) {
    if (!locString) {
        throw new Error('no location string provided, could not parse');
    }
    let reversed = false;
    if (locString.endsWith('[rev]')) {
        reversed = true;
        locString = locString.replace(/\[rev]$/, '');
    }
    // remove any whitespace
    locString = locString.replace(/\s/, '');
    // refNames can have colons, ref https://samtools.github.io/hts-specs/SAMv1.pdf Appendix A
    const assemblyMatch = locString.match(/({(.+)})?(.+)/);
    if (!assemblyMatch) {
        throw new Error(`invalid location string: "${locString}"`);
    }
    const [, , assemblyName, location] = assemblyMatch;
    if (!assemblyName && location.startsWith('{}')) {
        throw new Error(`no assembly name was provided in location "${location}"`);
    }
    const lastColonIdx = location.lastIndexOf(':');
    if (lastColonIdx === -1) {
        if (isValidRefName(location, assemblyName)) {
            return { assemblyName, refName: location, reversed };
        }
        throw new Error(`Unknown reference sequence "${location}"`);
    }
    const prefix = location.slice(0, lastColonIdx);
    const suffix = location.slice(lastColonIdx + 1);
    if (isValidRefName(prefix, assemblyName) &&
        isValidRefName(location, assemblyName)) {
        throw new Error(`ambiguous location string: "${locString}"`);
    }
    else if (isValidRefName(prefix, assemblyName)) {
        if (suffix) {
            // see if it's a range
            const rangeMatch = suffix.match(/^(-?(\d+|\d{1,3}(,\d{3})*))(\.\.|-)(-?(\d+|\d{1,3}(,\d{3})*))$/);
            // see if it's a single point
            const singleMatch = suffix.match(/^(-?(\d+|\d{1,3}(,\d{3})*))(\.\.|-)?$/);
            if (rangeMatch) {
                const [, start, , , , end] = rangeMatch;
                if (start !== undefined && end !== undefined) {
                    return {
                        assemblyName,
                        refName: prefix,
                        start: +start.replaceAll(',', ''),
                        end: +end.replaceAll(',', ''),
                        reversed,
                    };
                }
            }
            else if (singleMatch) {
                const [, start, , , separator] = singleMatch;
                if (start !== undefined) {
                    if (separator) {
                        // indefinite end
                        return {
                            assemblyName,
                            refName: prefix,
                            start: +start.replaceAll(',', ''),
                            reversed,
                        };
                    }
                    return {
                        assemblyName,
                        refName: prefix,
                        start: +start.replaceAll(',', ''),
                        end: +start.replaceAll(',', ''),
                        reversed,
                    };
                }
            }
            else {
                throw new Error(`could not parse range "${suffix}" on location "${locString}"`);
            }
        }
        else {
            return { assemblyName, refName: prefix, reversed };
        }
    }
    else if (isValidRefName(location, assemblyName)) {
        return { assemblyName, refName: location, reversed };
    }
    throw new Error(`unknown reference sequence name in location "${locString}"`);
}
exports.parseLocStringOneBased = parseLocStringOneBased;
/**
 * Parse a 1-based location string into an interbase genomic location
 * @param locString - Location string
 * @param isValidRefName - Function that checks if a refName exists in the set
 * of all known refNames, or in the set of refNames for an assembly if
 * assemblyName is given
 * @example
 * ```ts
 * parseLocString('chr1:1..100', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1-100', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString(`{hg19}chr1:1..100`, isValidRefName)
 * // ↳ { assemblyName: 'hg19', refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1', isValidRefName)
 * // ↳ { refName: 'chr1' }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 1 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1..', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0}
 * ```
 */
function parseLocString(locString, isValidRefName) {
    const parsed = parseLocStringOneBased(locString, isValidRefName);
    if (typeof parsed.start === 'number') {
        parsed.start -= 1;
    }
    return parsed;
}
exports.parseLocString = parseLocString;
function compareLocs(locA, locB) {
    const assemblyComp = locA.assemblyName || locB.assemblyName
        ? (locA.assemblyName || '').localeCompare(locB.assemblyName || '')
        : 0;
    if (assemblyComp) {
        return assemblyComp;
    }
    const refComp = locA.refName || locB.refName
        ? (locA.refName || '').localeCompare(locB.refName || '')
        : 0;
    if (refComp) {
        return refComp;
    }
    if (locA.start !== undefined && locB.start !== undefined) {
        const startComp = locA.start - locB.start;
        if (startComp) {
            return startComp;
        }
    }
    if (locA.end !== undefined && locB.end !== undefined) {
        const endComp = locA.end - locB.end;
        if (endComp) {
            return endComp;
        }
    }
    return 0;
}
exports.compareLocs = compareLocs;
function compareLocStrings(a, b, isValidRefName) {
    const locA = parseLocString(a, isValidRefName);
    const locB = parseLocString(b, isValidRefName);
    return compareLocs(locA, locB);
}
exports.compareLocStrings = compareLocStrings;
/**
 * Ensure that a number is at least min and at most max.
 *
 * @param num -
 * @param min -
 * @param  max -
 */
function clamp(num, min, max) {
    if (num < min) {
        return min;
    }
    if (num > max) {
        return max;
    }
    return num;
}
exports.clamp = clamp;
function roundToNearestPointOne(num) {
    return Math.round(num * 10) / 10;
}
/**
 * @param bp -
 * @param region -
 * @param bpPerPx -
 */
function bpToPx(bp, { reversed, end = 0, start = 0, }, bpPerPx) {
    return roundToNearestPointOne((reversed ? end - bp : bp - start) / bpPerPx);
}
exports.bpToPx = bpToPx;
const oneEightyOverPi = 180 / Math.PI;
const piOverOneEighty = Math.PI / 180;
function radToDeg(radians) {
    return (radians * oneEightyOverPi) % 360;
}
exports.radToDeg = radToDeg;
function degToRad(degrees) {
    return (degrees * piOverOneEighty) % (2 * Math.PI);
}
exports.degToRad = degToRad;
/**
 * @returns [x, y]
 */
function polarToCartesian(rho, theta) {
    return [rho * Math.cos(theta), rho * Math.sin(theta)];
}
exports.polarToCartesian = polarToCartesian;
/**
 * @param x - the x
 * @param y - the y
 * @returns [rho, theta]
 */
function cartesianToPolar(x, y) {
    const rho = Math.sqrt(x * x + y * y);
    const theta = Math.atan(y / x);
    return [rho, theta];
}
exports.cartesianToPolar = cartesianToPolar;
function featureSpanPx(feature, region, bpPerPx) {
    return bpSpanPx(feature.get('start'), feature.get('end'), region, bpPerPx);
}
exports.featureSpanPx = featureSpanPx;
function bpSpanPx(leftBp, rightBp, region, bpPerPx) {
    const start = bpToPx(leftBp, region, bpPerPx);
    const end = bpToPx(rightBp, region, bpPerPx);
    return region.reversed ? [end, start] : [start, end];
}
exports.bpSpanPx = bpSpanPx;
// do an array map of an iterable
function iterMap(iter, func, sizeHint) {
    const results = Array.from({ length: sizeHint || 0 });
    let counter = 0;
    for (const item of iter) {
        results[counter] = func(item);
        counter += 1;
    }
    return results;
}
exports.iterMap = iterMap;
/**
 * Returns the index of the last element in the array where predicate is true,
 * and -1 otherwise.
 * Based on https://stackoverflow.com/a/53187807
 *
 * @param array - The source array to search in
 *
 * @param predicate - find calls predicate once for each element of the array, in
 * descending order, until it finds one where predicate returns true.
 *
 * @returns findLastIndex returns element index where predicate is true.
 * Otherwise, findLastIndex returns -1.
 */
function findLastIndex(array, predicate) {
    let l = array.length;
    while (l--) {
        if (predicate(array[l], l, array)) {
            return l;
        }
    }
    return -1;
}
exports.findLastIndex = findLastIndex;
function findLast(array, predicate) {
    let l = array.length;
    while (l--) {
        if (predicate(array[l], l, array)) {
            return array[l];
        }
    }
    return undefined;
}
exports.findLast = findLast;
/**
 * makes a mobx reaction with the given functions, that calls actions on the
 * model for each stage of execution, and to abort the reaction function when
 * the model is destroyed.
 *
 * Will call startedFunction(signal), successFunction(result), and
 * errorFunction(error) when the async reaction function starts, completes, and
 * errors respectively.
 *
 * @param self -
 * @param dataFunction -
 * @param asyncReactionFunction -
 * @param reactionOptions -
 * @param startedFunction -
 * @param successFunction -
 * @param errorFunction -
 */
function makeAbortableReaction(self, dataFunction, asyncReactionFunction, 
// @ts-expect-error
reactionOptions, startedFunction, successFunction, errorFunction) {
    let inProgress;
    function handleError(error) {
        if (!(0, aborting_1.isAbortException)(error)) {
            if ((0, mobx_state_tree_1.isAlive)(self)) {
                errorFunction(error);
            }
            else {
                console.error(error);
            }
        }
    }
    (0, mobx_state_tree_1.addDisposer)(self, (0, mobx_1.reaction)(() => {
        try {
            return dataFunction(self);
        }
        catch (e) {
            handleError(e);
            return undefined;
        }
    }, async (data, mobxReactionHandle) => {
        if (inProgress && !inProgress.signal.aborted) {
            inProgress.abort();
        }
        if (!(0, mobx_state_tree_1.isAlive)(self)) {
            return;
        }
        inProgress = new AbortController();
        const thisInProgress = inProgress;
        startedFunction(thisInProgress);
        try {
            const result = await asyncReactionFunction(data, thisInProgress.signal, self, 
            // @ts-expect-error
            mobxReactionHandle);
            (0, aborting_1.checkAbortSignal)(thisInProgress.signal);
            if ((0, mobx_state_tree_1.isAlive)(self)) {
                successFunction(result);
            }
        }
        catch (e) {
            if (thisInProgress && !thisInProgress.signal.aborted) {
                thisInProgress.abort();
            }
            handleError(e);
        }
    }, reactionOptions));
    (0, mobx_state_tree_1.addDisposer)(self, () => {
        if (inProgress && !inProgress.signal.aborted) {
            inProgress.abort();
        }
    });
}
exports.makeAbortableReaction = makeAbortableReaction;
function renameRegionIfNeeded(refNameMap, region) {
    if ((0, mobx_state_tree_1.isStateTreeNode)(region) && !(0, mobx_state_tree_1.isAlive)(region)) {
        return region;
    }
    if (region && (refNameMap === null || refNameMap === void 0 ? void 0 : refNameMap[region.refName])) {
        // clone the region so we don't modify it
        region = (0, mobx_state_tree_1.isStateTreeNode)(region)
            ? { ...(0, mobx_state_tree_1.getSnapshot)(region) }
            : { ...region };
        // modify it directly in the container
        const newRef = refNameMap[region.refName];
        if (newRef) {
            return { ...region, refName: newRef, originalRefName: region.refName };
        }
    }
    return region;
}
exports.renameRegionIfNeeded = renameRegionIfNeeded;
async function renameRegionsIfNeeded(assemblyManager, args) {
    const { regions = [], adapterConfig } = args;
    if (!args.sessionId) {
        throw new Error('sessionId is required');
    }
    const assemblyNames = regions.map(region => region.assemblyName);
    const assemblyMaps = Object.fromEntries(await Promise.all([...new Set(assemblyNames)].map(async (assemblyName) => {
        return [
            assemblyName,
            await assemblyManager.getRefNameMapForAdapter(adapterConfig, assemblyName, args),
        ];
    })));
    return {
        ...args,
        regions: regions.map((region, i) => 
        // note: uses assemblyNames defined above since region could be dead now
        renameRegionIfNeeded(assemblyMaps[assemblyNames[i]], region)),
    };
}
exports.renameRegionsIfNeeded = renameRegionsIfNeeded;
function minmax(a, b) {
    return [Math.min(a, b), Math.max(a, b)];
}
exports.minmax = minmax;
function shorten(name, max = 70, short = 30) {
    return name.length > max
        ? name.slice(0, short) + '...' + name.slice(-short)
        : name;
}
exports.shorten = shorten;
function stringify({ refName, coord, assemblyName, oob, }, useAssemblyName) {
    return [
        assemblyName && useAssemblyName ? `{${assemblyName}}` : '',
        refName
            ? `${shorten(refName)}:${toLocale(coord)}${oob ? ' (out of bounds)' : ''}`
            : '',
    ].join('');
}
exports.stringify = stringify;
// this is recommended in a later comment in
// https://github.com/electron/electron/issues/2288 for detecting electron in a
// renderer process, which is the one that has node enabled for us
//
// const isElectron = process.versions.electron
// const i2 = process.versions.hasOwnProperty('electron')
exports.isElectron = /electron/i.test(typeof navigator !== 'undefined' ? navigator.userAgent : '');
function revcom(seqString) {
    return reverse((0, exports.complement)(seqString));
}
exports.revcom = revcom;
function reverse(seqString) {
    return seqString.split('').reverse().join('');
}
exports.reverse = reverse;
exports.complement = (() => {
    const complementRegex = /[ACGT]/gi;
    // from bioperl: tr/acgtrymkswhbvdnxACGTRYMKSWHBVDNX/tgcayrkmswdvbhnxTGCAYRKMSWDVBHNX/
    // generated with:
    // perl -MJSON -E '@l = split "","acgtrymkswhbvdnxACGTRYMKSWHBVDNX"; print to_json({ map { my $in = $_; tr/acgtrymkswhbvdnxACGTRYMKSWHBVDNX/tgcayrkmswdvbhnxTGCAYRKMSWDVBHNX/; $in => $_ } @l})'
    const complementTable = {
        S: 'S',
        w: 'w',
        T: 'A',
        r: 'y',
        a: 't',
        N: 'N',
        K: 'M',
        x: 'x',
        d: 'h',
        Y: 'R',
        V: 'B',
        y: 'r',
        M: 'K',
        h: 'd',
        k: 'm',
        C: 'G',
        g: 'c',
        t: 'a',
        A: 'T',
        n: 'n',
        W: 'W',
        X: 'X',
        m: 'k',
        v: 'b',
        B: 'V',
        s: 's',
        H: 'D',
        c: 'g',
        D: 'H',
        b: 'v',
        R: 'Y',
        G: 'C',
    };
    return (seqString) => {
        return seqString.replaceAll(complementRegex, m => complementTable[m] || '');
    };
})();
// requires immediate execution in jest environment, because (hypothesis) it
// otherwise listens for prerendered_canvas but reads empty pixels, and doesn't
// get the contents of the canvas
exports.rIC = typeof jest === 'undefined'
    ? typeof window !== 'undefined' && window.requestIdleCallback
        ? window.requestIdleCallback
        : (cb) => setTimeout(() => cb(), 1)
    : (cb) => cb();
// prettier-ignore
const widths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2796875, 0.2765625, 0.3546875, 0.5546875, 0.5546875, 0.8890625, 0.665625, 0.190625, 0.3328125, 0.3328125, 0.3890625, 0.5828125, 0.2765625, 0.3328125, 0.2765625, 0.3015625, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.2765625, 0.2765625, 0.584375, 0.5828125, 0.584375, 0.5546875, 1.0140625, 0.665625, 0.665625, 0.721875, 0.721875, 0.665625, 0.609375, 0.7765625, 0.721875, 0.2765625, 0.5, 0.665625, 0.5546875, 0.8328125, 0.721875, 0.7765625, 0.665625, 0.7765625, 0.721875, 0.665625, 0.609375, 0.721875, 0.665625, 0.94375, 0.665625, 0.665625, 0.609375, 0.2765625, 0.3546875, 0.2765625, 0.4765625, 0.5546875, 0.3328125, 0.5546875, 0.5546875, 0.5, 0.5546875, 0.5546875, 0.2765625, 0.5546875, 0.5546875, 0.221875, 0.240625, 0.5, 0.221875, 0.8328125, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.3328125, 0.5, 0.2765625, 0.5546875, 0.5, 0.721875, 0.5, 0.5, 0.5, 0.3546875, 0.259375, 0.353125, 0.5890625];
// xref https://gist.github.com/tophtucker/62f93a4658387bb61e4510c37e2e97cf
function measureText(str, fontSize = 10) {
    var _a;
    const avg = 0.5279276315789471;
    const s = String(str);
    let total = 0;
    for (let i = 0; i < s.length; i++) {
        const code = s.charCodeAt(i);
        total += (_a = widths[code]) !== null && _a !== void 0 ? _a : avg;
    }
    return total * fontSize;
}
exports.measureText = measureText;
function getFrame(start, end, strand, phase) {
    return strand === 1
        ? (((start + phase) % 3) + 1)
        : (-1 * ((end - phase) % 3) - 1);
}
exports.getFrame = getFrame;
exports.defaultStarts = ['ATG'];
exports.defaultStops = ['TAA', 'TAG', 'TGA'];
exports.defaultCodonTable = {
    TCA: 'S',
    TCC: 'S',
    TCG: 'S',
    TCT: 'S',
    TTC: 'F',
    TTT: 'F',
    TTA: 'L',
    TTG: 'L',
    TAC: 'Y',
    TAT: 'Y',
    TAA: '*',
    TAG: '*',
    TGC: 'C',
    TGT: 'C',
    TGA: '*',
    TGG: 'W',
    CTA: 'L',
    CTC: 'L',
    CTG: 'L',
    CTT: 'L',
    CCA: 'P',
    CCC: 'P',
    CCG: 'P',
    CCT: 'P',
    CAC: 'H',
    CAT: 'H',
    CAA: 'Q',
    CAG: 'Q',
    CGA: 'R',
    CGC: 'R',
    CGG: 'R',
    CGT: 'R',
    ATA: 'I',
    ATC: 'I',
    ATT: 'I',
    ATG: 'M',
    ACA: 'T',
    ACC: 'T',
    ACG: 'T',
    ACT: 'T',
    AAC: 'N',
    AAT: 'N',
    AAA: 'K',
    AAG: 'K',
    AGC: 'S',
    AGT: 'S',
    AGA: 'R',
    AGG: 'R',
    GTA: 'V',
    GTC: 'V',
    GTG: 'V',
    GTT: 'V',
    GCA: 'A',
    GCC: 'A',
    GCG: 'A',
    GCT: 'A',
    GAC: 'D',
    GAT: 'D',
    GAA: 'E',
    GAG: 'E',
    GGA: 'G',
    GGC: 'G',
    GGG: 'G',
    GGT: 'G',
};
/**
 * take CodonTable above and generate larger codon table that includes all
 * permutations of upper and lower case nucleotides
 */
function generateCodonTable(table) {
    const tempCodonTable = {};
    Object.keys(table).forEach(codon => {
        const aa = table[codon];
        const nucs = [];
        for (let i = 0; i < 3; i++) {
            const nuc = codon.charAt(i);
            nucs[i] = [];
            nucs[i][0] = nuc.toUpperCase();
            nucs[i][1] = nuc.toLowerCase();
        }
        for (let i = 0; i < 2; i++) {
            const n0 = nucs[0][i];
            for (let j = 0; j < 2; j++) {
                const n1 = nucs[1][j];
                for (let k = 0; k < 2; k++) {
                    const n2 = nucs[2][k];
                    const triplet = n0 + n1 + n2;
                    tempCodonTable[triplet] = aa;
                }
            }
        }
    });
    return tempCodonTable;
}
exports.generateCodonTable = generateCodonTable;
// call statusCallback with current status and clear when finished
async function updateStatus(msg, cb, fn) {
    cb(msg);
    const res = await fn();
    cb('');
    return res;
}
exports.updateStatus = updateStatus;
function hashCode(str) {
    let hash = 0;
    if (str.length === 0) {
        return hash;
    }
    for (let i = 0; i < str.length; i++) {
        const chr = str.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0; // Convert to 32bit integer
    }
    return hash;
}
exports.hashCode = hashCode;
function objectHash(obj) {
    return `${hashCode(JSON.stringify(obj))}`;
}
exports.objectHash = objectHash;
async function bytesForRegions(regions, index) {
    const blockResults = await Promise.all(regions.map(r => index.blocksForRange(r.refName, r.start, r.end)));
    return blockResults
        .flat()
        .map(block => ({
        start: block.minv.blockPosition,
        end: block.maxv.blockPosition + 65535,
    }))
        .reduce((a, b) => a + b.end - b.start, 0);
}
exports.bytesForRegions = bytesForRegions;
// supported adapter types by text indexer
//  ensure that this matches the method found in @jbrowse/text-indexing/util
function isSupportedIndexingAdapter(type) {
    return [
        'Gff3TabixAdapter',
        'VcfTabixAdapter',
        'Gff3Adapter',
        'VcfAdapter',
    ].includes(type);
}
exports.isSupportedIndexingAdapter = isSupportedIndexingAdapter;
function getBpDisplayStr(totalBp) {
    let str;
    if (Math.floor(totalBp / 1000000) > 0) {
        str = `${Number.parseFloat((totalBp / 1000000).toPrecision(3))}Mbp`;
    }
    else if (Math.floor(totalBp / 1000) > 0) {
        str = `${Number.parseFloat((totalBp / 1000).toPrecision(3))}Kbp`;
    }
    else {
        str = `${toLocale(Math.floor(totalBp))}bp`;
    }
    return str;
}
exports.getBpDisplayStr = getBpDisplayStr;
function toLocale(n) {
    return n.toLocaleString('en-US');
}
exports.toLocale = toLocale;
function getTickDisplayStr(totalBp, bpPerPx) {
    return Math.floor(bpPerPx / 1000) > 0
        ? `${toLocale(Number.parseFloat((totalBp / 1000000).toFixed(2)))}M`
        : `${toLocale(Math.floor(totalBp))}`;
}
exports.getTickDisplayStr = getTickDisplayStr;
function getViewParams(model, exportSVG) {
    // @ts-expect-error
    const { dynamicBlocks, staticBlocks, offsetPx } = getContainingView(model);
    const b = (dynamicBlocks === null || dynamicBlocks === void 0 ? void 0 : dynamicBlocks.contentBlocks[0]) || {};
    const staticblock = (staticBlocks === null || staticBlocks === void 0 ? void 0 : staticBlocks.contentBlocks[0]) || {};
    const staticblock1 = (staticBlocks === null || staticBlocks === void 0 ? void 0 : staticBlocks.contentBlocks[1]) || {};
    return {
        offsetPx: exportSVG ? 0 : offsetPx - staticblock.offsetPx,
        offsetPx1: exportSVG ? 0 : offsetPx - staticblock1.offsetPx,
        start: b.start,
        end: b.end,
    };
}
exports.getViewParams = getViewParams;
function getLayoutId({ sessionId, layoutId, }) {
    return sessionId + '-' + layoutId;
}
exports.getLayoutId = getLayoutId;
// Hook from https://usehooks.com/useLocalStorage/
function useLocalStorage(key, initialValue) {
    const [storedValue, setStoredValue] = (0, react_1.useState)(() => {
        if (typeof window === 'undefined') {
            return initialValue;
        }
        try {
            const item = window.localStorage.getItem(key);
            return item ? JSON.parse(item) : initialValue;
        }
        catch (error) {
            console.error(error);
            return initialValue;
        }
    });
    const setValue = (value) => {
        try {
            const valueToStore = value instanceof Function ? value(storedValue) : value;
            setStoredValue(valueToStore);
            if (typeof window !== 'undefined') {
                window.localStorage.setItem(key, JSON.stringify(valueToStore));
            }
        }
        catch (error) {
            console.error(error);
        }
    };
    return [storedValue, setValue];
}
exports.useLocalStorage = useLocalStorage;
function getUriLink(value) {
    const { uri, baseUri = '' } = value;
    let href;
    try {
        href = new URL(uri, baseUri).href;
    }
    catch (e) {
        href = uri;
    }
    return href;
}
exports.getUriLink = getUriLink;
function getStr(obj) {
    return (0, is_object_1.default)(obj)
        ? (0, types_2.isUriLocation)(obj)
            ? getUriLink(obj)
            : JSON.stringify(obj)
        : String(obj);
}
exports.getStr = getStr;
// tries to measure grid width without HTML tags included
function coarseStripHTML(s) {
    return s.replaceAll(/(<([^>]+)>)/gi, '');
}
exports.coarseStripHTML = coarseStripHTML;
// based on autolink-js, license MIT
function linkify(s) {
    const pattern = /(^|[\s\n]|<[A-Za-z]*\/?>)((?:https?|ftp):\/\/[-A-Z0-9+\u0026\u2019@#/%?=()~_|!:,.;]*[-A-Z0-9+\u0026@#/%=~()_|])/gi;
    return s.replaceAll(pattern, '$1<a href=\'$2\' target="_blank">$2</a>');
}
exports.linkify = linkify;
// heuristic measurement for a column of a @mui/x-data-grid, pass in values from a column
function measureGridWidth(elements, args) {
    const { padding = 30, minWidth = 80, fontSize = 12, maxWidth = 1000, stripHTML = false, } = args || {};
    return max(elements
        .map(element => getStr(element))
        .map(str => (stripHTML ? coarseStripHTML(str) : str))
        .map(str => measureText(str, fontSize))
        .map(n => Math.min(Math.max(n + padding, minWidth), maxWidth)));
}
exports.measureGridWidth = measureGridWidth;
function getEnv(obj) {
    return (0, mobx_state_tree_1.getEnv)(obj);
}
exports.getEnv = getEnv;
function localStorageGetItem(item) {
    return typeof localStorage !== 'undefined'
        ? localStorage.getItem(item)
        : undefined;
}
exports.localStorageGetItem = localStorageGetItem;
function localStorageSetItem(str, item) {
    return typeof localStorage !== 'undefined'
        ? localStorage.setItem(str, item)
        : undefined;
}
exports.localStorageSetItem = localStorageSetItem;
function max(arr, init = -Infinity) {
    let max = init;
    for (const entry of arr) {
        max = entry > max ? entry : max;
    }
    return max;
}
exports.max = max;
function min(arr, init = Infinity) {
    let min = init;
    for (const entry of arr) {
        min = entry < min ? entry : min;
    }
    return min;
}
exports.min = min;
function sum(arr) {
    let sum = 0;
    for (const entry of arr) {
        sum += entry;
    }
    return sum;
}
exports.sum = sum;
function avg(arr) {
    return sum(arr) / arr.length;
}
exports.avg = avg;
function groupBy(array, predicate) {
    var _a;
    const result = {};
    for (const value of array) {
        const entry = (result[_a = predicate(value)] || (result[_a] = []));
        entry.push(value);
    }
    return result;
}
exports.groupBy = groupBy;
function notEmpty(value) {
    return value !== null && value !== undefined;
}
exports.notEmpty = notEmpty;
function mergeIntervals(intervals, w = 5000) {
    // test if there are at least 2 intervals
    if (intervals.length <= 1) {
        return intervals;
    }
    const stack = [];
    let top = null;
    // sort the intervals based on their start values
    intervals = intervals.sort((a, b) => a.start - b.start);
    // push the 1st interval into the stack
    stack.push(intervals[0]);
    // start from the next interval and merge if needed
    for (let i = 1; i < intervals.length; i++) {
        // get the top element
        top = stack.at(-1);
        // if the current interval doesn't overlap with the
        // stack top element, push it to the stack
        if (top.end + w < intervals[i].start - w) {
            stack.push(intervals[i]);
        }
        // otherwise update the end value of the top element
        // if end of current interval is higher
        else if (top.end < intervals[i].end) {
            top.end = Math.max(top.end, intervals[i].end);
            stack.pop();
            stack.push(top);
        }
    }
    return stack;
}
exports.mergeIntervals = mergeIntervals;
function gatherOverlaps(regions) {
    const memo = {};
    for (const x of regions) {
        if (!memo[x.refName]) {
            memo[x.refName] = [];
        }
        memo[x.refName].push(x);
    }
    return Object.values(memo).flatMap(group => mergeIntervals(group.sort((a, b) => a.start - b.start)));
}
exports.gatherOverlaps = gatherOverlaps;
function stripAlpha(str) {
    const c = (0, colord_1.colord)(str);
    return c.alpha(1).toHex();
}
exports.stripAlpha = stripAlpha;
function getStrokeProps(str) {
    const c = (0, colord_1.colord)(str);
    return { strokeOpacity: c.alpha(), stroke: c.alpha(1).toHex() };
}
exports.getStrokeProps = getStrokeProps;
function getFillProps(str) {
    const c = (0, colord_1.colord)(str);
    return { fillOpacity: c.alpha(), fill: c.alpha(1).toHex() };
}
exports.getFillProps = getFillProps;
// https://react.dev/reference/react-dom/server/renderToString#removing-rendertostring-from-the-client-code
function renderToStaticMarkup(node, createRootFn) {
    const div = document.createElement('div');
    (0, react_dom_1.flushSync)(() => {
        if (createRootFn) {
            createRootFn(div).render(node);
        }
        else {
            (0, react_dom_1.render)(node, div);
        }
    });
    return div.innerHTML.replaceAll(/\brgba\((.+?),[^,]+?\)/g, 'rgb($1)');
}
exports.renderToStaticMarkup = renderToStaticMarkup;
var simpleFeature_1 = require("./simpleFeature");
Object.defineProperty(exports, "SimpleFeature", { enumerable: true, get: function () { return __importDefault(simpleFeature_1).default; } });
Object.defineProperty(exports, "isFeature", { enumerable: true, get: function () { return simpleFeature_1.isFeature; } });
var blobToDataURL_1 = require("./blobToDataURL");
Object.defineProperty(exports, "blobToDataURL", { enumerable: true, get: function () { return blobToDataURL_1.blobToDataURL; } });
