"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blankStats = exports.scoresToStats = exports.calcPerBaseStats = exports.rectifyStats = exports.calcStdFromSums = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
/**
 * calculate standard deviation using the 'shortcut method' that accepts
 * the sum and the sum squares of the elements
 *
 * @param sum - sum(i, 1..n)
 * @param sumSquares - sum(i^2, 1..n)
 * @param n - number of elements
 * @param population - boolean: use population instead of sample correction
 * @returns - the estimated std deviation
 */
function calcStdFromSums(sum, sumSquares, n, population = false) {
    if (n === 0) {
        return 0;
    }
    let variance;
    if (population) {
        variance = sumSquares / n - (sum * sum) / (n * n);
    }
    else {
        // sample correction is n-1
        variance = sumSquares - (sum * sum) / n;
        if (n > 1) {
            variance /= n - 1;
        }
    }
    return variance < 0 ? 0 : Math.sqrt(variance);
}
exports.calcStdFromSums = calcStdFromSums;
/**
 * @param stats - a summary stats object with scoreSum, featureCount,
 * scoreSumSquares, and basesCovered
 * @returns - a summary stats object with
 * scoreMean, scoreStdDev, and featureDensity added
 */
function rectifyStats(s) {
    return {
        ...s,
        scoreMean: (s.scoreSum || 0) / (s.featureCount || s.basesCovered || 1),
        scoreStdDev: calcStdFromSums(s.scoreSum, s.scoreSumSquares, s.featureCount || s.basesCovered),
        featureDensity: (s.featureCount || 1) / s.basesCovered,
    };
}
exports.rectifyStats = rectifyStats;
/**
 * calculates per-base scores for variable width features over a region
 *
 * @param region - object contains start, end
 * @param features - list of features with start, end, score
 * @returns array of numeric scores
 */
function calcPerBaseStats(region, features) {
    const { start, end } = region;
    const scores = [];
    const feats = features.sort((a, b) => a.get('start') - b.get('start'));
    let pos = start;
    let currentFeat = 0;
    let i = 0;
    while (pos < end) {
        while (currentFeat < feats.length && pos >= feats[currentFeat].get('end')) {
            currentFeat += 1;
        }
        const f = feats[currentFeat];
        if (!f) {
            scores[i] = 0;
        }
        else if (pos >= f.get('start') && pos < f.get('end')) {
            scores[i] = f.get('score');
        }
        else {
            scores[i] = 0;
        }
        i += 1;
        pos += 1;
    }
    return scores;
}
exports.calcPerBaseStats = calcPerBaseStats;
/**
 * transform a list of scores to summary statistics
 *
 * @param region - object with start, end
 * @param features - array of features which are possibly summary features
 * @returns - object with scoreMax, scoreMin, scoreSum, scoreSumSquares, etc
 */
async function scoresToStats(region, feats) {
    const { start, end } = region;
    const seed = {
        scoreMin: Number.MAX_VALUE,
        scoreMax: Number.MIN_VALUE,
        scoreSum: 0,
        scoreSumSquares: 0,
        featureCount: 0,
    };
    let found = false;
    const { scoreMin, scoreMax, scoreSum, scoreSumSquares, featureCount } = await (0, rxjs_1.firstValueFrom)(feats.pipe((0, operators_1.reduce)((acc, f) => {
        const s = f.get('score');
        const summary = f.get('summary');
        const { scoreMax, scoreMin } = acc;
        acc.scoreMax = Math.max(scoreMax, summary ? f.get('maxScore') : s);
        acc.scoreMin = Math.min(scoreMin, summary ? f.get('minScore') : s);
        acc.scoreSum += s;
        acc.scoreSumSquares += s * s;
        acc.featureCount += 1;
        found = true;
        return acc;
    }, seed)));
    return found
        ? rectifyStats({
            scoreMax,
            scoreMin,
            scoreSum,
            scoreSumSquares,
            featureCount,
            basesCovered: end - start + 1,
        })
        : blankStats();
}
exports.scoresToStats = scoresToStats;
function blankStats() {
    return {
        scoreMin: 0,
        scoreMax: 0,
        scoreMean: 0,
        scoreStdDev: 0,
        scoreSum: 0,
        scoreSumSquares: 0,
        featureCount: 0,
        featureDensity: 0,
        basesCovered: 0,
    };
}
exports.blankStats = blankStats;
