import { Observable } from 'rxjs';
import { NoAssemblyRegion } from './types';
import { Feature } from './simpleFeature';
export interface UnrectifiedQuantitativeStats {
    scoreMin: number;
    scoreMax: number;
    scoreSum: number;
    scoreSumSquares: number;
    featureCount: number;
    basesCovered: number;
}
export interface QuantitativeStats extends UnrectifiedQuantitativeStats {
    featureDensity: number;
    scoreMean: number;
    scoreStdDev: number;
}
/**
 * calculate standard deviation using the 'shortcut method' that accepts
 * the sum and the sum squares of the elements
 *
 * @param sum - sum(i, 1..n)
 * @param sumSquares - sum(i^2, 1..n)
 * @param n - number of elements
 * @param population - boolean: use population instead of sample correction
 * @returns - the estimated std deviation
 */
export declare function calcStdFromSums(sum: number, sumSquares: number, n: number, population?: boolean): number;
/**
 * @param stats - a summary stats object with scoreSum, featureCount,
 * scoreSumSquares, and basesCovered
 * @returns - a summary stats object with
 * scoreMean, scoreStdDev, and featureDensity added
 */
export declare function rectifyStats(s: UnrectifiedQuantitativeStats): QuantitativeStats;
/**
 * calculates per-base scores for variable width features over a region
 *
 * @param region - object contains start, end
 * @param features - list of features with start, end, score
 * @returns array of numeric scores
 */
export declare function calcPerBaseStats(region: NoAssemblyRegion, features: Feature[]): number[];
/**
 * transform a list of scores to summary statistics
 *
 * @param region - object with start, end
 * @param features - array of features which are possibly summary features
 * @returns - object with scoreMax, scoreMin, scoreSum, scoreSumSquares, etc
 */
export declare function scoresToStats(region: NoAssemblyRegion, feats: Observable<Feature>): Promise<QuantitativeStats>;
export declare function blankStats(): QuantitativeStats;
