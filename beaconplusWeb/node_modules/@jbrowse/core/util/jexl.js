"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jexl_1 = __importDefault(require("jexl"));
function JexlF( /* config?: any*/) {
    const j = new jexl_1.default.Jexl();
    // someday will make sure all of configs callbacks are added in, including
    // ones passed in
    // below are core functions
    j.addFunction('get', (feature, data) => feature.get(data));
    j.addFunction('parent', (feature) => feature.parent());
    j.addFunction('id', (feature) => feature.id());
    // let user cast a jexl type into a javascript type
    j.addFunction('cast', (arg) => arg);
    // logging
    j.addFunction('log', (thing) => {
        console.log(thing); // eslint-disable-line no-console
        return thing;
    });
    // math
    // addfunction added in jexl 2.3 but types/jexl still on 2.2
    j.addFunction('max', Math.max);
    j.addFunction('min', Math.min);
    j.addFunction('sqrt', Math.sqrt);
    j.addFunction('ceil', Math.ceil);
    j.addFunction('floor', Math.floor);
    j.addFunction('round', Math.round);
    j.addFunction('abs', Math.abs);
    j.addFunction('log10', Math.log10);
    j.addFunction('parseInt', Number.parseInt);
    j.addFunction('parseFloat', Number.parseFloat);
    // string
    j.addFunction('split', (s, char) => s.split(char));
    j.addFunction('charAt', (s, index) => s.charAt(index));
    j.addFunction('charCodeAt', (s, index) => s.charCodeAt(index));
    j.addFunction('codePointAt', (s, pos) => s.codePointAt(pos));
    j.addFunction('startsWith', (s, search, len) => s.startsWith(search, len));
    j.addFunction('endsWith', (s, search, len) => s.endsWith(search, len));
    j.addFunction('padEnd', (s, len, pad) => s.padEnd(len, pad));
    j.addFunction('padStart', (s, len, fill) => s.padStart(len, fill));
    j.addFunction('repeat', (s, count) => s.repeat(count));
    j.addFunction('replace', (s, match, sub) => s.replace(match, sub));
    j.addFunction('replaceAll', (s, match, sub) => s.replaceAll(match, sub));
    j.addFunction('slice', (s, start, end) => s.slice(start, end));
    j.addFunction('startsWith', (s, search, pos) => s.startsWith(search, pos));
    j.addFunction('substring', (s, start, end) => 
    // eslint-disable-next-line unicorn/prefer-string-slice
    s.substring(start, end));
    j.addFunction('toLowerCase', (s) => s.toLowerCase());
    j.addFunction('toUpperCase', (s) => s.toUpperCase());
    j.addFunction('jsonParse', (s) => JSON.parse(s));
    j.addFunction('trim', (s) => s.trim());
    j.addFunction('trimEnd', (s) => s.trimEnd());
    j.addFunction('trimStart', (s) => s.trimStart());
    j.addFunction('getTag', (feature, s) => {
        const tags = feature.get('tags');
        return tags ? tags[s] : feature.get(s);
    });
    j.addBinaryOp('&', 15, (a, b) => a & b);
    return j;
}
exports.default = JexlF;
