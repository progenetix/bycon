import React from 'react';
import PluginManager from '../PluginManager';
import { IAnyStateTreeNode, IStateTreeNode, Instance } from 'mobx-state-tree';
import { IReactionPublic, IReactionOptions } from 'mobx';
import { Feature } from './simpleFeature';
import { AssemblyManager, Region, TypeTestedByPredicate } from './types';
import { Region as MUIRegion } from './types/mst';
import { BaseBlock } from './blockTypes';
export * from './types';
export * from './aborting';
export * from './when';
export * from './range';
export * from './dedupe';
export * from './offscreenCanvasPonyfill';
export * from './offscreenCanvasUtils';
export declare function useDebounce<T>(value: T, delay: number): T;
export declare function useWidthSetter(view: {
    setWidth: (arg: number) => void;
}, padding: string): React.RefObject<HTMLDivElement>;
export declare function useDebouncedCallback<T>(callback: (...args: T[]) => void, wait?: number): (...args: T[]) => void;
/**
 * find the first node in the hierarchy that matches the given predicate
 */
export declare function findParentThat(node: IAnyStateTreeNode, predicate: (thing: IAnyStateTreeNode) => boolean): IAnyStateTreeNode;
export declare function springAnimate(fromValue: number, toValue: number, setValue: (value: number) => void, onFinish?: () => void, precision?: number, tension?: number, friction?: number, clamp?: boolean): (() => void)[];
/**
 * find the first node in the hierarchy that matches the given 'is' typescript
 * type guard predicate
 */
export declare function findParentThatIs<T extends (a: IAnyStateTreeNode) => boolean>(node: IAnyStateTreeNode, predicate: T): TypeTestedByPredicate<T>;
/**
 * get the current JBrowse session model, starting at any node in the state
 * tree
 */
export declare function getSession(node: IAnyStateTreeNode): import("./types").AbstractSessionModel;
/**
 * get the state model of the view in the state tree that contains the given
 * node
 */
export declare function getContainingView(node: IAnyStateTreeNode): import("./types").AbstractViewModel;
/**
 * get the state model of the view in the state tree that contains the given
 * node
 */
export declare function getContainingTrack(node: IAnyStateTreeNode): import("./types").AbstractTrackModel;
/**
 * get the state model of the display in the state tree that contains the given
 * node
 */
export declare function getContainingDisplay(node: IAnyStateTreeNode): import("./types").AbstractDisplayModel;
/**
 * Assemble a 1-based "locString" from an interbase genomic location
 * @param region - Region
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0, end: 100 })
 * // ↳ 'chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ assemblyName: 'hg19', refName: 'chr1', start: 0, end: 100 })
 * // ↳ '{hg19}chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1' })
 * // ↳ 'chr1'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0 })
 * // ↳ 'chr1:1..'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', end: 100 })
 * // ↳ 'chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0, end: 1 })
 * // ↳ 'chr1:1'
 * ```
 */
export declare function assembleLocString(region: ParsedLocString): string;
export declare function assembleLocStringFast(region: ParsedLocString, cb?: (n: number) => string | number): string;
export interface ParsedLocString {
    assemblyName?: string;
    refName: string;
    start?: number;
    end?: number;
    reversed?: boolean;
}
export declare function parseLocStringOneBased(locString: string, isValidRefName: (refName: string, assemblyName?: string) => boolean): ParsedLocString;
/**
 * Parse a 1-based location string into an interbase genomic location
 * @param locString - Location string
 * @param isValidRefName - Function that checks if a refName exists in the set
 * of all known refNames, or in the set of refNames for an assembly if
 * assemblyName is given
 * @example
 * ```ts
 * parseLocString('chr1:1..100', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1-100', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString(`{hg19}chr1:1..100`, isValidRefName)
 * // ↳ { assemblyName: 'hg19', refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1', isValidRefName)
 * // ↳ { refName: 'chr1' }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 1 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1..', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0}
 * ```
 */
export declare function parseLocString(locString: string, isValidRefName: (refName: string, assemblyName?: string) => boolean): ParsedLocString;
export declare function compareLocs(locA: ParsedLocString, locB: ParsedLocString): number;
export declare function compareLocStrings(a: string, b: string, isValidRefName: (refName: string, assemblyName?: string) => boolean): number;
/**
 * Ensure that a number is at least min and at most max.
 *
 * @param num -
 * @param min -
 * @param  max -
 */
export declare function clamp(num: number, min: number, max: number): number;
/**
 * @param bp -
 * @param region -
 * @param bpPerPx -
 */
export declare function bpToPx(bp: number, { reversed, end, start, }: {
    start?: number;
    end?: number;
    reversed?: boolean;
}, bpPerPx: number): number;
export declare function radToDeg(radians: number): number;
export declare function degToRad(degrees: number): number;
/**
 * @returns [x, y]
 */
export declare function polarToCartesian(rho: number, theta: number): [number, number];
/**
 * @param x - the x
 * @param y - the y
 * @returns [rho, theta]
 */
export declare function cartesianToPolar(x: number, y: number): [number, number];
export declare function featureSpanPx(feature: Feature, region: {
    start: number;
    end: number;
    reversed?: boolean;
}, bpPerPx: number): [number, number];
export declare function bpSpanPx(leftBp: number, rightBp: number, region: {
    start: number;
    end: number;
    reversed?: boolean;
}, bpPerPx: number): [number, number];
export declare function iterMap<T, U>(iter: Iterable<T>, func: (arg: T) => U, sizeHint?: number): U[];
/**
 * Returns the index of the last element in the array where predicate is true,
 * and -1 otherwise.
 * Based on https://stackoverflow.com/a/53187807
 *
 * @param array - The source array to search in
 *
 * @param predicate - find calls predicate once for each element of the array, in
 * descending order, until it finds one where predicate returns true.
 *
 * @returns findLastIndex returns element index where predicate is true.
 * Otherwise, findLastIndex returns -1.
 */
export declare function findLastIndex<T>(array: T[], predicate: (value: T, index: number, obj: T[]) => boolean): number;
export declare function findLast<T>(array: T[], predicate: (value: T, index: number, obj: T[]) => boolean): T | undefined;
/**
 * makes a mobx reaction with the given functions, that calls actions on the
 * model for each stage of execution, and to abort the reaction function when
 * the model is destroyed.
 *
 * Will call startedFunction(signal), successFunction(result), and
 * errorFunction(error) when the async reaction function starts, completes, and
 * errors respectively.
 *
 * @param self -
 * @param dataFunction -
 * @param asyncReactionFunction -
 * @param reactionOptions -
 * @param startedFunction -
 * @param successFunction -
 * @param errorFunction -
 */
export declare function makeAbortableReaction<T, U, V>(self: T, dataFunction: (arg: T) => U, asyncReactionFunction: (arg: U | undefined, signal: AbortSignal, model: T, handle: IReactionPublic) => Promise<V>, reactionOptions: IReactionOptions, startedFunction: (aborter: AbortController) => void, successFunction: (arg: V) => void, errorFunction: (err: unknown) => void): void;
export declare function renameRegionIfNeeded(refNameMap: Record<string, string>, region: Region | Instance<typeof MUIRegion>): Region & {
    originalRefName?: string;
};
export declare function renameRegionsIfNeeded<ARGTYPE extends {
    assemblyName?: string;
    regions?: Region[];
    signal?: AbortSignal;
    adapterConfig: Record<string, unknown>;
    sessionId: string;
    statusCallback?: (arg: string) => void;
}>(assemblyManager: AssemblyManager, args: ARGTYPE): Promise<ARGTYPE & {
    regions: (Region & {
        originalRefName?: string | undefined;
    })[];
}>;
export declare function minmax(a: number, b: number): number[];
export declare function shorten(name: string, max?: number, short?: number): string;
export declare function stringify({ refName, coord, assemblyName, oob, }: {
    assemblyName?: string;
    coord: number;
    refName?: string;
    oob?: boolean;
}, useAssemblyName?: boolean): string;
export declare const isElectron: boolean;
export declare function revcom(seqString: string): string;
export declare function reverse(seqString: string): string;
export declare const complement: (seqString: string) => string;
export declare const rIC: (((callback: IdleRequestCallback, options?: IdleRequestOptions | undefined) => number) & typeof requestIdleCallback) | ((cb: Function) => any);
export declare function measureText(str: unknown, fontSize?: number): number;
export type Frame = 1 | 2 | 3 | -1 | -2 | -3;
export declare function getFrame(start: number, end: number, strand: 1 | -1, phase: 0 | 1 | 2): Frame;
export declare const defaultStarts: string[];
export declare const defaultStops: string[];
export declare const defaultCodonTable: {
    TCA: string;
    TCC: string;
    TCG: string;
    TCT: string;
    TTC: string;
    TTT: string;
    TTA: string;
    TTG: string;
    TAC: string;
    TAT: string;
    TAA: string;
    TAG: string;
    TGC: string;
    TGT: string;
    TGA: string;
    TGG: string;
    CTA: string;
    CTC: string;
    CTG: string;
    CTT: string;
    CCA: string;
    CCC: string;
    CCG: string;
    CCT: string;
    CAC: string;
    CAT: string;
    CAA: string;
    CAG: string;
    CGA: string;
    CGC: string;
    CGG: string;
    CGT: string;
    ATA: string;
    ATC: string;
    ATT: string;
    ATG: string;
    ACA: string;
    ACC: string;
    ACG: string;
    ACT: string;
    AAC: string;
    AAT: string;
    AAA: string;
    AAG: string;
    AGC: string;
    AGT: string;
    AGA: string;
    AGG: string;
    GTA: string;
    GTC: string;
    GTG: string;
    GTT: string;
    GCA: string;
    GCC: string;
    GCG: string;
    GCT: string;
    GAC: string;
    GAT: string;
    GAA: string;
    GAG: string;
    GGA: string;
    GGC: string;
    GGG: string;
    GGT: string;
};
/**
 * take CodonTable above and generate larger codon table that includes all
 * permutations of upper and lower case nucleotides
 */
export declare function generateCodonTable(table: any): Record<string, string>;
export declare function updateStatus<U>(msg: string, cb: (arg: string) => void, fn: () => U | Promise<U>): Promise<U>;
export declare function hashCode(str: string): number;
export declare function objectHash(obj: Record<string, any>): string;
interface VirtualOffset {
    blockPosition: number;
}
interface Block {
    minv: VirtualOffset;
    maxv: VirtualOffset;
}
export declare function bytesForRegions(regions: Region[], index: {
    blocksForRange: (ref: string, start: number, end: number) => Promise<Block[]>;
}): Promise<number>;
export interface ViewSnap {
    bpPerPx: number;
    interRegionPaddingWidth: number;
    minimumBlockWidth: number;
    width: number;
    offsetPx: number;
    staticBlocks: {
        contentBlocks: BaseBlock[];
        blocks: BaseBlock[];
    };
    displayedRegions: (IStateTreeNode & {
        start: number;
        end: number;
        refName: string;
        reversed: boolean;
        assemblyName: string;
    })[];
}
export declare function isSupportedIndexingAdapter(type: string): boolean;
export declare function getBpDisplayStr(totalBp: number): string;
export declare function toLocale(n: number): string;
export declare function getTickDisplayStr(totalBp: number, bpPerPx: number): string;
export declare function getViewParams(model: IAnyStateTreeNode, exportSVG?: boolean): {
    offsetPx: number;
    offsetPx1: number;
    start: number;
    end: number;
};
export declare function getLayoutId({ sessionId, layoutId, }: {
    sessionId: string;
    layoutId: string;
}): string;
export declare function useLocalStorage<T>(key: string, initialValue: T): readonly [T, (value: T | ((val: T) => T)) => void];
export declare function getUriLink(value: {
    uri: string;
    baseUri?: string;
}): string;
export declare function getStr(obj: unknown): string;
export declare function coarseStripHTML(s: string): string;
export declare function linkify(s: string): string;
export declare function measureGridWidth(elements: unknown[], args?: {
    minWidth?: number;
    fontSize?: number;
    maxWidth?: number;
    padding?: number;
    stripHTML?: boolean;
}): number;
export declare function getEnv(obj: any): {
    pluginManager: PluginManager;
};
export declare function localStorageGetItem(item: string): string | null | undefined;
export declare function localStorageSetItem(str: string, item: string): void;
export declare function max(arr: number[], init?: number): number;
export declare function min(arr: number[], init?: number): number;
export declare function sum(arr: number[]): number;
export declare function avg(arr: number[]): number;
export declare function groupBy<T>(array: Iterable<T>, predicate: (v: T) => string): Record<string, T[] | undefined>;
export declare function notEmpty<T>(value: T | null | undefined): value is T;
export declare function mergeIntervals<T extends {
    start: number;
    end: number;
}>(intervals: T[], w?: number): T[];
interface BasicFeature {
    end: number;
    start: number;
    refName: string;
}
export declare function gatherOverlaps(regions: BasicFeature[]): BasicFeature[];
export declare function stripAlpha(str: string): string;
export declare function getStrokeProps(str: string): {
    strokeOpacity: number;
    stroke: string;
};
export declare function getFillProps(str: string): {
    fillOpacity: number;
    fill: string;
};
export declare function renderToStaticMarkup(node: React.ReactElement, createRootFn?: (elt: Element | DocumentFragment) => {
    render: (node: React.ReactElement) => unknown;
}): string;
export { default as SimpleFeature, type Feature, type SimpleFeatureSerialized, isFeature, } from './simpleFeature';
export { blobToDataURL } from './blobToDataURL';
