import PluginManager from '../PluginManager';
import { AnyConfigurationModel } from '../configuration';
export interface WorkerHandle {
    status?: string;
    error?: Error;
    on?: (channel: string, callback: (message: unknown) => void) => void;
    off?: (channel: string, callback: (message: unknown) => void) => void;
    destroy(): void;
    call(functionName: string, args?: unknown, options?: {
        statusCallback?(message: string): void;
        timeout?: number;
        rpcDriverClassName: string;
    }): Promise<unknown>;
}
export interface RpcDriverConstructorArgs {
    config: AnyConfigurationModel;
}
export declare function watchWorker(worker: WorkerHandle, pingTime: number, rpcDriverClassName: string): Promise<void>;
declare class LazyWorker {
    driver: BaseRpcDriver;
    workerP?: Promise<WorkerHandle> | undefined;
    constructor(driver: BaseRpcDriver);
    getWorker(): Promise<WorkerHandle>;
}
export default abstract class BaseRpcDriver {
    abstract name: string;
    private lastWorkerAssignment;
    private workerAssignments;
    abstract makeWorker(): Promise<WorkerHandle>;
    private workerPool?;
    maxPingTime: number;
    workerCheckFrequency: number;
    config: AnyConfigurationModel;
    constructor(args: RpcDriverConstructorArgs);
    filterArgs<THING_TYPE>(thing: THING_TYPE, sessionId: string): THING_TYPE;
    remoteAbort(sessionId: string, functionName: string, signalId: number): Promise<void>;
    createWorkerPool(): LazyWorker[];
    getWorkerPool(): LazyWorker[];
    getWorker(sessionId: string): Promise<WorkerHandle>;
    call(pluginManager: PluginManager, sessionId: string, functionName: string, args: {
        statusCallback?: (message: unknown) => void;
    }, options?: {}): Promise<unknown>;
}
export {};
