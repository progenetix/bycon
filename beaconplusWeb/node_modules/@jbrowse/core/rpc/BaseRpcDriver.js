"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.watchWorker = void 0;
const mobx_state_tree_1 = require("mobx-state-tree");
const util_1 = require("../util");
const remoteAbortSignals_1 = require("./remoteAbortSignals");
const configuration_1 = require("../configuration");
function isClonable(thing) {
    return !(typeof thing === 'function') && !(thing instanceof Error);
}
// watches the given worker object, returns a promise that will be rejected if
// the worker times out
async function watchWorker(worker, pingTime, rpcDriverClassName) {
    // after first ping succeeds, apply wait for timeout
    // eslint-disable-next-line no-constant-condition
    while (true) {
        await worker.call('ping', [], {
            timeout: pingTime * 2,
            rpcDriverClassName,
        });
        await new Promise(resolve => setTimeout(resolve, pingTime));
    }
}
exports.watchWorker = watchWorker;
function detectHardwareConcurrency() {
    const mainThread = typeof window !== 'undefined';
    const canDetect = mainThread && 'hardwareConcurrency' in window.navigator;
    if (mainThread && canDetect) {
        return window.navigator.hardwareConcurrency;
    }
    return 1;
}
class LazyWorker {
    constructor(driver) {
        this.driver = driver;
    }
    async getWorker() {
        if (!this.workerP) {
            this.workerP = this.driver
                .makeWorker()
                .then(worker => {
                watchWorker(worker, this.driver.maxPingTime, this.driver.name).catch(error => {
                    if (worker) {
                        console.error('worker did not respond, killing and generating new one');
                        console.error(error);
                        worker.destroy();
                        worker.status = 'killed';
                        worker.error = error;
                        this.workerP = undefined;
                    }
                });
                return worker;
            })
                .catch(e => {
                this.workerP = undefined;
                throw e;
            });
        }
        return this.workerP;
    }
}
class BaseRpcDriver {
    constructor(args) {
        this.lastWorkerAssignment = -1;
        this.workerAssignments = new Map(); // sessionId -> worker number
        this.maxPingTime = 30000;
        this.workerCheckFrequency = 5000;
        this.config = args.config;
    }
    // filter the given object and just remove any non-clonable things from it
    filterArgs(thing, sessionId) {
        if (Array.isArray(thing)) {
            return thing
                .filter(thing => isClonable(thing))
                .map(t => this.filterArgs(t, sessionId));
        }
        if (typeof thing === 'object' && thing !== null) {
            // AbortSignals are specially handled
            if (thing instanceof AbortSignal) {
                return (0, remoteAbortSignals_1.serializeAbortSignal)(thing, this.remoteAbort.bind(this, sessionId));
            }
            if ((0, mobx_state_tree_1.isStateTreeNode)(thing) && !(0, mobx_state_tree_1.isAlive)(thing)) {
                throw new Error('dead state tree node passed to RPC call');
            }
            // special case, don't try to iterate the file's subelements as the
            // object entries below would
            if (thing instanceof File) {
                return thing;
            }
            return Object.fromEntries(Object.entries(thing)
                .filter(e => isClonable(e[1]))
                .map(([k, v]) => [k, this.filterArgs(v, sessionId)]));
        }
        return thing;
    }
    async remoteAbort(sessionId, functionName, signalId) {
        const worker = await this.getWorker(sessionId);
        await worker.call(functionName, { signalId }, { timeout: 1000000, rpcDriverClassName: this.name });
    }
    createWorkerPool() {
        const hardwareConcurrency = detectHardwareConcurrency();
        const workerCount = (0, configuration_1.readConfObject)(this.config, 'workerCount') ||
            (0, util_1.clamp)(1, Math.max(1, hardwareConcurrency - 1), 5);
        const workers = [];
        for (let i = 0; i < workerCount; i++) {
            workers.push(new LazyWorker(this));
        }
        return workers;
    }
    getWorkerPool() {
        if (!this.workerPool) {
            const res = this.createWorkerPool();
            this.workerPool = res;
            return res; // making this several steps makes TS happy
        }
        return this.workerPool;
    }
    async getWorker(sessionId) {
        const workers = this.getWorkerPool();
        let workerNumber = this.workerAssignments.get(sessionId);
        if (workerNumber === undefined) {
            const workerAssignment = (this.lastWorkerAssignment + 1) % workers.length;
            this.workerAssignments.set(sessionId, workerAssignment);
            this.lastWorkerAssignment = workerAssignment;
            workerNumber = workerAssignment;
        }
        return workers[workerNumber].getWorker();
    }
    async call(pluginManager, sessionId, functionName, args, options = {}) {
        if (!sessionId) {
            throw new TypeError('sessionId is required');
        }
        let done = false;
        const unextendedWorker = await this.getWorker(sessionId);
        const worker = pluginManager.evaluateExtensionPoint('Core-extendWorker', unextendedWorker);
        const rpcMethod = pluginManager.getRpcMethodType(functionName);
        const serializedArgs = await rpcMethod.serializeArguments(args, this.name);
        const filteredAndSerializedArgs = this.filterArgs(serializedArgs, sessionId);
        // now actually call the worker
        const callP = worker
            .call(functionName, filteredAndSerializedArgs, {
            timeout: 5 * 60 * 1000, // 5 minutes
            statusCallback: args.statusCallback,
            rpcDriverClassName: this.name,
            ...options,
        })
            .finally(() => {
            done = true;
        });
        // check every 5 seconds to see if the worker has been killed, and
        // reject the killedP promise if it has
        let killedCheckInterval;
        const killedP = new Promise((resolve, reject) => {
            killedCheckInterval = setInterval(() => {
                // must've been killed
                if (worker.status === 'killed') {
                    reject(new Error(`operation timed out, worker process stopped responding, ${worker.error}`));
                }
                else if (done) {
                    resolve(true);
                }
            }, this.workerCheckFrequency);
        }).finally(() => {
            clearInterval(killedCheckInterval);
        });
        // the result is a race between the actual result promise, and the "killed"
        // promise. the killed promise will only actually win if the worker was
        // killed before the call could return
        const resultP = Promise.race([callP, killedP]);
        return rpcMethod.deserializeReturn(resultP, args, this.name);
    }
}
exports.default = BaseRpcDriver;
