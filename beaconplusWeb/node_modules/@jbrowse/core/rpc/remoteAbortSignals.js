"use strict";
/* ---------------- for the RPC client ----------------- */
Object.defineProperty(exports, "__esModule", { value: true });
exports.remoteAbortRpcHandler = exports.remoteAbort = exports.deserializeAbortSignal = exports.isRemoteAbortSignal = exports.serializeAbortSignal = void 0;
let abortSignalCounter = 0;
const abortSignalIds = new WeakMap(); // map of abortsignal => numerical ID
/**
 * assign an ID to the given abort signal and return a plain object
 * representation
 *
 * @param signal - the signal to serialize
 * @param callfunc - function used to call
 *  a remote method, will be called like callfunc('signalAbort', signalId)
 */
function serializeAbortSignal(signal, callfunc) {
    let abortSignalId = abortSignalIds.get(signal);
    if (!abortSignalId) {
        abortSignalCounter += 1;
        abortSignalIds.set(signal, abortSignalCounter);
        abortSignalId = abortSignalCounter;
        signal.addEventListener('abort', () => {
            const signalId = abortSignalIds.get(signal);
            if (signalId !== undefined) {
                callfunc('signalAbort', signalId);
            }
        });
    }
    return { abortSignalId };
}
exports.serializeAbortSignal = serializeAbortSignal;
/* ---------------- for the RPC server ----------------- */
/**
 * test whether a given object
 * @param thing - the thing to test
 * @returns true if the thing is a remote abort signal
 */
function isRemoteAbortSignal(thing) {
    return (typeof thing === 'object' &&
        thing !== null &&
        'abortSignalId' in thing &&
        typeof thing.abortSignalId === 'number');
}
exports.isRemoteAbortSignal = isRemoteAbortSignal;
// the server side keeps a set of surrogate abort controllers that can be
// aborted based on ID
const surrogateAbortControllers = new Map(); // numerical ID => surrogate abort controller
/**
 * deserialize the result of serializeAbortSignal into an AbortSignal
 *
 * @param signal -
 * @returns an abort signal that corresponds to the given ID
 */
function deserializeAbortSignal({ abortSignalId, }) {
    let surrogateAbortController = surrogateAbortControllers.get(abortSignalId);
    if (!surrogateAbortController) {
        surrogateAbortController = new AbortController();
        surrogateAbortControllers.set(abortSignalId, surrogateAbortController);
    }
    return surrogateAbortController.signal;
}
exports.deserializeAbortSignal = deserializeAbortSignal;
/**
 * fire an abort signal from a remote abort signal ID
 *
 * @param abortSignalId -
 */
function remoteAbort(props) {
    const { signalId: abortSignalId } = props;
    const surrogateAbortController = surrogateAbortControllers.get(abortSignalId);
    if (surrogateAbortController) {
        surrogateAbortController.abort();
    }
}
exports.remoteAbort = remoteAbort;
function remoteAbortRpcHandler() {
    return {
        signalAbort: remoteAbort,
    };
}
exports.remoteAbortRpcHandler = remoteAbortRpcHandler;
