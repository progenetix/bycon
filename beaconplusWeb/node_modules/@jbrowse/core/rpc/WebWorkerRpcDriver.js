"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const serialize_error_1 = require("serialize-error");
const librpc_web_mod_1 = __importDefault(require("librpc-web-mod"));
// locals
const nanoid_1 = require("../util/nanoid");
const BaseRpcDriver_1 = __importDefault(require("./BaseRpcDriver"));
class WebWorkerHandle extends librpc_web_mod_1.default.Client {
    destroy() {
        this.workers[0].terminate();
    }
    async call(funcName, args, opts) {
        const { statusCallback, rpcDriverClassName } = opts;
        const channel = `message-${(0, nanoid_1.nanoid)()}`;
        const listener = (message) => {
            statusCallback === null || statusCallback === void 0 ? void 0 : statusCallback(message);
        };
        this.on(channel, listener);
        const result = await super.call(funcName, { ...args, channel, rpcDriverClassName }, opts);
        this.off(channel, listener);
        return result;
    }
}
class WebWorkerRpcDriver extends BaseRpcDriver_1.default {
    constructor(args, workerBootConfiguration) {
        super(args);
        this.workerBootConfiguration = workerBootConfiguration;
        this.name = 'WebWorkerRpcDriver';
        this.makeWorkerInstance = args.makeWorkerInstance;
    }
    async makeWorker() {
        // note that we are making a Rpc.Client connection with a worker pool of
        // one for each worker, because we want to do our own state-group-aware
        // load balancing rather than using librpc's builtin round-robin
        const instance = this.makeWorkerInstance();
        // @ts-ignore this is used to avoid warning in jbrowse-web startup
        // (because this file is referred to via src, declare.d.ts file is in
        // e.g. products/jbrowse-web)
        const worker = new WebWorkerHandle({ workers: [instance] });
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        if (isSafari) {
            // xref https://github.com/GMOD/jbrowse-components/issues/3245
            // eslint-disable-next-line no-console
            console.log('console logging the webworker handle avoids the track going into an infinite loading state, this is a hacky workaround for safari', instance);
        }
        // send the worker its boot configuration using info from the pluginManager
        return new Promise((resolve, reject) => {
            const listener = (e) => {
                switch (e.data.message) {
                    case 'ready': {
                        resolve(worker);
                        worker.workers[0].removeEventListener('message', listener);
                        break;
                    }
                    case 'readyForConfig': {
                        worker.workers[0].postMessage({
                            message: 'config',
                            config: this.workerBootConfiguration,
                        });
                        break;
                    }
                    case 'error': {
                        reject((0, serialize_error_1.deserializeError)(e.data.error));
                        break;
                    }
                    // No default
                }
            };
            worker.workers[0].addEventListener('message', listener);
        });
    }
}
exports.default = WebWorkerRpcDriver;
