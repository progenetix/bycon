/// <reference types="react" />
import { IAnyType, IAnyModelType } from 'mobx-state-tree';
import PluggableElementBase from './pluggableElementTypes/PluggableElementBase';
import RendererType from './pluggableElementTypes/renderers/RendererType';
import AdapterType from './pluggableElementTypes/AdapterType';
import TrackType from './pluggableElementTypes/TrackType';
import DisplayType from './pluggableElementTypes/DisplayType';
import ViewType from './pluggableElementTypes/ViewType';
import WidgetType from './pluggableElementTypes/WidgetType';
import ConnectionType from './pluggableElementTypes/ConnectionType';
import RpcMethodType from './pluggableElementTypes/RpcMethodType';
import InternetAccountType from './pluggableElementTypes/InternetAccountType';
import TextSearchAdapterType from './pluggableElementTypes/TextSearchAdapterType';
import AddTrackWorkflowType from './pluggableElementTypes/AddTrackWorkflowType';
import Plugin from './Plugin';
import ReExports from './ReExports';
import { PluggableElementType, PluggableElementMember } from './pluggableElementTypes';
import { AbstractRootModel } from './util';
import { PluginDefinition } from './PluginLoader';
declare class PhasedScheduler<PhaseName extends string> {
    phaseCallbacks: Map<PhaseName, Function[]>;
    phaseOrder: PhaseName[];
    constructor(...phaseOrder: PhaseName[]);
    add(phase: PhaseName, callback: Function): void;
    run(): void;
}
type PluggableElementTypeGroup = 'renderer' | 'adapter' | 'display' | 'track' | 'connection' | 'view' | 'widget' | 'rpc method' | 'internet account' | 'text search adapter' | 'add track workflow';
/** internal class that holds the info for a certain element type */
declare class TypeRecord<ElementClass extends PluggableElementBase> {
    typeName: string;
    baseClass: (new (...args: unknown[]) => ElementClass) | (Function & {
        prototype: ElementClass;
    });
    registeredTypes: Record<string, ElementClass>;
    constructor(typeName: string, baseClass: (new (...args: unknown[]) => ElementClass) | (Function & {
        prototype: ElementClass;
    }));
    add(name: string, t: ElementClass): void;
    has(name: string): boolean;
    get(name: string): ElementClass;
    all(): ElementClass[];
}
type AnyFunction = (...args: any) => any;
/**
 * free-form string-to-unknown mapping of metadata related to the instance of
 * this plugin. `isCore` is typically set to `Boolean(true)` if the plugin was
 * loaded as part of the "core" set of plugins for this application. Can also
 * use this metadata to stash other things about why the plugin is loaded, such
 * as where it came from, what plugin depends on it, etc.
 */
export type PluginMetadata = Record<string, unknown>;
export interface PluginLoadRecord {
    metadata?: PluginMetadata;
    plugin: Plugin;
}
export interface RuntimePluginLoadRecord extends PluginLoadRecord {
    definition: PluginDefinition;
}
export default class PluginManager {
    plugins: Plugin[];
    jexl: {
        addBinaryOp: (operator: string, precedence: number, fn: (left: any, right: any) => any) => void;
        addUnaryOp: (operator: string, fn: (right: any) => any) => void;
        addTransform: (name: string, fn: (value: any, ...args: any[]) => any) => void;
        addTransforms: (map: {
            [key: string]: (value: any, ...args: any[]) => any;
        }) => void;
        getTransform: (name: string) => (value: any, ...args: any[]) => any;
        addFunction: (name: string, fn: (value: any, ...args: any[]) => any) => void;
        addFunctions: (map: {
            [key: string]: (value: any, ...args: any[]) => any;
        }) => void;
        getFunction: (name: string) => (value: any, ...args: any[]) => any;
        eval: (expression: string, context?: import("jexl/Expression").Context | undefined) => Promise<any>;
        evalSync: (expression: string, context?: import("jexl/Expression").Context | undefined) => any;
        compile: (expression: string) => import("jexl/Expression").default;
        createExpression: (expression: string) => import("jexl/Expression").default;
        removeOp: (operator: string) => void;
        _grammar: import("jexl/Grammar").default;
    };
    pluginMetadata: Record<string, PluginMetadata>;
    runtimePluginDefinitions: PluginDefinition[];
    elementCreationSchedule: PhasedScheduler<PluggableElementTypeGroup> | undefined;
    rendererTypes: TypeRecord<RendererType>;
    adapterTypes: TypeRecord<AdapterType>;
    textSearchAdapterTypes: TypeRecord<TextSearchAdapterType>;
    trackTypes: TypeRecord<TrackType>;
    displayTypes: TypeRecord<DisplayType>;
    connectionTypes: TypeRecord<ConnectionType>;
    viewTypes: TypeRecord<ViewType>;
    widgetTypes: TypeRecord<WidgetType>;
    rpcMethods: TypeRecord<RpcMethodType>;
    addTrackWidgets: TypeRecord<AddTrackWorkflowType>;
    internetAccountTypes: TypeRecord<InternetAccountType>;
    configured: boolean;
    rootModel?: AbstractRootModel;
    extensionPoints: Map<string, Function[]>;
    constructor(initialPlugins?: (Plugin | PluginLoadRecord)[]);
    pluginConfigurationSchemas(): Record<string, unknown>;
    addPlugin(load: Plugin | PluginLoadRecord | RuntimePluginLoadRecord): this;
    getPlugin(name: string): Plugin | undefined;
    hasPlugin(name: string): boolean;
    createPluggableElements(): this;
    setRootModel(rootModel: AbstractRootModel): void;
    configure(): this;
    getElementTypeRecord(groupName: PluggableElementTypeGroup): TypeRecord<PluggableElementBase>;
    addElementType(groupName: PluggableElementTypeGroup, creationCallback: (pluginManager: PluginManager) => PluggableElementType): this;
    getElementType(groupName: PluggableElementTypeGroup, typeName: string): PluggableElementBase;
    getElementTypesInGroup(groupName: PluggableElementTypeGroup): PluggableElementBase[];
    getTrackElements(): TrackType[];
    getConnectionElements(): ConnectionType[];
    getAddTrackWorkflowElements(): AddTrackWorkflowType[];
    getRpcElements(): RpcMethodType[];
    getDisplayElements(): DisplayType[];
    getAdapterElements(): AdapterType[];
    /** get a MST type for the union of all specified pluggable MST types */
    pluggableMstType(groupName: PluggableElementTypeGroup, fieldName: PluggableElementMember, fallback?: IAnyType): IAnyType;
    /** get a MST type for the union of all specified pluggable config schemas */
    pluggableConfigSchemaType(typeGroup: PluggableElementTypeGroup, fieldName?: PluggableElementMember): IAnyModelType;
    jbrequireCache: Map<any, any>;
    lib: {
        '@material-ui/lab/ToggleButton': import("react").LazyExoticComponent<import("@mui/material").ExtendButtonBase<import("@mui/material").ToggleButtonTypeMap<{}, "button">>>;
        '@material-ui/lab/ToggleButtonGroup': import("react").LazyExoticComponent<typeof import("@mui/material").ToggleButtonGroup>;
        '@material-ui/lab/Autocomplete': import("react").LazyExoticComponent<typeof import("@mui/material").Autocomplete>;
        '@material-ui/lab/Alert': import("react").LazyExoticComponent<typeof import("@mui/material").Alert>;
        '@material-ui/lab': {
            Alert: import("react").LazyExoticComponent<typeof import("@mui/material").Alert>;
            Autocomplete: import("react").LazyExoticComponent<typeof import("@mui/material").Autocomplete>;
            ToggleButton: import("react").LazyExoticComponent<import("@mui/material").ExtendButtonBase<import("@mui/material").ToggleButtonTypeMap<{}, "button">>>;
            ToggleButtonGroup: import("react").LazyExoticComponent<typeof import("@mui/material").ToggleButtonGroup>;
        };
        '@jbrowse/core/Plugin': typeof Plugin;
        '@jbrowse/core/pluggableElementTypes': typeof import("./pluggableElementTypes");
        '@jbrowse/core/pluggableElementTypes/ViewType': typeof ViewType;
        '@jbrowse/core/pluggableElementTypes/AdapterType': typeof AdapterType;
        '@jbrowse/core/pluggableElementTypes/DisplayType': typeof DisplayType;
        '@jbrowse/core/pluggableElementTypes/TrackType': typeof TrackType;
        '@jbrowse/core/pluggableElementTypes/WidgetType': typeof WidgetType;
        '@jbrowse/core/pluggableElementTypes/models': typeof import("./pluggableElementTypes/models");
        '@jbrowse/core/pluggableElementTypes/renderers/ServerSideRendererType': typeof import("./pluggableElementTypes/renderers/ServerSideRendererType");
        '@jbrowse/core/pluggableElementTypes/renderers/CircularChordRendererType': typeof import("./pluggableElementTypes").CircularChordRendererType;
        '@jbrowse/core/pluggableElementTypes/renderers/BoxRendererType': typeof import("./pluggableElementTypes/renderers/BoxRendererType");
        '@jbrowse/core/pluggableElementTypes/renderers/FeatureRendererType': typeof import("./pluggableElementTypes/renderers/FeatureRendererType");
        '@jbrowse/core/pluggableElementTypes/renderers/RendererType': typeof import("./pluggableElementTypes/renderers/RendererType");
        '@jbrowse/core/configuration': typeof import("./configuration");
        '@jbrowse/core/util/types/mst': typeof import("./util/types/mst");
        '@jbrowse/core/ui': typeof import("./ui");
        '@jbrowse/core/util': typeof import("./util");
        '@jbrowse/core/util/color': typeof import("./util/color");
        '@jbrowse/core/util/layouts': typeof import("./util/layouts");
        '@jbrowse/core/util/tracks': typeof import("./util/tracks");
        '@jbrowse/core/util/Base1DViewModel': import("mobx-state-tree").IModelType<{
            id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
            displayedRegions: import("mobx-state-tree").IArrayType<import("mobx-state-tree").IModelType<{
                refName: import("mobx-state-tree").ISimpleType<string>;
                start: import("mobx-state-tree").ISimpleType<number>;
                end: import("mobx-state-tree").ISimpleType<number>;
                reversed: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
            } & {
                assemblyName: import("mobx-state-tree").ISimpleType<string>;
            }, {
                setRefName(newRefName: string): void;
            }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
            bpPerPx: import("mobx-state-tree").IType<number | undefined, number, number>;
            offsetPx: import("mobx-state-tree").IType<number | undefined, number, number>;
            interRegionPaddingWidth: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<number>, [undefined]>;
            minimumBlockWidth: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<number>, [undefined]>;
        }, {
            features: import("./util").Feature[] | undefined;
            volatileWidth: number;
        } & {
            setDisplayedRegions(regions: import("./util").Region[]): void;
            setBpPerPx(val: number): void;
            setVolatileWidth(width: number): void;
        } & {
            readonly width: number;
            readonly assemblyNames: string[];
            readonly displayedRegionsTotalPx: number;
            readonly maxOffset: number;
            readonly minOffset: number;
            readonly totalBp: number;
        } & {
            readonly dynamicBlocks: import("./util/blockTypes").BlockSet;
            readonly staticBlocks: import("./util/blockTypes").BlockSet;
            readonly currBp: number;
        } & {
            pxToBp(px: number): {
                coord: number;
                index: number;
                refName: string;
                oob: boolean;
                assemblyName: string;
                offset: number;
                start: number;
                end: number;
                reversed: boolean;
            };
            bpToPx({ refName, coord, regionNumber, }: {
                refName: string;
                coord: number;
                regionNumber?: number | undefined;
            }): number | undefined;
        } & {
            setFeatures(features: import("./util").Feature[]): void;
            showAllRegions(): void;
            zoomOut(): void;
            zoomIn(): void;
            zoomTo(bpPerPx: number, offset?: number): number;
            scrollTo(offsetPx: number): number;
            centerAt(coord: number, refName: string | undefined, regionNumber: number): void;
            scroll(distance: number): number;
        } & {
            moveTo(start?: import("./util/Base1DUtils").BpOffset | undefined, end?: import("./util/Base1DUtils").BpOffset | undefined): void;
        }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
        '@jbrowse/core/util/io': typeof import("./util/io");
        '@jbrowse/core/util/mst-reflection': typeof import("./util/mst-reflection");
        '@jbrowse/core/util/rxjs': typeof import("./util/rxjs");
        '@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail': {
            Attributes: import("react").ForwardRefExoticComponent<Omit<any, "ref"> & import("react").RefAttributes<unknown>>;
            FeatureDetails: import("react").ForwardRefExoticComponent<Omit<any, "ref"> & import("react").RefAttributes<unknown>>;
            BaseCard: import("react").ForwardRefExoticComponent<Omit<any, "ref"> & import("react").RefAttributes<unknown>>;
        };
        '@jbrowse/core/data_adapters/BaseAdapter': typeof import("./data_adapters/BaseAdapter");
        mobx: typeof import("mobx");
        'mobx-state-tree': typeof import("mobx-state-tree");
        react: typeof import("react");
        'react/jsx-runtime': typeof import("react/jsx-runtime");
        'react-dom': typeof import("react-dom");
        'mobx-react': typeof import("mobx-react");
        '@mui/x-data-grid': {
            useGridApiContext: typeof import("@mui/x-data-grid").useGridApiContext;
            useGridApiRef: <Api extends import("@mui/x-data-grid").GridApiCommon<any, any> = import("@mui/x-data-grid/internals").GridApiCommunity>() => import("react").MutableRefObject<Api>;
            useGridRootProps: () => import("@mui/x-data-grid/internals").DataGridProcessedProps<any>;
        };
        '@mui/material/utils': typeof import("@mui/material/utils");
        '@material-ui/core/utils': typeof import("@mui/material/utils");
        'tss-react/mui': {
            makeStyles: <Params = void, RuleNameSubsetReferencableInNestedSelectors extends string = never>(params?: {
                name?: string | Record<string, unknown> | undefined;
                uniqId?: string | undefined;
            } | undefined) => <RuleName extends string>(cssObjectByRuleNameOrGetCssObjectByRuleName: Record<RuleName, import("tss-react").CSSObject> | ((theme: import("@mui/material").Theme, params: Params, classes: Record<RuleNameSubsetReferencableInNestedSelectors, string>) => Record<RuleNameSubsetReferencableInNestedSelectors | RuleName, import("tss-react").CSSObject>)) => (params: Params, muiStyleOverridesParams?: {
                props: Record<string, unknown>;
                ownerState?: Record<string, unknown> | undefined;
            } | undefined) => {
                classes: Record<RuleName, string>;
                theme: import("@mui/material").Theme;
                css: import("tss-react").Css;
                cx: import("tss-react").Cx;
            };
        };
        '@material-ui/core': {
            useTheme: typeof import("@mui/material").useTheme;
            alpha: typeof import("@mui/system").alpha;
            makeStyles: (args: any) => () => Record<string, string>;
        };
        '@mui/material': {
            alpha: typeof import("@mui/system").alpha;
            useTheme: typeof import("@mui/material").useTheme;
        };
        'prop-types': typeof import("prop-types");
        '@mui/material/styles': {
            MUIStyles: typeof import("@mui/material/styles");
            makeStyles: (args: any) => () => Record<string, string>;
        };
        '@material-ui/core/styles': {
            MUIStyles: typeof import("@mui/material/styles");
            makeStyles: (args: any) => () => Record<string, string>;
        };
    };
    load: <FTYPE extends AnyFunction>(lib: FTYPE) => ReturnType<FTYPE>;
    /**
     * Get the re-exported version of the given package name.
     * Throws an error if the package is not re-exported by the plugin manager.
     *
     * @returns the library's default export
     */
    jbrequire: (lib: keyof typeof ReExports | AnyFunction | {
        default: AnyFunction;
    }) => any;
    getRendererType(typeName: string): RendererType;
    getRendererTypes(): RendererType[];
    getAdapterType(typeName: string): AdapterType;
    getTextSearchAdapterType(typeName: string): TextSearchAdapterType;
    getTrackType(typeName: string): TrackType;
    getDisplayType(typeName: string): DisplayType;
    getViewType(typeName: string): ViewType;
    getAddTrackWorkflow(typeName: string): AddTrackWorkflowType;
    getWidgetType(typeName: string): WidgetType;
    getConnectionType(typeName: string): ConnectionType;
    getRpcMethodType(methodName: string): RpcMethodType;
    getInternetAccountType(name: string): InternetAccountType;
    addRendererType(cb: (pm: PluginManager) => RendererType): this;
    addAdapterType(cb: (pm: PluginManager) => AdapterType): this;
    addTextSearchAdapterType(cb: (pm: PluginManager) => TextSearchAdapterType): this;
    addTrackType(cb: (pm: PluginManager) => TrackType): this;
    addDisplayType(cb: (pluginManager: PluginManager) => DisplayType): this;
    addViewType(cb: (pluginManager: PluginManager) => ViewType): this;
    addWidgetType(cb: (pm: PluginManager) => WidgetType): this;
    addConnectionType(cb: (pm: PluginManager) => ConnectionType): this;
    addRpcMethod(cb: (pm: PluginManager) => RpcMethodType): this;
    addInternetAccountType(cb: (pm: PluginManager) => InternetAccountType): this;
    addAddTrackWorkflowType(cb: (pm: PluginManager) => AddTrackWorkflowType): this;
    addToExtensionPoint<T>(extensionPointName: string, callback: (extendee: T, props: Record<string, unknown>) => T): void;
    evaluateExtensionPoint(extensionPointName: string, extendee: unknown, props?: Record<string, unknown>): unknown;
    evaluateAsyncExtensionPoint(extensionPointName: string, extendee: unknown, props?: Record<string, unknown>): Promise<unknown>;
}
export {};
