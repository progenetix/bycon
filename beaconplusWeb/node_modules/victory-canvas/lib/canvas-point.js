"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CanvasPoint = void 0;

var _react = _interopRequireDefault(require("react"));

var _victoryCore = require("victory-core");

var _useCanvasContext2 = require("./hooks/use-canvas-context");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getPath = function (props) {
  var x = props.x,
      y = props.y,
      size = props.size,
      symbol = props.symbol;

  if (props.getPath) {
    return props.getPath(x, y, size);
  }

  var pathFunctions = {
    circle: _victoryCore.PointPathHelpers.circle,
    square: _victoryCore.PointPathHelpers.square,
    diamond: _victoryCore.PointPathHelpers.diamond,
    triangleDown: _victoryCore.PointPathHelpers.triangleDown,
    triangleUp: _victoryCore.PointPathHelpers.triangleUp,
    plus: _victoryCore.PointPathHelpers.plus,
    minus: _victoryCore.PointPathHelpers.minus,
    star: _victoryCore.PointPathHelpers.star,
    cross: _victoryCore.PointPathHelpers.cross
  };
  var symbolFunction = typeof pathFunctions[symbol] === "function" ? pathFunctions[symbol] : pathFunctions.circle;
  return symbolFunction(x, y, size);
};

var evaluateProps = function (props) {
  /**
   * Potential evaluated props are:
   * `size`
   * `style`
   * `symbol`
   */
  var size = _victoryCore.Helpers.evaluateProp(props.size, props);

  var style = _victoryCore.Helpers.evaluateStyle(props.style, props);

  var symbol = _victoryCore.Helpers.evaluateProp(props.symbol, props);

  return Object.assign({}, props, {
    size: size,
    style: style,
    symbol: symbol
  });
};

var CanvasPoint = function (props) {
  var _useCanvasContext = (0, _useCanvasContext2.useCanvasContext)(),
      canvasRef = _useCanvasContext.canvasRef;

  var modifiedProps = evaluateProps(props);

  var draw = _react.default.useCallback(function (ctx) {
    var style = modifiedProps.style;
    var path = getPath(modifiedProps);
    ctx.fillStyle = style.fill; // eslint-disable-next-line no-undef

    var path2d = new Path2D(path);
    ctx.fill(path2d);
  }, [modifiedProps]);

  _react.default.useEffect(function () {
    var _canvasRef$current;

    var ctx = (_canvasRef$current = canvasRef.current) === null || _canvasRef$current === void 0 ? void 0 : _canvasRef$current.getContext("2d");
    if (!ctx) return;
    draw(ctx); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return null;
};

exports.CanvasPoint = CanvasPoint;