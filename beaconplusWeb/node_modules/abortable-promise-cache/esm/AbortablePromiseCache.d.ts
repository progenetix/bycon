import AggregateAbortController from './AggregateAbortController';
import AggregateStatusReporter from './AggregateStatusReporter';
declare type Cache<U> = {
    delete: (key: string) => void;
    keys: () => Iterator<string>;
    get: (key: string) => U | undefined;
    set: (key: string, val: U) => void;
    has: (key: string) => boolean;
};
declare type FillCallback<T, U> = (data: T, signal?: AbortSignal, statusCallback?: Function) => Promise<U>;
declare type Entry<U> = {
    aborter: AggregateAbortController;
    settled: boolean;
    readonly aborted: boolean;
    statusReporter: AggregateStatusReporter;
    promise: Promise<U>;
};
export default class AbortablePromiseCache<T, U> {
    /**
     * @param {object} args constructor args
     * @param {Function} args.fill fill callback, will be called with sig `fill(data, signal)`
     * @param {object} args.cache backing store to use, must implement `get(key)`, `set(key, val)`,
     *   `delete(key)`, and `keys() -> iterator`
     */
    private cache;
    private fillCallback;
    constructor({ fill, cache, }: {
        fill: FillCallback<T, U>;
        cache: Cache<Entry<U>>;
    });
    static isAbortException(exception: Error): boolean;
    evict(key: string, entry: Entry<U>): void;
    fill(key: string, data: T, signal?: AbortSignal, statusCallback?: Function): void;
    static checkSinglePromise<U>(promise: Promise<U>, signal?: AbortSignal): Promise<U>;
    has(key: string): boolean;
    /**
     * Callback for getting status of the pending async
     *
     * @callback statusCallback
     * @param {any} status, current status string or message object
     */
    /**
     * @param {any} key cache key to use for this request
     * @param {any} data data passed as the first argument to the fill callback
     * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request
     * @param {statusCallback} a callback to get the current status of a pending async operation
     */
    get(key: string, data: T, signal?: AbortSignal, statusCallback?: Function): Promise<U>;
    /**
     * delete the given entry from the cache. if it exists and its fill request has
     * not yet settled, the fill will be signaled to abort.
     *
     * @param {any} key
     */
    delete(key: string): void;
    /**
     * Clear all requests from the cache. Aborts any that have not settled.
     * @returns {number} count of entries deleted
     */
    clear(): number;
}
export {};
