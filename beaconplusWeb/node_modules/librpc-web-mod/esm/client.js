import EventEmitter from './ee';
import { peekTransferables, uuid } from './utils';
import { deserializeError } from 'serialize-error';
export default class RpcClient extends EventEmitter {
    /**
     * Client could be connected to several workers for better CPU utilization.
     * Requests are sent to an exact worker by round robin algorithm.
     * @param options - Rpc Client options
     */
    constructor({ workers }) {
        super();
        this.idx = 0;
        this.calls = {};
        this.timeouts = {};
        this.errors = {};
        this.workers = [...workers];
        this.handler = this.handler.bind(this);
        this.catch = this.catch.bind(this);
        this.init();
    }
    /**
     * Subscribtion to web workers events
     */
    init() {
        this.workers.forEach(this.listen, this);
    }
    /**
     * Subsrciption to exact worker
     * @param worker - Server worker
     */
    listen(worker) {
        worker.addEventListener('message', this.handler);
        worker.addEventListener('error', this.catch);
    }
    /**
     * Message handler
     * @param e - Event object
     */
    handler(e) {
        var { uid, error, method, eventName, data, libRpc } = e.data;
        if (!libRpc)
            return; // ignore non-librpc messages
        if (error) {
            this.reject(uid, error);
        }
        else if (method) {
            this.resolve(uid, data);
        }
        else if (eventName) {
            this.emit(eventName, data);
        }
    }
    /**
     * Error handler
     * https://www.nczonline.net/blog/2009/08/25/web-workers-errors-and-debugging/
     * @param options - Error handler options
     */
    catch({ message, lineno, filename, libRpc }) {
        if (libRpc) {
            this.emit('error', {
                message,
                lineno,
                filename,
            });
        }
    }
    /**
     * Handle remote procedure call error
     * @param uid - Remote call uid
     * @param error - Error message
     */
    reject(uid, error) {
        if (this.errors[uid]) {
            this.errors[uid](deserializeError(error));
            this.clear(uid);
        }
    }
    /**
     * Handle remote procedure call response
     * @param uid - Remote call uid
     * @param data - Response data
     */
    resolve(uid, data) {
        if (this.calls[uid]) {
            this.calls[uid](data);
            this.clear(uid);
        }
    }
    /**
     * Clear inner references to remote call
     * @param uid - Remote call uid
     */
    clear(uid) {
        clearTimeout(this.timeouts[uid]);
        delete this.timeouts[uid];
        delete this.calls[uid];
        delete this.errors[uid];
    }
    /**
     * Remote procedure call. Only ArrayBuffers will be transferred automatically (not TypedArrays).
     * Error would be thrown, if:
     * - it happened during procedure
     * - you try to call an unexisted procedure
     * - procedure execution takes more than timeout
     * @param method - Remote procedure name
     * @param data - Request data
     * @param options - Options
     * @returns Remote procedure promise
     */
    call(method, data, { timeout = 2000 } = {}) {
        var uid = uuid();
        var transferables = peekTransferables(data);
        return new Promise((resolve, reject) => {
            this.timeouts[uid] = setTimeout(() => this.reject(uid, new Error(`Timeout exceeded for RPC method "${method}"`)), timeout);
            this.calls[uid] = resolve;
            this.errors[uid] = reject;
            this.workers[this.idx].postMessage({ method, uid, data, libRpc: true }, transferables);
            this.idx = ++this.idx % this.workers.length; // round robin
        });
    }
}
