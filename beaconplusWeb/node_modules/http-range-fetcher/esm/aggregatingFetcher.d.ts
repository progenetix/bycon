/**
 * takes fetch requests and aggregates them at a certain time frequency
 */
export default class AggregatingFetcher {
    /**
     *
     * @param {object} params
     * @param {number} [params.frequency] number of milliseconds to wait for requests to aggregate
     */
    constructor({ frequency, fetch, maxExtraSize, maxFetchSize, }: {
        frequency: number;
        maxExtraSize: number;
        maxFetchSize: number;
    });
    _canAggregate(requestGroup: any, request: any): boolean;
    _allSignalsFired(signals: any): Promise<unknown>;
    _dispatch({ url, start, end, requests }: {
        url: any;
        start: any;
        end: any;
        requests: any;
    }): void;
    _aggregateAndDispatch(): void;
    _enQueue(url: any, request: any): void;
    /**
     *
     * @param {string} url
     * @param {number} start 0-based half-open
     * @param {number} end 0-based half-open
     * @param {object} [requestOptions] options passed to the underlying fetch call
     */
    fetch(url: any, start: any, end: any, requestOptions?: {}): Promise<unknown>;
}
