import crossFetchBinaryRange from './crossFetchBinaryRange';
/**
 * smart cache that fetches chunks of remote files.
 * caches chunks in an LRU cache, and aggregates upstream fetches
 */
export default class HttpRangeFetcher {
    /**
     * @param {object} args the arguments object
     * @param {number} [args.fetch] callback with signature `(key, start, end) => Promise({ headers, buffer })`
     * @param {number} [args.size] size in bytes of cache to keep
     * @param {number} [args.chunkSize] size in bytes of cached chunks
     * @param {number} [args.aggregationTime] time in ms over which to pool requests before dispatching them
     * @param {number} [args.minimumTTL] time in ms a non-cacheable response will be cached
     * @param {number} [args.maxFetchSize] maximum size of an aggregated request
     * @param {number} [args.maxExtraFetch] max number of additional bytes to fetch when aggregating requests
     * that don't actually overlap
     */
    constructor({ fetch, size, chunkSize, aggregationTime, minimumTTL, maxFetchSize, maxExtraFetch, }: {
        fetch?: typeof crossFetchBinaryRange | undefined;
        size?: number | undefined;
        chunkSize?: number | undefined;
        aggregationTime?: number | undefined;
        minimumTTL?: number | undefined;
        maxFetchSize?: number | undefined;
        maxExtraFetch?: any;
    });
    /**
     * Fetch a range of a remote resource.
     * @param {string} key the resource's unique identifier, this would usually be a URL.
     * This is passed along to the fetch callback.
     * @param {number} [position] offset in the file at which to start fetching
     * @param {number} [length] number of bytes to fetch, defaults to the remainder of the file
     * @param {object} [options] request options
     * @param {AbortSignal} [options.signal] AbortSignal object that can be used to abort the fetch
     */
    getRange(key: any, position: number | undefined, requestedLength: any, options?: {}): Promise<{
        headers: any;
        buffer: any;
    }>;
    _makeBuffer(chunkResponses: any, chunksOffset: any, length: any): any;
    /**
     * Fetches the first few bytes of the remote file (if necessary) and uses
     * the returned headers to populate a `fs`-like stat object.
     *
     * Currently, this attempts to set `size`, `mtime`, and `mtimeMs`, if
     * the information is available from HTTP headers.
     *
     * @param {string} key
     * @returns {Promise} for a stats object
     */
    stat(key: any): Promise<any>;
    _headersToStats(chunkResponse: any): {};
    _makeHeaders(originalHeaders: any, newStart: any, newEnd: any): any;
    _getChunk(key: any, chunkNumber: any, requestOptions: any): any;
    _recordStatsIfNecessary(key: any, chunk: any): void;
    _uncacheIfSame(key: any, cachedPromise: any): void;
    /**
     * Throw away all cached data, resetting the cache.
     */
    reset(): void;
}
