import * as React from "react";
import type { ReactNode } from "react";
import type NextDocument from "next/document";
import type { DocumentContext } from "next/document";
import type { EmotionCache } from "@emotion/cache";
import type { Options as CreateCacheOption } from "@emotion/cache";
/**
 * @deprecated Use tss-react/next instead.
 * @see <https://docs.tss-react.dev/ssr/next> */
export declare function createEmotionSsrAdvancedApproach(options: CreateCacheOption): {
    EmotionCacheProvider: (props: {
        children: ReactNode;
    }) => JSX.Element;
    withEmotionCache: (Document: typeof NextDocument, params?: {
        getExtraCaches: () => EmotionCache[];
    } | undefined) => {
        new (props: (import("next/dist/shared/lib/utils").RenderPageResult & {
            styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
        } & import("next/dist/shared/lib/html-context").HtmlProps) | Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
            styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
        } & import("next/dist/shared/lib/html-context").HtmlProps>): {
            render(): JSX.Element;
            context: unknown;
            setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
            forceUpdate(callback?: (() => void) | undefined): void;
            readonly props: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>;
            state: Readonly<{}>;
            refs: {
                [key: string]: React.ReactInstance;
            };
            componentDidMount?(): void;
            shouldComponentUpdate?(nextProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, nextState: Readonly<{}>, nextContext: any): boolean;
            componentWillUnmount?(): void;
            componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, prevState: Readonly<{}>): any;
            componentDidUpdate?(prevProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, prevState: Readonly<{}>, snapshot?: any): void;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, nextState: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, nextState: Readonly<{}>, nextContext: any): void;
        };
        new (props: import("next/dist/shared/lib/utils").RenderPageResult & {
            styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
        } & import("next/dist/shared/lib/html-context").HtmlProps, context: any): {
            render(): JSX.Element;
            context: unknown;
            setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
            forceUpdate(callback?: (() => void) | undefined): void;
            readonly props: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>;
            state: Readonly<{}>;
            refs: {
                [key: string]: React.ReactInstance;
            };
            componentDidMount?(): void;
            shouldComponentUpdate?(nextProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, nextState: Readonly<{}>, nextContext: any): boolean;
            componentWillUnmount?(): void;
            componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
            getSnapshotBeforeUpdate?(prevProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, prevState: Readonly<{}>): any;
            componentDidUpdate?(prevProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, prevState: Readonly<{}>, snapshot?: any): void;
            componentWillMount?(): void;
            UNSAFE_componentWillMount?(): void;
            componentWillReceiveProps?(nextProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, nextContext: any): void;
            UNSAFE_componentWillReceiveProps?(nextProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, nextContext: any): void;
            componentWillUpdate?(nextProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, nextState: Readonly<{}>, nextContext: any): void;
            UNSAFE_componentWillUpdate?(nextProps: Readonly<import("next/dist/shared/lib/utils").RenderPageResult & {
                styles?: JSX.Element | React.ReactFragment | React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | undefined;
            } & import("next/dist/shared/lib/html-context").HtmlProps>, nextState: Readonly<{}>, nextContext: any): void;
        };
        getInitialProps(ctx: DocumentContext): Promise<{
            styles: (string | number | JSX.Element | React.ReactFragment)[];
            html: string;
            head?: (JSX.Element | null)[] | undefined;
        }>;
        contextType?: React.Context<any> | undefined;
    };
};
